const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const l of e.keys())if(l===F){const a=o[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=u;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=o[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=o[f+y]+ +b,A=o[f+y+1]+1,w=o[p+y]+1,L=o[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}R(e.get(l),t,s,n,o,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const l=new Map;l.set(u.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(u),e=l}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const l of Object.keys(u)){const a=u[l],h=e._fieldIds[l],m=o.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:N(n.boost,g)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,o,u,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f?.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,o,u,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,o,u,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(u),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=k(u),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(u,d)),u=l,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),l=u.includes("#"),[a,h]=u.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>o.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(o.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in o)for(const c of o.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":75,\"nextId\":75,\"documentIds\":{\"0\":\"v-184f4da6\",\"1\":\"v-184f4da6#你好\",\"2\":\"v-4c7489d3\",\"3\":\"v-4c7489d3@0\",\"4\":\"v-4c7489d3@1\",\"5\":\"v-54cdf850\",\"6\":\"v-54cdf850#反问\",\"7\":\"v-fb476c86\",\"8\":\"v-fb476c86#一-keepalive组件的实现原理\",\"9\":\"v-fb476c86#二-teleport组件的实现原理\",\"10\":\"v-fb476c86#三-transition组件的实现原理\",\"11\":\"v-fb476c86#四-总结\",\"12\":\"v-fb476c86@0\",\"13\":\"v-fb476c86@1\",\"14\":\"v-439497f1\",\"15\":\"v-439497f1#响应式设计\",\"16\":\"v-439497f1#渲染器设计\",\"17\":\"v-439497f1#vue设计与实现第七章-渲染器的设计\",\"18\":\"v-439497f1#vue设计与实现第八章-挂载与更新\",\"19\":\"v-439497f1#_8-1-8-3-挂在子节点和元素属性和正确的设置元素属性\",\"20\":\"v-439497f1#_8-4-class的处理\",\"21\":\"v-439497f1#_8-5-卸载操作\",\"22\":\"v-439497f1#_8-6-区分vnode的类型\",\"23\":\"v-439497f1#_8-7-事件的处理\",\"24\":\"v-439497f1#_8-8-事件冒泡与更新时机问题\",\"25\":\"v-439497f1#_8-9-更新子节点\",\"26\":\"v-439497f1#_8-10-文本注释和注释节点\",\"27\":\"v-439497f1#_8-11-fragment\",\"28\":\"v-439497f1#_8-12-总结\",\"29\":\"v-439497f1#vue设计与实现第九章-简单diff算法\",\"30\":\"v-439497f1#_9-1-减少dom操作的性能开销\",\"31\":\"v-439497f1#_9-2-dom复用和key的作用\",\"32\":\"v-439497f1#_9-3-找到需要移动的元素\",\"33\":\"v-439497f1#_9-4-如何移动\",\"34\":\"v-439497f1#_9-5-添加新元素\",\"35\":\"v-439497f1#_9-6-移除不存在的元素\",\"36\":\"v-439497f1#_9-7-总结\",\"37\":\"v-439497f1#vue设计与实现第十章-双端diff算法\",\"38\":\"v-439497f1#_10-1-双端比较的原理\",\"39\":\"v-439497f1#_10-2-添加新元素\",\"40\":\"v-439497f1#_10-3-移除旧节点\",\"41\":\"v-439497f1#vue设计与实现第十一章-快速diff算法\",\"42\":\"v-439497f1#_11-1-相同前置和后置元素\",\"43\":\"v-439497f1#_11-2-判断是否需要进行dom的移动\",\"44\":\"v-439497f1#_11-3-如何移动\",\"45\":\"v-439497f1#_11-4-总结\",\"46\":\"v-439497f1#vue设计与实现第十二章-组件的实现原理\",\"47\":\"v-439497f1@0\",\"48\":\"v-439497f1@1\",\"49\":\"v-155c4e9e\",\"50\":\"v-155c4e9e#一-介绍\",\"51\":\"v-155c4e9e#传统的渲染方式\",\"52\":\"v-155c4e9e@0\",\"53\":\"v-155c4e9e@1\",\"54\":\"v-96639358\",\"55\":\"v-96639358#编译器的流程以及parser的实现\",\"56\":\"v-96639358@0\",\"57\":\"v-96639358@1\",\"58\":\"v-16febab1\",\"59\":\"v-16febab1#_1-引言\",\"60\":\"v-16febab1#_2-组件的渲染\",\"61\":\"v-16febab1#_3-组件状态与自更新\",\"62\":\"v-16febab1#_4-组件的实例与组件的生命周期\",\"63\":\"v-16febab1#_5-props与组件的被动更新\",\"64\":\"v-16febab1@0\",\"65\":\"v-16febab1@1\",\"66\":\"v-5ff272e6\",\"67\":\"v-5ff272e6#常用项\",\"68\":\"v-5ff272e6#可选项\",\"69\":\"v-5ff272e6@0\",\"70\":\"v-5ff272e6@1\",\"71\":\"v-70bc2959\",\"72\":\"v-e1e3da16\",\"73\":\"v-1eea5c8f\",\"74\":\"v-28e4aa5b\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1],\"2\":[1,6],\"3\":[null,null,1],\"4\":[null,null,2],\"5\":[1,42],\"6\":[1,15],\"7\":[1],\"8\":[2,201],\"9\":[2,30],\"10\":[2,104],\"11\":[2,44],\"12\":[null,null,2],\"13\":[null,null,3],\"14\":[1],\"15\":[1,11],\"16\":[1,2],\"17\":[2,72],\"18\":[2],\"19\":[4,33],\"20\":[3,17],\"21\":[3,63],\"22\":[3,81],\"23\":[3,83],\"24\":[2,147],\"25\":[3,110],\"26\":[3,1],\"27\":[3,3],\"28\":[3,73],\"29\":[2],\"30\":[3,94],\"31\":[3,83],\"32\":[3,83],\"33\":[3,155],\"34\":[3,152],\"35\":[3,76],\"36\":[3,11],\"37\":[2],\"38\":[3,81],\"39\":[3,49],\"40\":[3,38],\"41\":[2],\"42\":[3,111],\"43\":[3,44],\"44\":[3,112],\"45\":[3,5],\"46\":[2],\"47\":[null,null,1],\"48\":[null,null,3],\"49\":[1],\"50\":[2,4],\"51\":[1,81],\"52\":[null,null,1],\"53\":[null,null,3],\"54\":[1],\"55\":[1,333],\"56\":[null,null,3],\"57\":[null,null,3],\"58\":[1],\"59\":[2,12],\"60\":[2,93],\"61\":[2,123],\"62\":[2,87],\"63\":[2,31],\"64\":[null,null,1],\"65\":[null,null,2],\"66\":[2,11],\"67\":[1,11],\"68\":[1,5],\"69\":[null,null,1],\"70\":[null,null,1],\"71\":[1],\"72\":[1],\"73\":[1],\"74\":[1]},\"averageFieldLength\":[2.0304277314607733,58.36623208281864,1.0411242662890483],\"storedFields\":{\"0\":{\"h\":\"博主简介\"},\"1\":{\"h\":\"你好\"},\"2\":{\"h\":\"子序列问题\",\"t\":[\"这两题都是子序列问题，题目类似。但是还未理清，先贴链接\",\"最长重复子数组\",\"最长公共子序列\"]},\"3\":{\"c\":[\"算法\"]},\"4\":{\"c\":[\"动态规划\",\"子序列问题\"]},\"5\":{\"h\":\"滴滴一面\",\"t\":[\"自我介绍，介绍项目\",\"为什么用 monorepo：因为我自己开发舒服\",\"作用域和作用域链，原型和原型链（没答好）\",\"ES6 新特性\",\"computed 和 watch\",\"Vue2 和 Vue3 的响应式区别。为什么用 proxy\",\"函数和箭头函数区别（没背八股，只说了 this 和函数提升，因为其他的一下子忘记了）\",\"用了些什么控制代码规范\",\"事件循环\",\"微宏任务队列，哪些是哪些\",\"this（没答好）\",\"CORS\",\"Nginx 的 gzip 有没有兼容性问题\",\"Vite 做了哪些优化\",\"什么是高阶函数（函数返回函数 qwq）\",\"组件的意义，是什么时候该封装\",\"手写题：Array.indexOf\"]},\"6\":{\"h\":\"反问\",\"t\":[\"我：我是第一次面，所以想问一下怎么样\",\"面试官：面试官有点意外，说还可以，比之前面试人要好，问我怎么学的\",\"我：我八股记得少，要是八股没有太多答出来，影响大吗\",\"面试官：听着都像自己理解的，不是背的，还可以。\",\"...然后我开始道谢\"]},\"7\":{\"h\":\"内建组件和模块\"},\"8\":{\"h\":\"一.keepAlive组件的实现原理\",\"t\":[\"KeepAlive 又称HTTP 持久连接（HTTP persistent connection），其作用是允许多个请求或响应共用一个 TCP 连接。由于每个HTTP请求都会建立一个新的连接并且在结束时销毁。所以当多个请求进行发送时就会导致额外的性能开销。但在响应头里把Connection字段的值设置成keep-alive，这样就能使用长连接的HTTP协议。\",\"webSocket和HTTP：https://zhuanlan.zhihu.com/p/113286469\",\"同理，对于一个组件，反复的挂载和卸载会导致很多额外的开销，KeepAlive就是用来解决这个问题的。KeepAlive本质上是对组件的缓存，将不用的组件缓存到一个看不见的地方，卸载的时候把他放进去，用的时候再拿出来。\",\"01 const KeepAlive = { 02 // KeepAlive 组件独有的属性，用作标识 03 __isKeepAlive: true, 04 setup(props, { slots }) { 05 // 创建一个缓存对象 06 // key: vnode.type 07 // value: vnode 08 const cache = new Map() 09 // 当前 KeepAlive 组件的实例 10 const instance = currentInstance 11 // 对于 KeepAlive 组件来说，它的实例上存在特殊的 keepAliveCtx 对象，该对象由渲染器注入 12 // 该对象会暴露渲染器的一些内部方法，其中 move 函数用来将一段 DOM 移动到另一个容器中 13 const { move, createElement } = instance.keepAliveCtx 14 15 // 创建隐藏容器 16 const storageContainer = createElement('div') 17 18 // KeepAlive 组件的实例上会被添加两个内部函数，分别是 _deActivate 和 _activate 19 // 这两个函数会在渲染器中被调用 20 instance._deActivate = (vnode) => { 21 move(vnode, storageContainer) 22 } 23 instance._activate = (vnode, container, anchor) => { 24 move(vnode, container, anchor) 25 } 26 27 return () => { 28 // KeepAlive 的默认插槽就是要被 KeepAlive 的组件 29 let rawVNode = slots.default() 30 // 如果不是组件，直接渲染即可，因为非组件的虚拟节点无法被 KeepAlive 31 if (typeof rawVNode.type !== 'object') { 32 return rawVNode 33 } 34 35 // 在挂载时先获取缓存的组件 vnode 36 const cachedVNode = cache.get(rawVNode.type) 37 if (cachedVNode) { 38 // 如果有缓存的内容，则说明不应该执行挂载，而应该执行激活 39 // 继承组件实例 40 rawVNode.component = cachedVNode.component 41 // 在 vnode 上添加 keptAlive 属性，标记为 true，避免渲染器重新挂载它 42 rawVNode.keptAlive = true 43 } else { 44 // 如果没有缓存，则将其添加到缓存中，这样下次激活组件时就不会执行新的挂载动作了 45 cache.set(rawVNode.type, rawVNode) 46 } 47 48 // 在组件 vnode 上添加 shouldKeepAlive 属性，并标记为 true，避免渲染器真的将组件卸载 49 rawVNode.shouldKeepAlive = true 50 // 将 KeepAlive 组件的实例也添加到 vnode 上，以便在渲染器中访问 51 rawVNode.keepAliveInstance = instance 52 53 // 渲染组件 vnode 54 return rawVNode 55 } 56 } 57 } \",\"通过以上的构建就得到了一些信息，可以明确的知道对于该组件是否是第一次挂载以及后期的激活和失活。\",\"对KeepAlive组件的实现后，就是对include和exclude以及max的实现了。对于max，就差不多是一道设计一个缓存机制的算法题，其他两个就只是单纯匹配了。总体设计不难。\",\"01 const cache = new Map() 02 const KeepAlive = { 03 __isKeepAlive: true, 04 props: { 05 include: RegExp, 06 exclude: RegExp 07 }, 08 setup(props, { slots }) { 09 // 省略部分代码 10 11 return () => { 12 let rawVNode = slots.default() 13 if (typeof rawVNode.type !== 'object') { 14 return rawVNode 15 } 16 // 获取“内部组件”的 name 17 const name = rawVNode.type.name 18 // 对 name 进行匹配 19 if ( 20 name && 21 ( 22 // 如果 name 无法被 include 匹配 23 (props.include && !props.include.test(name)) || 24 // 或者被 exclude 匹配 25 (props.exclude && props.exclude.test(name)) 26 ) 27 ) { 28 // 则直接渲染“内部组件”，不对其进行后续的缓存操作 29 return rawVNode 30 } 31 32 // 省略部分代码 33 } 34 } 35 } \"]},\"9\":{\"h\":\"二.Teleport组件的实现原理\",\"t\":[\"该组件的诞生是为了解决组件的层级关系不依赖与模板结构。就是说，父组件包了子组件，但是子组件最终挂载的地方并不是当前父组件下面。\",\"01 <Teleport to=\\\"body\\\"> 02 <h1>Title</h1> 03 <p>content</p> 04 </Teleport> \",\"本身它的意思也很明确，就是将children全部挂载到body下面去。而且这个to属性还可以进行v-bind，也就是说，还是随便放 -_- 。通过dom操作获取到指定的节点，然后将children挂载上去即可，后期更新的时候也只需要patchChildren即可。不过考虑到to的值会发送变化，所以要多加个特判来决定是否需要移动。\"]},\"10\":{\"h\":\"三.Transition组件的实现原理\",\"t\":[\"在设计原生的过渡效果的时候，需要考虑三个点，从哪来(.enter_from),到哪去(.enter_to)，如何过渡(.enter_active)。当设计好这三个点后，过渡效果就呈现出来了。这三个点对挂载和卸载都有效。\",\"// 入场动画 01 // 创建 class 为 box 的 DOM 元素 02 const el = document.createElement('div') 03 el.classList.add('box') 04 05 // 在 DOM 元素被添加到页面之前，将初始状态和运动过程定义到元素上 06 el.classList.add('enter-from') // 初始状态 07 el.classList.add('enter-active') // 运动过程 08 09 // 将元素添加到页面 10 document.body.appendChild(el) 11 12 // 嵌套调用 requestAnimationFrame 13 requestAnimationFrame(() => { 14 requestAnimationFrame(() => { 15 el.classList.remove('enter-from') // 移除 enter-from 16 el.classList.add('enter-to') // 添加 enter-to 17 }) 18 }) // 离场动画 01 el.addEventListener('click', () => { 02 // 将卸载动作封装到 performRemove 函数中 03 const performRemove = () => el.parentNode.removeChild(el) 04 05 // 设置初始状态：添加 leave-from 和 leave-active 类 06 el.classList.add('leave-from') 07 el.classList.add('leave-active') 08 09 // 强制 reflow：使初始状态生效 10 document.body.offsetHeight 11 12 // 在下一帧切换状态 13 requestAnimationFrame(() => { 14 requestAnimationFrame(() => { 15 // 切换到结束状态 16 el.classList.remove('leave-from') 17 el.classList.add('leave-to') 18 19 // 监听 transitionend 事件做收尾工作 20 el.addEventListener('transitionend', () => { 21 el.classList.remove('leave-to') 22 el.classList.remove('leave-active') 23 // 当过渡完成后，记得调用 performRemove 函数将 DOM 元素移除 24 performRemove() 25 }) 26 }) 27 }) 28 }) \",\"被Transition组件包装后的组件会添加一个transition属性，里面的内容就是一些关于DOM过渡的钩子。比如：beforeEnter，enter，leave。对于组件的过渡效果来说，具体体现的是在组件的进入和组件的退出。也就是mounted和unmounted这两个钩子。\",\"actived和unactived我不清楚是否也能激活过渡效果。\"]},\"11\":{\"h\":\"四.总结\",\"t\":[\"这些内置组件的创建都跟渲染器有紧密联系，而他们的定义是基于组件上进行修改，利用插槽函数等。\",\"对于KeepAlive组件是借用了HTTP中的长连接的概率，解决了组件的反复挂载和卸载造成的额外开销。本质上的实现是将组件缓存下来。不过考虑到缓存过多成本也很大，所以引入了一些策略上的属性，include，exclude，max。\",\"HTTP的长连接本质上是TCP的长连接，HTTP是TCP/IP协议簇的子集之一，是基于TCP/IP的应用层服务\",\"对于Teleport组件来说，实现了跨越DOM层级完成渲染的功能。Teleport组件可以避免渲染器的代码膨胀，以及使打包体积更小的原因，主要是因为它可以将子组件的内容直接移动到指定位置，而不需要创建新的真实DOM节点。具体来说，Teleport组件的实现方式是使用了DOM中的\\\"移动\\\"（move）操作，实现了将子组件的内容渲染到指定的目标位置（target）中去。这样，通过Teleport组件渲染出的子组件内容，可以在视觉上被认为是在Teleport组件外渲染的，但实际上它们并没有被添加到任何额外的DOM节点中。这就避免了因为Teleport组件造成的额外DOM节点的创建，从而减少了渲染器的工作量和代码膨胀，降低了打包体积。\",\"至于Transition组件，他就是进行对DOM的进场和离场做一个分析，然后讨论出三个钩子函数。然后在组件的进场和离场之前，将这些钩子函数执行，从而达到过渡效果。\"]},\"12\":{\"c\":[\"源码\",\"网络\"]},\"13\":{\"c\":[\"Vue\",\"KeepAlive\",\"HTTP\"]},\"14\":{\"h\":\"响应式设计和渲染器设计\"},\"15\":{\"h\":\"响应式设计\",\"t\":[\"https://github.com/JsweetA/vue-sourceCode-study/tree/reactive/reactiveBasis\",\"详细请看仓库源码注释\"]},\"16\":{\"h\":\"渲染器设计\",\"t\":[\"渲染器和响应式结合：就可以达到那种数据跟页面同步的效果\"]},\"17\":{\"h\":\"vue设计与实现第七章：渲染器的设计\",\"t\":[\"渲染函数：renderer(vnode,container)\",\"vnode:虚拟节点\",\"container：容器\",\"const count = ref(1) effect(() => { renderer(`<h1>${count.value}</h1>`, document.getElementById('app')) }) count.value++ \",\"如果该节点什么都没有，属于第一次，则它叫做挂在（mount）,反之则是oldVnode和newVnode通过patch方法比较打补丁进行渲染（也就是diff）\",\"而渲染器则是由createRenderer所创建，以下是调用该函数的返回值：\",\"render：渲染器\",\"hydrate：服务器的渲染器\",\"（还有一个，忘记了）\",\"其实不管是第一次渲染还是第二次渲染，其实都可以叫做打补丁，一般来讲第一次叫做挂载，其他叫做打补丁，毕竟渲染器的主要工作就是挂载、更新和渲染。\",\"render：\",\"if vnode is exist\",\"patch(oldVnode,vnode,container)\",\"_else _ \",\"if oldVnode is exist\",\"oldVnode = null\",\"oldVnode = vnode\",\"其中第二步是指新的不存在，而旧的存在的话，应该执行unmount操作。\",\"vnode是一个object，其中有type，children，props等属性，而render可以将这种vnode转换成真实dom，简单的这种操作就可以通过封装一个方法去调用api进行创建和挂载。不过考虑到耦合性，为了使这种模板可以在不同环境下运行，所以这种调用api的东西，挂在的东西都是外部传进这个createRenderer函数里的。\",\"vnode = { type:'h1', props:{ ... }, children:'我是一个vnodeObj' // children:[ // {...}, //] // 对象数组，里面存放的是vnode } // 转换后应该是<h1>我是一个vnodeObj</h1> \",\"总之，渲染器的作用就是将vnode渲染成真实dom，通过不断地patch\"]},\"18\":{\"h\":\"vue设计与实现第八章：挂载与更新\"},\"19\":{\"h\":\"8.1-8.3：挂在子节点和元素属性和正确的设置元素属性\",\"t\":[\"mountElement函数\",\"vnode\",\"container\",\"它会去判断vnode.children属性是否是string,是的话就直接挂在文本内容，反之如果是数组，则进行将数组内的内容全部挂在到vnode.type上，然后最后插入到container。添加el的属性有两种方式：\",\"HTML Attributes\",\"DOM Properties\",\"问题：attributes与DOM Properties不是直接映射,存在一个HTML Attributes 会关联多个DOM Properties的情况。\",\"来自书里所讲：“只需要记住一个原则：HTML Attributes 是 设置与之对应的DOM Properties的初始值”\",\"所以要正确的设置元素属性，需要看情况来进行判断赋值\",\"浏览器会自动解析HTMl代码，自动分析并且设置DOM Properties，但是Vue所采用的是vnode，所以需要自己去把这个活接过来。\"]},\"20\":{\"h\":\"8.4：class的处理\",\"t\":[\"props下的class属性有以下三种定义：\",\"class=\\\"bar foo\\\"\",\":class='{foo:true,bar:true}'\",\":class='['bar',{foo:true}]'\",\"处理该属性有一个normalizeClass函数，用来整合这些定义，全部转换为字符串的格式设置该属性有el.className,setAttribute,el.classList三种方法，但是考虑到性能问题，所以用的是el.className。于是就是接着在patchProps函数上打补丁\",\"同理，style属性也需要这种整合函数进行字符串化进行设置\"]},\"21\":{\"h\":\"8.5：卸载操作\",\"t\":[\"首次渲染后，后期渲染的vnode如果传的是null说明要执行卸载操作,但是考虑到以下几点问题\",\"容器可能是由多个组件渲染，卸载时应该调用这些组件的unmounted，beforeUnmounted生命周期函数\",\"有些元素存在自定义指令，卸载时应该要正确执行对应的指令钩子\",\"如果直接使用innerHtml去清空的话，他不会移除那些绑定在DOM元素上的钩子\",\"所以考虑到以上三点，卸载操作，应该是通过vnode获取到真实DOM,然后通过DOM的原生方法进行移除。在vnode对象上创建一个el属性，用来记录真实DOM。\",\"01 function render(vnode, container) { 02 if (vnode) { 03 patch(container._vnode, vnode, container) 04 } else { 05 if (container._vnode) { 06 // 根据 vnode 获取要卸载的真实 DOM 元素 07 const el = container._vnode.el 08 // 获取 el 的父元素 09 const parent = el.parentNode 10 // 调用 removeChild 移除元素 11 if (parent) parent.removeChild(el) 12 } 13 } 14 container._vnode = vnode 15 } 16 // container._vnode是oldVnode \",\"然后考虑到该操作会很频繁页很常见，所以封装成unmount函数。\",\"01 function unmount(vnode) { 02 const parent = vnode.el.parentNode 03 if (parent) { 04 parent.removeChild(vnode.el) 05 } 06 } 07 // 上面就只需要进行调用unmount(container._vnode) \",\"此时还有一个好处就是，他独立出去了，unmount和beforeunmounted生命周期就出现了，还可以进行检测该东东是否是组件了，是组件就可以调用前面所说的生命周期函数\"]},\"22\":{\"h\":\"8.6：区分vnode的类型\",\"t\":[\"先梳理一下执行流程\",\"通过createRenderer函数创建一个renderer\",\"通过调用renderer.render方法将vnode挂载到container上\",\"此时的render函数会进行判断 \",\"if vnode is null ：unmount(container._vnode)\",\"else vnode not is null : patch(oldVnode,newVnode,container)\",\"走到这里一定是进行patch了的，又会进行判断 \",\"if oldVnode is null :mountElement(newVnode,contaienr)\",\"else oldVnode not is ：patchElement(oldVnode,newVnode)\",\"patch函数的作用是将新旧vnode进行对比，然后把不同的地方进行替换，再渲染成真实DOM，不过考虑到所传进来的vnode并不是同一种类型，此时所作的操作应该时先卸载oldVnode,再挂载newVnode。\",\"01 function patch(n1, n2, container) { 02 // 如果 n1 存在，则对比 n1 和 n2 的类型 03 if (n1 && n1.type !== n2.type) { 04 // 如果新旧 vnode 的类型不同，则直接将旧 vnode 卸载 05 unmount(n1) 06 n1 = null 07 } 08 09 if (!n1) { 10 mountElement(n2, container) 11 } else { 12 // 更新 13 } 14 } \",\"而且除了类型上，其实不同的标签应该有不同的处理方式，所以还需要进一步的判断。\",\"01 function patch(n1, n2, container) { 02 if (n1 && n1.type !== n2.type) { 03 unmount(n1) 04 n1 = null 05 } 06 // 代码运行到这里，证明 n1 和 n2 所描述的内容相同 07 const { type } = n2 08 // 如果 n2.type 的值是字符串类型，则它描述的是普通标签元素 09 if (typeof type === 'string') { 10 if (!n1) { 11 mountElement(n2, container) 12 } else { 13 patchElement(n1, n2) 14 } 15 } else if (typeof type === 'object') { 16 // 如果 n2.type 的值的类型是对象，则它描述的是组件 17 } else if (type === 'xxx') { 18 // 处理其他类型的 vnode 19 } 20 } \"]},\"23\":{\"h\":\"8.7：事件的处理\",\"t\":[\"patchProps函数：用来对元素属性打补丁的函数。是通过createRenderer内所传的options带来的。\",\"01 patchProps(el, key, prevValue, nextValue) { 02 // 匹配以 on 开头的属性，视其为事件 03 if (/^on/.test(key)) { 04 // 根据属性名称得到对应的事件名称，例如 onClick ---> click 05 const name = key.slice(2).toLowerCase() 06 // 绑定事件，nextValue 为事件处理函数 07 el.addEventListener(name, nextValue) 08 } else if (key === 'class') { 09 // 省略部分代码 10 } else if (shouldSetAsProps(el, key, nextValue)) { 11 // 省略部分代码 12 } else { 13 // 省略部分代码 14 } 15 } \",\"事件这个也算vnode.props里，为了更明确的知道属性里哪个是事件，就统一安排on为前缀，这样就方便处理了。通过调用addEventListener绑定事件，更新跟更新vnode一样，先卸载，在挂载。\",\"性能优化：创建应该invoker,并且将函数缓存在invoker.value里面，然后调用的时候就调用这个，更新的时候覆盖invoker.value的值即可，就避免了一次remove的操作\",\"优化过性能后存在一个问题：缓存只缓存了一个，出现多个事件会进行覆盖。解决：将el._vei设置为一个对象 key->func。\",\"这里有一个新知识，之前看过一个问题，js中的object底层是什么，其实我第一想法是key-value的数据结构，然后我去问chatgpt，他说HashMap（确实嗷） 后面还有需求是一个事件可以绑定多个函数，emmm这种补丁加个判断就好了\"]},\"24\":{\"h\":\"8.8：事件冒泡与更新时机问题\",\"t\":[\"问题代码示例：\",\"01 const { effect, ref } = VueReactivity 02 03 const bol = ref(false) 04 05 effect(() => { 06 // 创建 vnode 07 const vnode = { 08 type: 'div', 09 props: bol.value ? { 10 onClick: () => { 11 alert('父元素 clicked') 12 } 13 } : {}, 14 children: [ 15 { 16 type: 'p', 17 props: { 18 onClick: () => { 19 bol.value = true 20 } 21 }, 22 children: 'text' 23 } 24 ] 25 } 26 // 渲染 vnode 27 renderer.render(vnode, document.querySelector('#app')) 28 }) \",\"此时点击p会触发他的点击事件，由于绑定了一个ref变量，父元素div的分支应该是处于{},就算事件冒泡，也不需要进行触发点击事件。但是结果却是触发了，看下图：在点击后，他修改了ref变量，于是执行了副作用函数，进行重新渲染，提前改变了使得div的点击事件进行了分支切换，并且绑定到了div上，所以会触发div的点击事件。解决方案：判断绑定事件的时间是否小于触发事件即可。\",\"我看到这的时候第一想法是，将渲染往后推，冒泡往前走，但是考虑到冒泡的事件何时开始与何时结束都是不可预料的，所以行不通\",\"01 patchProps(el, key, prevValue, nextValue) { 02 if (/^on/.test(key)) { 03 const invokers = el._vei || (el._vei = {}) 04 let invoker = invokers[key] 05 const name = key.slice(2).toLowerCase() 06 if (nextValue) { 07 if (!invoker) { 08 invoker = el._vei[key] = (e) => { 09 // e.timeStamp 是事件发生的时间 10 // 如果事件发生的时间早于事件处理函数绑定的时间，则不执行事件处理函数 11 if (e.timeStamp < invoker.attached) return 12 if (Array.isArray(invoker.value)) { 13 invoker.value.forEach(fn => fn(e)) 14 } else { 15 invoker.value(e) 16 } 17 } 18 invoker.value = nextValue 19 // 添加 invoker.attached 属性，存储事件处理函数被绑定的时间 20 invoker.attached = performance.now() 21 el.addEventListener(name, invoker) 22 } else { 23 invoker.value = nextValue 24 } 25 } else if (invoker) { 26 el.removeEventListener(name, invoker) 27 } 28 } else if (key === 'class') { 29 // 省略部分代码 30 } else if (shouldSetAsProps(el, key, nextValue)) { 31 // 省略部分代码 32 } else { 33 // 省略部分代码 34 } 35 } \",\"来自书中的补充： “在关于时间的存储和比较方面，我们使用的是高精时间，即 performance.now。但根据浏览器的不同，e.timeStamp 的值也会有所不同。它既可能是高精时间，也可能是非高精时间。因此，严格来讲，这里需要做兼容处理。不过在 Chrome 49、Firefox 54、Opera 36 以及之后的版本中，e.timeStamp 的值都是高精时间。”\"]},\"25\":{\"h\":\"8.9：更新子节点\",\"t\":[\"子元素的状态：\",\"没有子节点，此时 vnode.children 的值为 null。\",\"具有文本子节点，此时 vnode.children 的值为字符串，代表文本的内容。\",\"其他情况，无论是单个元素子节点，还是多个子节点（可能是文本和元素的混合），都可以用数组来表示。\",\"01 // 没有子节点 02 vnode = { 03 type: 'div', 04 children: null 05 } 06 // 文本子节点 07 vnode = { 08 type: 'div', 09 children: 'Some Text' 10 } 11 // 其他情况，子节点使用数组表示 12 vnode = { 13 type: 'div', 14 children: [ 15 { type: 'p' }, 16 'Some Text' 17 ] 18 } \",\"patchElement函数主要执行两个功能\",\"patchProps\",\"patchChildren\",\"这章主要讲的是patchChildren函数。\",\"对于更新children，我的想法是，卸载原有的，安装新的。不过为了使这个方法更加强大，所以需要做一些判断\",\"01 function patchChildren(n1, n2, container) { 02 if (typeof n2.children === 'string') { 03 if (Array.isArray(n1.children)) { 04 n1.children.forEach((c) => unmount(c)) 05 } 06 setElementText(container, n2.children) 07 } else if (Array.isArray(n2.children)) { 08 if (Array.isArray(n1.children)) { 09 // diff 10 } else { 11 setElementText(container, '') 12 n2.children.forEach(c => patch(null, c, container)) 13 } 14 } else { 15 // 代码运行到这里，说明新子节点不存在 16 // 旧子节点是一组子节点，只需逐个卸载即可 17 if (Array.isArray(n1.children)) { 18 n1.children.forEach(c => unmount(c)) 19 } else if (typeof n1.children === 'string') { 20 // 旧子节点是文本子节点，清空内容即可 21 setElementText(container, '') 22 } 23 // 如果也没有旧子节点，那么什么都不需要做 24 } 25 } \",\"代码如上，分析如下：\",\"判断_newVnode_是否是_string_\",\"如果是，则判断_oldVnode_是否是数组\",\"如果是就逐个卸载，并且挂在文本\",\"不是数组就不需要管，直接挂载文本\",\"当不是_string_的时候，判断_newVnode_是否是数组\",\"如果是，则判断_oldVnode_是否是数组\",\"_Diff_算法\",\"卸载文本，再挂载数组\",\"既不是_string_,也不是数组，这里的_newVnode_就一定时空了\",\"重复如第一步的操作一样，只需要把后面挂载文本改成挂在_''_\"]},\"26\":{\"h\":\"8.10：文本注释和注释节点\",\"t\":[\"...\"]},\"27\":{\"h\":\"8.11：Fragment\",\"t\":[\"名为片段，作用是解决了vue2不支持多根节点模板的问题。\"]},\"28\":{\"h\":\"8.12：总结\",\"t\":[\"章节总结自己翻书。\",\"1.render函数：\",\"首先调用render函数，传递vnode，container两个参数 \",\"进入render函数后会进行判断vnode是否是null\",\"是null则进行unmount的操作\",\"反之则进行patch操作，进行对oldVnode和newVnode比较\",\"2.patch函数：\",\"进入patch函数后判断新旧vnode的类型是否一样，不是一样就先卸载oldVnode\",\"取出newVnode的类型，这里有Text，Comment，Fragment，Static，default\",\"如果是前四种类型的节点，则会调用对应的process方法进行挂载到container上\",\"这个分支是default的执行，会判断节点是组件还是节点，如果是节点则调用processElement方法，反之则调用processComponent方法\",\"3.processElement函数：\",\"判断oldVnode是否是空，是空的话则调用mountElement方法\",\"反之调用patchElement方法\",\"4.mountElement函数：\",\"因为是第一次挂载，进行创建DOM el\",\"然后判断children类型是string还是array\",\"是string则进行挂载文本\",\"反之进行循环遍历数组进行patch子节点\",\"调用patchProps函数添加属性\",\"5.patchProps函数：\",\"对于class，style，event都是特殊属性，需要做特殊处理，调用对应的patch-函数\",\"除了以上三个，就是属性了，根据属性自身特性进行对应挂载。\",\"还有vue的指令挂载\",\"5.patchElement函数：\",\"更新props通过调用patchProps方法\",\"更新children通过调用patchChildren\",\"源码里面其实还做了其他的操作，而且patch，应该接着patch指令，我这些总结是一部分书上一部分源码上的，函数名都能从源码里找到的\",\"6.patchChildren函数：\",\"判断newVnode.children是不是string\",\"判断oldVnode.children是不是array是的话就循环卸载oldVnode.children\",\"判断newVnode.children是不是array\",\"判断oldVnode.children是不是array,如果是就进行diff算法，反之则循环挂载newVnode.children\",\"既不是string也不是array,那只能是null\",\"卸载oldVnode\"]},\"29\":{\"h\":\"vue设计与实现第九章：简单Diff算法\"},\"30\":{\"h\":\"9.1：减少DOM操作的性能开销\",\"t\":[\"旧的patchChildren在处理新旧vnode都是array时，是先全部卸载oldVnode,再挂载newVnode，算法的成本很大。有时候有一些节点，单纯可能只是文本值改变了，并不需要卸载和挂载操作，只需要更新文本值即可。于是diff算法就是来解决这个问题的。方案一：逐个比较新旧vnode.children，解决了DOM的开销，但问题却是，如果新旧vnode的个数不一样，所以需要考虑新旧vnode.children的长度，旧的多了应该卸载，新的多了应该挂载，不能只是单纯的更新。\",\"01 function patchChildren(n1, n2, container) { 02 if (typeof n2.children === 'string') { 03 // 省略部分代码 04 } else if (Array.isArray(n2.children)) { 05 const oldChildren = n1.children 06 const newChildren = n2.children 07 // 旧的一组子节点的长度 08 const oldLen = oldChildren.length 09 // 新的一组子节点的长度 10 const newLen = newChildren.length 11 // 两组子节点的公共长度，即两者中较短的那一组子节点的长度 12 const commonLength = Math.min(oldLen, newLen) 13 // 遍历 commonLength 次 14 for (let i = 0; i < commonLength; i++) { 15 patch(oldChildren[i], newChildren[i], container) 16 } 17 // 如果 newLen > oldLen，说明有新子节点需要挂载 18 if (newLen > oldLen) { 19 for (let i = commonLength; i < newLen; i++) { 20 patch(null, newChildren[i], container) 21 } 22 } else if (oldLen > newLen) { 23 // 如果 oldLen > newLen，说明有旧子节点需要卸载 24 for (let i = commonLength; i < oldLen; i++) { 25 unmount(oldChildren[i]) 26 } 27 } 28 } else { 29 // 省略部分代码 30 } 31 } \"]},\"31\":{\"h\":\"9.2：DOM复用和key的作用\",\"t\":[\"有些时候，新旧vnode.children的内容有很多相同，不需要做改动的操作，这个时候，这些相同的DOM是可以保留下面，不需要更新也不需要挂载和卸载，所以下一个优化方向是，如何知道这个DOM既出现在oldVnode.children，也出现在newVnode.children。引入key,唯一标识符。这样就可以知道在不在了。但是，key相同，并不一定意味着可以直接复用，他们的children可能会不一样。\",\"01 function patchChildren(n1, n2, container) { 02 if (typeof n2.children === 'string') { 03 // 省略部分代码 04 } else if (Array.isArray(n2.children)) { 05 const oldChildren = n1.children 06 const newChildren = n2.children 07 08 // 遍历新的 children 09 for (let i = 0; i < newChildren.length; i++) { 10 const newVNode = newChildren[i] 11 // 遍历旧的 children 12 for (let j = 0; j < oldChildren.length; j++) { 13 const oldVNode = oldChildren[j] 14 // 如果找到了具有相同 key 值的两个节点，说明可以复用，但仍然需要调用 patch 函数更新 15 if (newVNode.key === oldVNode.key) { 16 patch(oldVNode, newVNode, container) 17 break // 这里需要 break 18 } 19 } 20 } 21 22 } else { 23 // 省略部分代码 24 } 25 } \"]},\"32\":{\"h\":\"9.3：找到需要移动的元素\",\"t\":[\"上面解决了找到可复用的节点。这里就是用来考虑该节点是否需要移动。如何判断该元素需要移动：如果索引值具有单调递增的特性，说明不需要移动，但是中途有索引比当前状态下的最大索引要小，说明该节点需要移动。\",\"01 function patchChildren(n1, n2, container) { 02 if (typeof n2.children === 'string') { 03 // 省略部分代码 04 } else if (Array.isArray(n2.children)) { 05 const oldChildren = n1.children 06 const newChildren = n2.children 07 08 // 用来存储寻找过程中遇到的最大索引值 09 let lastIndex = 0 10 for (let i = 0; i < newChildren.length; i++) { 11 const newVNode = newChildren[i] 12 for (let j = 0; j < oldChildren.length; j++) { 13 const oldVNode = oldChildren[j] 14 if (newVNode.key === oldVNode.key) { 15 patch(oldVNode, newVNode, container) 16 if (j < lastIndex) { 17 // 如果当前找到的节点在旧 children 中的索引小于最大索引值 lastIndex， 18 // 说明该节点对应的真实 DOM 需要移动 19 } else { 20 // 如果当前找到的节点在旧 children 中的索引不小于最大索引值， 21 // 则更新 lastIndex 的值 22 lastIndex = j 23 } 24 break // 这里需要 break 25 } 26 } 27 } 28 29 } else { 30 // 省略部分代码 31 } 32 } \"]},\"33\":{\"h\":\"9.4：如何移动\",\"t\":[\"这里的移动是值移动真实DOM，而不是移动虚拟DOM。\",\"如果移动的是vnode，那又需要挂载，等于白干\",\"vnode.el记录的是真实DOM,所以可以利用它来进行DOM的移动。根据上面的算法来模拟一遍，起始的索引是0，遍历新子节点数组，如何在旧子节点数组里第一个元素p-3可得，索引为2，此时2比起始索引大（最大索引记为lastIndex），所以p-3不需要移动，并且更新lastIndex为2。接着找p-1的索引，值为0，比lastIndex要小，说明需要移动，移动到何处，由新子节点的顺序规定，也就是移动到newVnode[i - 1]的后面。然后就是p-2，跟找p-1同理。看代码：\",\"anchor：锚点，用于移动到哪，配合insertBefore使用。\",\"el.nextSibling：获取兄弟节点的下一个节点，然后赋值给anchor。\",\"insertBefore：两个参数，第一个参数为需要插入的节点，第二个参数是位置。\",\"01 function patchChildren(n1, n2, container) { 02 if (typeof n2.children === 'string') { 03 // 省略部分代码 04 } else if (Array.isArray(n2.children)) { 05 const oldChildren = n1.children 06 const newChildren = n2.children 07 08 let lastIndex = 0 09 for (let i = 0; i < newChildren.length; i++) { 10 const newVNode = newChildren[i] 11 let j = 0 12 for (j; j < oldChildren.length; j++) { 13 const oldVNode = oldChildren[j] 14 if (newVNode.key === oldVNode.key) { 15 patch(oldVNode, newVNode, container) 16 if (j < lastIndex) { 17 // 代码运行到这里，说明 newVNode 对应的真实 DOM 需要移动 18 // 先获取 newVNode 的前一个 vnode，即 prevVNode 19 const prevVNode = newChildren[i - 1] 20 // 如果 prevVNode 不存在，则说明当前 newVNode 是第一个节点，它不需要移动 21 if (prevVNode) { 22 // 由于我们要将 newVNode 对应的真实 DOM 移动到 prevVNode 所对应真实 DOM 后面， 23 // 所以我们需要获取 prevVNode 所对应真实 DOM 的下一个兄弟节点，并将其作为锚点 24 const anchor = prevVNode.el.nextSibling 25 // 调用 insert 方法将 newVNode 对应的真实 DOM 插入到锚点元素前面， 26 // 也就是 prevVNode 对应真实 DOM 的后面 27 insert(newVNode.el, container, anchor) 28 } 29 } else { 30 lastIndex = j 31 } 32 break 33 } 34 } 35 } 36 37 } else { 38 // 省略部分代码 39 } 40 } 01 const renderer = createRenderer({ 02 // 省略部分代码 03 04 insert(el, parent, anchor = null) { 05 // insertBefore 需要锚点元素 anchor 06 parent.insertBefore(el, anchor) // 如果anchor为null，则会插入到最后面 07 } 08 09 // 省略部分代码 10 }) \",\"看图：\"]},\"34\":{\"h\":\"9.5：添加新元素\",\"t\":[\"新增节点考虑的问题如下：\",\"哪个需要新增\",\"新增的该放哪\",\"问题一在前面设置key的时候就已经解决了，如果新子节点数组内有的而旧的没有的话，说明是新增。问题二其实也简单，因为在新子节点数组里是规定好了顺序，并且也跟对应的真实DOM有联系，所以直接挂载就可以了。\",\"01 function patchChildren(n1, n2, container) { 02 if (typeof n2.children === 'string') { 03 // 省略部分代码 04 } else if (Array.isArray(n2.children)) { 05 const oldChildren = n1.children 06 const newChildren = n2.children 07 08 let lastIndex = 0 09 for (let i = 0; i < newChildren.length; i++) { 10 const newVNode = newChildren[i] 11 let j = 0 12 // 在第一层循环中定义变量 find，代表是否在旧的一组子节点中找到可复用的节点， 13 // 初始值为 false，代表没找到 14 let find = false 15 for (j; j < oldChildren.length; j++) { 16 const oldVNode = oldChildren[j] 17 if (newVNode.key === oldVNode.key) { 18 // 一旦找到可复用的节点，则将变量 find 的值设为 true 19 find = true 20 patch(oldVNode, newVNode, container) 21 if (j < lastIndex) { 22 const prevVNode = newChildren[i - 1] 23 if (prevVNode) { 24 const anchor = prevVNode.el.nextSibling 25 insert(newVNode.el, container, anchor) 26 } 27 } else { 28 lastIndex = j 29 } 30 break 31 } 32 } 33 // 如果代码运行到这里，find 仍然为 false， 34 // 说明当前 newVNode 没有在旧的一组子节点中找到可复用的节点 35 // 也就是说，当前 newVNode 是新增节点，需要挂载 36 if (!find) { 37 // 为了将节点挂载到正确位置，我们需要先获取锚点元素 38 // 首先获取当前 newVNode 的前一个 vnode 节点 39 const prevVNode = newChildren[i - 1] 40 let anchor = null 41 if (prevVNode) { 42 // 如果有前一个 vnode 节点，则使用它的下一个兄弟节点作为锚点元素 43 anchor = prevVNode.el.nextSibling 44 } else { 45 // 如果没有前一个 vnode 节点，说明即将挂载的新节点是第一个子节点 46 // 这时我们使用容器元素的 firstChild 作为锚点 47 anchor = container.firstChild 48 } 49 // 挂载 newVNode 50 patch(null, newVNode, container, anchor) 51 } 52 } 53 54 } else { 55 // 省略部分代码 56 } 57 } 01 // patch 函数需要接收第四个参数，即锚点元素 02 function patch(n1, n2, container, anchor) { 03 // 省略部分代码 04 05 if (typeof type === 'string') { 06 if (!n1) { 07 // 挂载时将锚点元素作为第三个参数传递给 mountElement 函数 08 mountElement(n2, container, anchor) 09 } else { 10 patchElement(n1, n2) 11 } 12 } else if (type === Text) { 13 // 省略部分代码 14 } else if (type === Fragment) { 15 // 省略部分代码 16 } 17 } 18 19 // mountElement 函数需要增加第三个参数，即锚点元素 20 function mountElement(vnode, container, anchor) { 21 // 省略部分代码 22 23 // 在插入节点时，将锚点元素透传给 insert 函数 24 insert(el, container, anchor) 25 } \"]},\"35\":{\"h\":\"9.6：移除不存在的元素\",\"t\":[\"遍历旧子数组，如果旧的有而新的没有说明要移除。\",\"01 function patchChildren(n1, n2, container) { 02 if (typeof n2.children === 'string') { 03 // 省略部分代码 04 } else if (Array.isArray(n2.children)) { 05 const oldChildren = n1.children 06 const newChildren = n2.children 07 08 let lastIndex = 0 09 for (let i = 0; i < newChildren.length; i++) { 10 // 省略部分代码 11 } 12 13 // 上一步的更新操作完成后 14 // 遍历旧的一组子节点 15 for (let i = 0; i < oldChildren.length; i++) { 16 const oldVNode = oldChildren[i] 17 // 拿旧子节点 oldVNode 去新的一组子节点中寻找具有相同 key 值的节点 18 const has = newChildren.find( 19 vnode => vnode.key === oldVNode.key 20 ) 21 if (!has) { 22 // 如果没有找到具有相同 key 值的节点，则说明需要删除该节点 23 // 调用 unmount 函数将其卸载 24 unmount(oldVNode) 25 } 26 } 27 28 } else { 29 // 省略部分代码 30 } 31 } \"]},\"36\":{\"h\":\"9.7：总结\",\"t\":[\"Diff算法是用来计算两组子节点的差异，并且最大程度上来复用DOM元素。改进前是全部卸载再挂载，改进后是遍历新旧子节点数量，需要更新的更新，需要卸载的卸载，需要增加的增加。其中引入了key，是Diff算法里一个非常重要的角色。然后还讲了如何移动添加删除等等。\"]},\"37\":{\"h\":\"vue设计与实现第十章：双端Diff算法\"},\"38\":{\"h\":\"10.1：双端比较的原理\",\"t\":[\"简单Diff算法执行流程：遍历newChildren，在oldChildren 里找newChildren[i]的索引，并且维护一个lastIndex记录最大索引\",\"如果i < lastIndex则将newChildren[i]的真实Dom移动到newChildren[i - 1]下面，\",\"否则不动，并且更新lastIndex\",\"缺点：如图所示，对于新旧vnode去操作Dom的时候，他是将p-1，p-2往下移。进行了两次操作，假设如果oldVnode是从p1-pn,而newVnode的顺序是pn,p1-pn-1,以简单Diff算法来说，他是不是会进行操作n-1此Dom的移动，但是实际上，只需要将pn移动到最下面，就能完成操作。这就是双端Diff算法 优化的一个方向。双端Diff算法执行流程：上面是该算法的变量，下面是该算法每次都要执行的四步\",\"第一步比较新旧节点的startVnode：对应index往下走\",\"第二步比较新旧节点的endVnode：对应index往上走\",\"第三步比较newStartVnode和oldEndVnode：新的往下走，旧的往上走，并且把oldEndVnode插入到oldStartVnode的上面\",\"第四步比较newEndVnode和oldStartVnode：新的往上走，旧的往下走，并且把oldStartVnode插入到oldEndVnode的下面\",\"通过比较key值，判断他们是否可复用，如果可复用，则走对应分支，并且更新对应的index。\",\"对于每一个分支，第一步都需要patch\",\"上面是理想状态下的双端Diff算法比较，他能跑起来的前提是，至少有一个分支能走，但是有时候会出现，双端，都走不了的情况，这个时候，他就会走第五步。\",\"第五步，拿newStartVnode在旧的里面找，找到所在的位置，并且记录为oldToVnode，并且将这个oldToVnode移动到oldStartVnode的上面。\",\"这里暂不考虑没找到的情况，如果没找到，就意味着新增了\",\"此时，就将newStartVode的位置排好了，在而oldToVnode的位置的Vnode是已经走过了的，避免下一次循环再走，所以把它置为undefined，下一轮变量的时候，在加个对oldStartVnode做一下特殊处理，值是undefined直接跳过就好了。\"]},\"39\":{\"h\":\"10.2：添加新元素\",\"t\":[\"对于双端Diff算法的原理，上面分析了该算法如何执行，分析了在理想状态和非理想状态的情况，也就是对于头和尾能不能找到对应的并且移动的情况。在非理想状态下，新旧子数组不能保证他能直接找到，新增分支5用来做特殊处理，以及新增特殊判断，判断该Vnode是否已经移动过了。但是对于非理性状态，也并不是总能找到，这种情况，就属于新增节点。\",\"白话：我新数组里有，你旧的没有，所以新增\",\"逻辑还是挺简单的，就是在分支5中加个判断，如果没有找到重复的key那就将newStartVnoe插入到oldStartVnode的上面即可。但是这还有缺陷，看例子：\",\"newChildren：4，1，2，3\",\"oldChildren：1，2，3\",\"他们开始跑代码，会发现尾部一直相同，那么就一直会走分支2，然后一直跳过，然后oldEndIndex会变成-1，oldStartIndex还是1，循环结束。但是对于newChildren的4，他并没有做任何操作，被遗弃了。所以，还需要在分支5加个判断，判断newChildren是否有遗留，也就是newStartIndex <= newEndIndex && oldStartIndex > oldEndIndex，这时候需要将newStartIndex到newEndIndex之间的所有结点挂载到头部。\"]},\"40\":{\"h\":\"10.3：移除旧节点\",\"t\":[\"判断新增是通过判断oldEnd是否小于oldStart并且满足newStart要小于等于newEnd，而判断移除也差不多，就是判断newEnd是否小于newStart并且满足oldStart要小于等于oldEnd，满足条件就逐个unmount。\",\"01 while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) { 02 // 省略部分代码 移动节点五个分支 03 } 04 05 if (oldEndIdx < oldStartIdx && newStartIdx <= newEndIdx) { 06 // 添加新节点 07 // 省略部分代码 08 } else if (newEndIdx < newStartIdx && oldStartIdx <= oldEndIdx) { 09 // 移除操作 10 for (let i = oldStartIdx; i <= oldEndIdx; i++) { 11 unmount(oldChildren[i]) 12 } 13 } \"]},\"41\":{\"h\":\"vue设计与实现第十一章：快速Diff算法\"},\"42\":{\"h\":\"11.1：相同前置和后置元素\",\"t\":[\"快速Diff算法与前两个Diff算法的区别就是它具有一个预处理的过程。何为预处理？本质上来讲就是，晒掉相同的，留下不同的，我只需要去管理不同的部分，并且对该部分进行crud操作。看这边例子：\",\"01 TEXT1: I use vue for app development 02 TEXT2: I use react for app development \",\"两段文本，仔细发现其实只有vue和react不一样，前后都一样。那么这说明，真正需要操作的其实只有这两个。\",\"01 TEXT1: I like you 02 TEXT2: I like you too \",\"这段也一样，只需要处理后面即可。如果引申到vnode上，看如下的图：对于相同的，我们完全不需要去处理它，只需找到不同即可。代码也简单，开两个while循环，然后从顶部和底部遍历掉这些相同节点，将索引去指向需要Diff的区域即可。\",\"01 function patchKeyedChildren(n1, n2, container) { 02 const newChildren = n2.children 03 const oldChildren = n1.children 04 // 更新相同的前置节点 05 let j = 0 06 let oldVNode = oldChildren[j] 07 let newVNode = newChildren[j] 08 while (oldVNode.key === newVNode.key) { 09 patch(oldVNode, newVNode, container) 10 j++ 11 oldVNode = oldChildren[j] 12 newVNode = newChildren[j] 13 } 14 15 // 更新相同的后置节点 16 // 索引 oldEnd 指向旧的一组子节点的最后一个节点 17 let oldEnd = oldChildren.length - 1 18 // 索引 newEnd 指向新的一组子节点的最后一个节点 19 let newEnd = newChildren.length - 1 20 21 oldVNode = oldChildren[oldEnd] 22 newVNode = newChildren[newEnd] 23 24 // while 循环从后向前遍历，直到遇到拥有不同 key 值的节点为止 25 while (oldVNode.key === newVNode.key) { 26 // 调用 patch 函数进行更新 27 patch(oldVNode, newVNode, container) 28 // 递减 oldEnd 和 nextEnd 29 oldEnd-- 30 newEnd-- 31 oldVNode = oldChildren[oldEnd] 32 newVNode = newChildren[newEnd] 33 } 34 35 } \",\"这里的新增节点和需要移除的节点跟双端那边类似，只是索引变量名字稍微有点变化。\"]},\"43\":{\"h\":\"11.2：判断是否需要进行DOM的移动\",\"t\":[\"简明的说，对于以上的预处理以及算法的设计，是在理想状态下的。世间总是不那么尽人意。所以这些节点就是喜欢来给你出问题。比如以下的节点：\",\"newChildren：2 3 1 5 6 4 7 8\",\"oldChildren：2 9 2 5 4 7 2 8\",\"通过预处理后，只有削去了前面第一个和后面第一个，按照上面算法来跑，说明这之间的又得全部卸载和全部挂在，这明显又回到了原地，不符合快速的这一名称。Diff算法，本质上来讲就是想尽可能地减少DOM操作，对于上面的节点，有些还是比较类似的，这说明也还是可以复用，这就回到了如何移动这些可复用的DOM元素上。\",\"不管哪种diff算法，他们终究都需要去做两件事情 1、判断是否需要移动 2、找到需要新增的和需要卸载的\",\"所以，对于非理想情况，应该再开一个分支进行去处理它。算法的设计是建立一个source数组，里面的内容是中间不理想区域的一个索引，也就是对于新节点在旧节点上的索引值。然后通过这个source函数，利用简单Diff算法的思路找出需要移动的节点，也就是序列保持递增时说明不需要移动，反之则需要移动。\"]},\"44\":{\"h\":\"11.3：如何移动\",\"t\":[\"基于上面的条件，我们实现了两个目标。\",\"判断是否需要移动\",\"source数组\",\"这个source数组可不一般，精髓所在，后续通过它，计算出一个最长递增子序列，然后再去移动Dom。\",\"最长递增子序列：https://juejin.cn/post/7134499769803603999\",\"找出最长递增子序列的区间，该区间记录的是在newChildren中这段上升子序列的索引值。构建一个s和i。\",\"s：表示最长递增子序列的尾部索引\",\"i：表示newChildren中预处理后的尾部索引\",\"接着，开始遍历。算法的设计如下：\",\"如果source[i]的值为-1，这表明该节点需要新增\",\"如果i！== seq[s]，表明该节点需要移动，直接将该节点移动到他应该所在的位置\",\"如果前两个分支都没走，说明i === seq[i]的，这是可复用的节点，不需要做任何Dom操作。尾部提升就行。\",\"01 if (moved) { 02 const seq = lis(sources) 03 04 // s 指向最长递增子序列的最后一个元素 05 let s = seq.length - 1 06 let i = count - 1 07 for (i; i >= 0; i--) { 08 if (source[i] === -1) { 09 // 下面是插入，这里是挂载，位置的获取和下面一样，只是需要特判一下是否是最下面 10 } else if (i !== seq[s]) { 11 // 说明该节点需要移动 12 // 该节点在新的一组子节点中的真实位置索引 13 const pos = i + newStart 14 const newVNode = newChildren[pos] 15 // 该节点的下一个节点的位置索引 16 const nextPos = pos + 1 17 // 锚点 18 const anchor = nextPos < newChildren.length 19 ? newChildren[nextPos].el 20 : null 21 // 移动 22 insert(newVNode.el, container, anchor) 23 } else { 24 // 当 i === seq[s] 时，说明该位置的节点不需要移动 25 // 并让 s 指向下一个位置 26 s-- 27 } 28 } 29 } \"]},\"45\":{\"h\":\"11.4：总结\",\"t\":[\"预处理，减少Dom操作，并且还能精确到当前组件。因为快所以叫快速。\"]},\"46\":{\"h\":\"vue设计与实现第十二章：组件的实现原理\"},\"47\":{\"c\":[\"源码\"]},\"48\":{\"c\":[\"Vue\",\"VNode\",\"AST\"]},\"49\":{\"h\":\"服务端渲染\"},\"50\":{\"h\":\"一.介绍\",\"t\":[\"vue框架提供了两种渲染模式，即客户端渲染和服务器渲染。这两个方式的本质区别就是对于谁负责解析模板。\"]},\"51\":{\"h\":\"传统的渲染方式\",\"t\":[\"image.png\",\"客户端发送请求给服务器\",\"服务器向数据库请求数据\",\"数据库将数据返回给服务器\",\"服务器将html,css,js发送给客户端\",\"客户端进行渲染\",\"这是传统的客户端的渲染方式。但是在这个阶段，服务器返回给的html只是一个普通的html，内部什么都没有，只有一个<div id='app'></div>这个东西(除开那些必要的标签外)。如下面代码：\",\"01 <!DOCTYPE html> 02 <html lang=\\\"zh\\\"> 03 <head> 04 <meta charset=\\\"UTF-8\\\"> 05 <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\"> 06 <title>My App</title> 07 <link rel=\\\"stylesheet\\\" href=\\\"/dist/app.css\\\"> 08 </head> 09 <body> 10 <div id=\\\"app\\\"></div> 11 12 <script src=\\\"/dist/app.js\\\"></script> 13 </body> 14 </html> \",\"此时，当客户端接收这个html后，交给浏览器，浏览器就会开始解析。但是由于这个html是什么都没有的，所以就会出现白屏的现象。然后当遇见script，link标签后，浏览器才会慢慢开始渲染出页面。\"]},\"52\":{\"c\":[\"源码\"]},\"53\":{\"c\":[\"Vue\",\"客户端渲染\",\"服务端渲染\"]},\"54\":{\"h\":\"模板编译器\"},\"55\":{\"h\":\"编译器的流程以及parser的实现\",\"t\":[\"编译一般的步骤由词法分析，语法分析，语义分析，中间代码生成，优化，目标代码生成等步骤。\",\"可以看到，整个编译过程分为编译前端和编译后端。编译前端包含词法分析、语法分析和语义分析，它通常与目标平台无关，仅负责分析源代码。编译后端则通常与目标平台有关，编译后端涉及中间代码生成和优化以及目标代码生成。但是，编译后端并不一定会包含中间代码生成和优化这两个环节，这取决于具体的场景和实现。中间代码生成和优化这两个环节有时也叫“中端”。\",\"对于vue来说，编译器的功能就是将模板语法编译成渲染器能识别的render()。但是这中间这个过程需要先将模板语法编译成模板AST，再将模板AST转换成JSAST，最后通过JSAST生成render()。\",\"对于编译来说，vue编译出来的这种语言叫做DSL（领域特定语言），也就是针对某一种特定环境而产生的语言，类似的有HTML这些。\",\"// 编译前 01 <div> 02 <h1 v-if=\\\"ok\\\">Vue Template</h1> 03 </div> // 通过parser编译后 01 const ast = { 02 // 逻辑根节点 03 type: 'Root', 04 children: [ 05 // div 标签节点 06 { 07 type: 'Element', 08 tag: 'div', 09 children: [ 10 // h1 标签节点 11 { 12 type: 'Element', 13 tag: 'h1', 14 props: [ 15 // v-if 指令节点 16 { 17 type: 'Directive', // 类型为 Directive 代表指令 18 name: 'if'， // 指令名称为 if，不带有前缀 v- 19 exp: { 20 // 表达式节点 21 type: 'Expression', 22 content: 'ok' 23 } 24 } 25 ] 26 } 27 ] 28 } 29 ] 30 } \",\"上面的代码片段就是parser所需要实现的功能。这个函数利用的算法是有限状态自动机。它是通过逐步遍历模板字符串，然后进行对状态的逐步改变。比如当读取到<时，说明状态是开启了一个新标签，直到遇见>之前，这之间所遇到的所有字符串都将成为标签名，所以通过这种思想，可以把有限的状态列出来，读取时进行不同状态的转换，进行收集不同的数据。\",\"01 // 定义状态机的状态 02 const State = { 03 initial: 1, // 初始状态 04 tagOpen: 2, // 标签开始状态 05 tagName: 3, // 标签名称状态 06 text: 4, // 文本状态 07 tagEnd: 5, // 结束标签状态 08 tagEndName: 6 // 结束标签名称状态 09 } 10 // 一个辅助函数，用于判断是否是字母 11 function isAlpha(char) { 12 return char >= 'a' && char <= 'z' || char >= 'A' && char <= 'Z' 13 } 14 15 // 接收模板字符串作为参数，并将模板切割为 Token 返回 16 function tokenize(str) { 17 // 状态机的当前状态：初始状态 18 let currentState = State.initial 19 // 用于缓存字符 20 const chars = [] 21 // 生成的 Token 会存储到 tokens 数组中，并作为函数的返回值返回 22 const tokens = [] 23 // 使用 while 循环开启自动机，只要模板字符串没有被消费尽，自动机就会一直运行 24 while(str) { 25 // 查看第一个字符，注意，这里只是查看，没有消费该字符 26 const char = str[0] 27 // switch 语句匹配当前状态 28 switch (currentState) { 29 // 状态机当前处于初始状态 30 case State.initial: 31 // 遇到字符 < 32 if (char === '<') { 33 // 1. 状态机切换到标签开始状态 34 currentState = State.tagOpen 35 // 2. 消费字符 < 36 str = str.slice(1) 37 } else if (isAlpha(char)) { 38 // 1. 遇到字母，切换到文本状态 39 currentState = State.text 40 // 2. 将当前字母缓存到 chars 数组 41 chars.push(char) 42 // 3. 消费当前字符 43 str = str.slice(1) 44 } 45 break 46 // 状态机当前处于标签开始状态 47 case State.tagOpen: 48 if (isAlpha(char)) { 49 // 1. 遇到字母，切换到标签名称状态 50 currentState = State.tagName 51 // 2. 将当前字符缓存到 chars 数组 52 chars.push(char) 53 // 3. 消费当前字符 54 str = str.slice(1) 55 } else if (char === '/') { 56 // 1. 遇到字符 /，切换到结束标签状态 57 currentState = State.tagEnd 58 // 2. 消费字符 / 59 str = str.slice(1) 60 } 61 break 62 // 状态机当前处于标签名称状态 63 case State.tagName: 64 if (isAlpha(char)) { 65 // 1. 遇到字母，由于当前处于标签名称状态，所以不需要切换状态， 66 // 但需要将当前字符缓存到 chars 数组 67 chars.push(char) 68 // 2. 消费当前字符 69 str = str.slice(1) 70 } else if (char === '>') { 71 // 1.遇到字符 >，切换到初始状态 72 currentState = State.initial 73 // 2. 同时创建一个标签 Token，并添加到 tokens 数组中 74 // 注意，此时 chars 数组中缓存的字符就是标签名称 75 tokens.push({ 76 type: 'tag', 77 name: chars.join('') 78 }) 79 // 3. chars 数组的内容已经被消费，清空它 80 chars.length = 0 81 // 4. 同时消费当前字符 > 82 str = str.slice(1) 83 } 84 break 85 // 状态机当前处于文本状态 86 case State.text: 87 if (isAlpha(char)) { 88 // 1. 遇到字母，保持状态不变，但应该将当前字符缓存到 chars 数组 89 chars.push(char) 90 // 2. 消费当前字符 91 str = str.slice(1) 92 } else if (char === '<') { 93 // 1. 遇到字符 <，切换到标签开始状态 94 currentState = State.tagOpen 95 // 2. 从 文本状态 --> 标签开始状态，此时应该创建文本 Token，并添加到 tokens 数组 96 // 注意，此时 chars 数组中的字符就是文本内容 97 tokens.push({ 98 type: 'text', 99 content: chars.join('') 100 }) 101 // 3. chars 数组的内容已经被消费，清空它 102 chars.length = 0 103 // 4. 消费当前字符 104 str = str.slice(1) 105 } 106 break 107 // 状态机当前处于标签结束状态 108 case State.tagEnd: 109 if (isAlpha(char)) { 110 // 1. 遇到字母，切换到结束标签名称状态 111 currentState = State.tagEndName 112 // 2. 将当前字符缓存到 chars 数组 113 chars.push(char) 114 // 3. 消费当前字符 115 str = str.slice(1) 116 } 117 break 118 // 状态机当前处于结束标签名称状态 119 case State.tagEndName: 120 if (isAlpha(char)) { 121 // 1. 遇到字母，不需要切换状态，但需要将当前字符缓存到 chars 数组 122 chars.push(char) 123 // 2. 消费当前字符 124 str = str.slice(1) 125 } else if (char === '>') { 126 // 1. 遇到字符 >，切换到初始状态 127 currentState = State.initial 128 // 2. 从 结束标签名称状态 --> 初始状态，应该保存结束标签名称 Token 129 // 注意，此时 chars 数组中缓存的内容就是标签名称 130 tokens.push({ 131 type: 'tagEnd', 132 name: chars.join('') 133 }) 134 // 3. chars 数组的内容已经被消费，清空它 135 chars.length = 0 136 // 4. 消费当前字符 137 str = str.slice(1) 138 } 139 break 140 } 141 } 142 143 // 最后，返回 tokens 144 return tokens 145 } \"]},\"56\":{\"c\":[\"源码\",\"算法\",\"编译器\"]},\"57\":{\"c\":[\"Vue\",\"状态机\",\"AST\"]},\"58\":{\"h\":\"组件实现原理\"},\"59\":{\"h\":\"1.引言\",\"t\":[\"先聊聊什么是组件，组件的用法有两个用途\",\"拆分页面，让页面功能单一，不需要去管理庞大的页面模板。每个组件有自己职责，出事找对应组件即可。\",\"复用，就跟抽离函数一样，页面有很多东西有时候也是可以复用的，所以将一些重复的或者会经常用到的抽离出来。\"]},\"60\":{\"h\":\"2.组件的渲染\",\"t\":[\"对于不同的vnode，patch函数会采用不同的方案会进行渲染。组件也不例外，在vnode的层次上，组件的vnode.type是一个对象，毕竟他也不是任何一个标签。\",\"01 function patch(n1, n2, container, anchor) { 02 if (n1 && n1.type !== n2.type) { 03 unmount(n1) 04 n1 = null 05 } 06 07 const { type } = n2 08 09 if (typeof type === 'string') { 10 // 作为普通元素处理 11 } else if (type === Text) { 12 // 作为文本节点处理 13 } else if (type === Fragment) { 14 // 作为片段处理 15 } else if (typeof type === 'object') { 16 // vnode.type 的值是选项对象，作为组件来处理 17 if (!n1) { 18 // 挂载组件 19 mountComponent(n2, container, anchor) 20 } else { 21 // 更新组件 22 patchComponent(n1, n2, anchor) 23 } 24 } 25 } \",\"对于这个对象里，他应该有一个render函数，用来返回该组件所对应的vnode。格式如下：\",\"01 const MyComponent = { 02 // 组件名称，可选 03 name: 'MyComponent', 04 // 组件的渲染函数，其返回值必须为虚拟 DOM 05 render() { 06 // 返回虚拟 DOM 07 return { 08 type: 'div', 09 children: `我是文本内容` 10 } 11 } 12 } // 挂载函数 01 function mountComponent(vnode, container, anchor) { 02 // 通过 vnode 获取组件的选项对象，即 vnode.type 03 const componentOptions = vnode.type 04 // 获取组件的渲染函数 render 05 const { render } = componentOptions 06 // 执行渲染函数，获取组件要渲染的内容，即 render 函数返回的虚拟 DOM 07 const subTree = render() 08 // 最后调用 patch 函数来挂载组件所描述的内容，即 subTree 09 patch(null, subTree, container, anchor) 10 } \",\"通过render所提供的vnode就可以将该组件渲染出来了。\"]},\"61\":{\"h\":\"3.组件状态与自更新\",\"t\":[\"对于响应式变量来说，如果跟页面双向绑定了。那变量的值改变的时候，页面应该需要重新渲染。而这些导致页面会重新渲染的变量，就叫做组件自身的状态。所以基于组件自身的状态，我们可以设置一个监视器，用来监听是否有改变，如果改变，即重新渲染。\",\"不管是effect还是watch，都是利用副作用，而watch又是对effect的扩展，所以我干脆用监视器来描述。这里也可以说成添加一个对组件自身状态的副作用，功能是重新渲染\",\"01 function mountComponent(vnode, container, anchor) { 02 const componentOptions = vnode.type 03 const { render, data } = componentOptions 04 05 const state = reactive(data()) 06 07 effect(() => { 08 const subTree = render.call(state, state) 09 patch(null, subTree, container, anchor) 10 }, { 11 // 指定该副作用函数的调度器为 queueJob 即可 12 scheduler: queueJob 13 }) 14 } \",\"以上代码有两个缺陷，一，状态反复修改，页面会反复渲染二，每次都是patch(null,subTree)都是重新挂载两个问题都会导致性能上产生不必要的开销。对于问题二，后期改成新旧组件比较即可解决。而问题一，个人见解是做一个防抖，书上是做了一个任务调度器queueJob，利用set收集响应函数，自动去重。\",\"01 // 任务缓存队列，用一个 Set 数据结构来表示，这样就可以自动对任务进行去重 02 const queue = new Set() 03 // 一个标志，代表是否正在刷新任务队列 04 let isFlushing = false 05 // 创建一个立即 resolve 的 Promise 实例 06 const p = Promise.resolve() 07 08 // 调度器的主要函数，用来将一个任务添加到缓冲队列中，并开始刷新队列 09 function queueJob(job) { 10 // 将 job 添加到任务队列 queue 中 11 queue.add(job) 12 // 如果还没有开始刷新队列，则刷新之 13 if (!isFlushing) { 14 // 将该标志设置为 true 以避免重复刷新 15 isFlushing = true 16 // 在微任务中刷新缓冲队列 17 p.then(() => { 18 try { 19 // 执行任务队列中的任务 20 queue.forEach(job => job()) 21 } finally { 22 // 重置状态 23 isFlushing = false 24 queue.clear = 0 25 } 26 }) 27 } 28 } \"]},\"62\":{\"h\":\"4.组件的实例与组件的生命周期\",\"t\":[\"基于上面的方案，对于组件的挂载，组件的销毁，组件的更新其实都表达的很明显了，而且对于上面的问题二，就是利用变量存储旧组件，然后通过判断是否有旧组件来进行决策执行mounted还是update，这样就讲这两个生命周期给分离了。对于create生命周期是在组件状态设置好之前就调用的，所以他的位置也很清晰。\",\"01 function mountComponent(vnode, container, anchor) { 02 const componentOptions = vnode.type 03 // 从组件选项对象中取得组件的生命周期函数 04 const { render, data, beforeCreate, created, beforeMount, mounted, beforeUpdate, updated } = componentOptions 05 06 // 在这里调用 beforeCreate 钩子 07 beforeCreate && beforeCreate() 08 09 const state = reactive(data()) 10 11 const instance = { 12 state, 13 isMounted: false, 14 subTree: null 15 } 16 vnode.component = instance 17 18 // 在这里调用 created 钩子 19 created && created.call(state) 20 21 effect(() => { 22 const subTree = render.call(state, state) 23 if (!instance.isMounted) { 24 // 在这里调用 beforeMount 钩子 25 beforeMount && beforeMount.call(state) 26 patch(null, subTree, container, anchor) 27 instance.isMounted = true 28 // 在这里调用 mounted 钩子 29 mounted && mounted.call(state) 30 } else { 31 // 在这里调用 beforeUpdate 钩子 32 beforeUpdate && beforeUpdate.call(state) 33 patch(instance.subTree, subTree, container, anchor) 34 // 在这里调用 updated 钩子 35 updated && updated.call(state) 36 } 37 instance.subTree = subTree 38 }, { scheduler: queueJob }) 39 } \"]},\"63\":{\"h\":\"5.props与组件的被动更新\",\"t\":[\"先理清组件的props有哪些？\",\"给组件的props：这也就是父子传值的props\",\"组件自身的props：class，style\",\"第一个就是定义组件时的props，也就是通过defineProps内定义的内容，第二个更像是标签的属性。所以vue会通过resolveProps方法将两个props进行合并，并且提炼出attrs。\",\"attrs：指的是传递给一个组件，却没有被该组件声明为 props 或 emits 的 attribute。\",\"有了props就可以来检测是否需要更新子组件了。当父组件的props数据发生变化的时候，会触发父组件的重新渲染，此时渲染函数也会去更新子组件。这种更新叫做被动更新。但是并不是所有的子组件都必须跟着父组件更新的，有时候只是父组件的状态有变化，但是对于子组件来说没有任何变化，此时子组件被动更新的话，这就是没必要的开销。\",\"代码检测props是否改变的通过调用hasPropsChanged方法。\"]},\"64\":{\"c\":[\"源码\"]},\"65\":{\"c\":[\"Vue\",\"AST\"]},\"66\":{\"h\":\"frontmatter 配置\",\"t\":[\"https://theme-hope.vuejs.press/zh/config/frontmatter/info.html#author\"]},\"67\":{\"h\":\"常用项\",\"t\":[\"title: 标题 descritption: 描述 category: 分类 tag: 标签 star: 是否收藏 \"]},\"68\":{\"h\":\"可选项\",\"t\":[\"image: 预览图 order: 侧边栏顺序 \"]},\"69\":{\"c\":[\"配置\"]},\"70\":{\"c\":[\"元信息\"]},\"71\":{\"h\":\"Algorithm\"},\"72\":{\"h\":\"Posts\"},\"73\":{\"h\":\"Vue源码\"},\"74\":{\"h\":\"杂项\"}},\"dirtCount\":0,\"index\":[[\"杂项\",{\"0\":{\"74\":1}}],[\"元信息\",{\"2\":{\"70\":1}}],[\"元素移除\",{\"1\":{\"10\":1}}],[\"元素被添加到页面之前\",{\"1\":{\"10\":1}}],[\"元素\",{\"1\":{\"10\":1,\"21\":1}}],[\"侧边栏顺序\",{\"1\":{\"68\":1}}],[\"预览图\",{\"1\":{\"68\":1}}],[\"预处理\",{\"1\":{\"45\":1}}],[\"描述\",{\"1\":{\"67\":1}}],[\"常用项\",{\"0\":{\"67\":1}}],[\"配置\",{\"0\":{\"66\":1},\"2\":{\"69\":1}}],[\"配合insertbefore使用\",{\"1\":{\"33\":1}}],[\"或\",{\"1\":{\"63\":1}}],[\"或者被\",{\"1\":{\"8\":1}}],[\"却没有被该组件声明为\",{\"1\":{\"63\":1}}],[\"给组件的props\",{\"1\":{\"63\":1}}],[\"钩子\",{\"1\":{\"62\":6}}],[\"基于上面的方案\",{\"1\":{\"62\":1}}],[\"基于上面的条件\",{\"1\":{\"44\":1}}],[\"重置状态\",{\"1\":{\"61\":1}}],[\"重复如第一步的操作一样\",{\"1\":{\"25\":1}}],[\"执行任务队列中的任务\",{\"1\":{\"61\":1}}],[\"执行渲染函数\",{\"1\":{\"60\":1}}],[\"调度器的主要函数\",{\"1\":{\"61\":1}}],[\"调用对应的patch\",{\"1\":{\"28\":1}}],[\"调用patchprops函数添加属性\",{\"1\":{\"28\":1}}],[\"调用\",{\"1\":{\"21\":1,\"33\":1,\"35\":1,\"42\":1}}],[\"实例\",{\"1\":{\"61\":1}}],[\"实现了将子组件的内容渲染到指定的目标位置\",{\"1\":{\"11\":1}}],[\"实现了跨越dom层级完成渲染的功能\",{\"1\":{\"11\":1}}],[\"任务缓存队列\",{\"1\":{\"61\":1}}],[\"书上是做了一个任务调度器queuejob\",{\"1\":{\"61\":1}}],[\"个人见解是做一个防抖\",{\"1\":{\"61\":1}}],[\"每次都是patch\",{\"1\":{\"61\":1}}],[\"每个组件有自己职责\",{\"1\":{\"59\":1}}],[\"状态反复修改\",{\"1\":{\"61\":1}}],[\"状态机\",{\"2\":{\"57\":1}}],[\"状态机当前处于结束标签名称状态\",{\"1\":{\"55\":1}}],[\"状态机当前处于文本状态\",{\"1\":{\"55\":1}}],[\"状态机当前处于标签结束状态\",{\"1\":{\"55\":1}}],[\"状态机当前处于标签名称状态\",{\"1\":{\"55\":1}}],[\"状态机当前处于标签开始状态\",{\"1\":{\"55\":1}}],[\"状态机当前处于初始状态\",{\"1\":{\"55\":1}}],[\"状态机切换到标签开始状态\",{\"1\":{\"55\":1}}],[\"状态机的当前状态\",{\"1\":{\"55\":1}}],[\"功能是重新渲染\",{\"1\":{\"61\":1}}],[\"页面会反复渲染二\",{\"1\":{\"61\":1}}],[\"页面应该需要重新渲染\",{\"1\":{\"61\":1}}],[\"页面有很多东西有时候也是可以复用的\",{\"1\":{\"59\":1}}],[\"`我是文本内容`\",{\"1\":{\"60\":1}}],[\"`<h1>$\",{\"1\":{\"17\":1}}],[\"格式如下\",{\"1\":{\"60\":1}}],[\"毕竟他也不是任何一个标签\",{\"1\":{\"60\":1}}],[\"毕竟渲染器的主要工作就是挂载\",{\"1\":{\"17\":1}}],[\"复用\",{\"1\":{\"59\":1}}],[\"出事找对应组件即可\",{\"1\":{\"59\":1}}],[\"出现多个事件会进行覆盖\",{\"1\":{\"23\":1}}],[\"让页面功能单一\",{\"1\":{\"59\":1}}],[\"拆分页面\",{\"1\":{\"59\":1}}],[\"引言\",{\"0\":{\"59\":1}}],[\"引入key\",{\"1\":{\"31\":1}}],[\"保持状态不变\",{\"1\":{\"55\":1}}],[\"清空它\",{\"1\":{\"55\":3}}],[\"清空内容即可\",{\"1\":{\"25\":1}}],[\"同时消费当前字符\",{\"1\":{\"55\":1}}],[\"同时创建一个标签\",{\"1\":{\"55\":1}}],[\"同理\",{\"1\":{\"8\":1,\"20\":1}}],[\"消费当前字符\",{\"1\":{\"55\":8}}],[\"消费字符\",{\"1\":{\"55\":2}}],[\"切换到标签开始状态\",{\"1\":{\"55\":1}}],[\"切换到标签名称状态\",{\"1\":{\"55\":1}}],[\"切换到初始状态\",{\"1\":{\"55\":2}}],[\"切换到结束标签名称状态\",{\"1\":{\"55\":1}}],[\"切换到结束标签状态\",{\"1\":{\"55\":1}}],[\"切换到结束状态\",{\"1\":{\"10\":1}}],[\"切换到文本状态\",{\"1\":{\"55\":1}}],[\"遇到字母\",{\"1\":{\"55\":6}}],[\"遇到字符\",{\"1\":{\"55\":5}}],[\"注意\",{\"1\":{\"55\":4}}],[\"查看第一个字符\",{\"1\":{\"55\":1}}],[\"使用\",{\"1\":{\"55\":1}}],[\"使初始状态生效\",{\"1\":{\"10\":1}}],[\"数据结构来表示\",{\"1\":{\"61\":1}}],[\"数据库将数据返回给服务器\",{\"1\":{\"51\":1}}],[\"数组的内容已经被消费\",{\"1\":{\"55\":3}}],[\"数组\",{\"1\":{\"55\":7}}],[\"数组中缓存的内容就是标签名称\",{\"1\":{\"55\":1}}],[\"数组中缓存的字符就是标签名称\",{\"1\":{\"55\":1}}],[\"数组中的字符就是文本内容\",{\"1\":{\"55\":1}}],[\"数组中\",{\"1\":{\"55\":2}}],[\"生成的\",{\"1\":{\"55\":1}}],[\"返回虚拟\",{\"1\":{\"60\":1}}],[\"返回\",{\"1\":{\"55\":2}}],[\"接收模板字符串作为参数\",{\"1\":{\"55\":1}}],[\"接着\",{\"1\":{\"44\":1}}],[\"接着找p\",{\"1\":{\"33\":1}}],[\"z\",{\"1\":{\"55\":2}}],[\"zh\",{\"1\":{\"51\":1,\"66\":1}}],[\"zhihu\",{\"1\":{\"8\":1}}],[\"zhuanlan\",{\"1\":{\"8\":1}}],[\"结束标签名称状态\",{\"1\":{\"55\":2}}],[\"结束标签状态\",{\"1\":{\"55\":1}}],[\"定义状态机的状态\",{\"1\":{\"55\":1}}],[\"读取时进行不同状态的转换\",{\"1\":{\"55\":1}}],[\"指的是传递给一个组件\",{\"1\":{\"63\":1}}],[\"指定该副作用函数的调度器为\",{\"1\":{\"61\":1}}],[\"指令名称为\",{\"1\":{\"55\":1}}],[\"指令节点\",{\"1\":{\"55\":1}}],[\"指向下一个位置\",{\"1\":{\"44\":1}}],[\"指向最长递增子序列的最后一个元素\",{\"1\":{\"44\":1}}],[\"指向新的一组子节点的最后一个节点\",{\"1\":{\"42\":1}}],[\"指向旧的一组子节点的最后一个节点\",{\"1\":{\"42\":1}}],[\"标题\",{\"1\":{\"67\":1}}],[\"标签\",{\"1\":{\"67\":1}}],[\"标签名称状态\",{\"1\":{\"55\":1}}],[\"标签开始状态\",{\"1\":{\"55\":2}}],[\"标签节点\",{\"1\":{\"55\":2}}],[\"标记为\",{\"1\":{\"8\":1}}],[\"逻辑根节点\",{\"1\":{\"55\":1}}],[\"逻辑还是挺简单的\",{\"1\":{\"39\":1}}],[\"领域特定语言\",{\"1\":{\"55\":1}}],[\"仅负责分析源代码\",{\"1\":{\"55\":1}}],[\"整个编译过程分为编译前端和编译后端\",{\"1\":{\"55\":1}}],[\"目标代码生成等步骤\",{\"1\":{\"55\":1}}],[\"语句匹配当前状态\",{\"1\":{\"55\":1}}],[\"语义分析\",{\"1\":{\"55\":1}}],[\"语法分析和语义分析\",{\"1\":{\"55\":1}}],[\"语法分析\",{\"1\":{\"55\":1}}],[\"编译器\",{\"2\":{\"56\":1}}],[\"编译器的功能就是将模板语法编译成渲染器能识别的render\",{\"1\":{\"55\":1}}],[\"编译器的流程以及parser的实现\",{\"0\":{\"55\":1}}],[\"编译前\",{\"1\":{\"55\":1}}],[\"编译前端包含词法分析\",{\"1\":{\"55\":1}}],[\"编译后端并不一定会包含中间代码生成和优化这两个环节\",{\"1\":{\"55\":1}}],[\"编译后端涉及中间代码生成和优化以及目标代码生成\",{\"1\":{\"55\":1}}],[\"编译后端则通常与目标平台有关\",{\"1\":{\"55\":1}}],[\"编译一般的步骤由词法分析\",{\"1\":{\"55\":1}}],[\"模板编译器\",{\"0\":{\"54\":1}}],[\"浏览器才会慢慢开始渲染出页面\",{\"1\":{\"51\":1}}],[\"浏览器就会开始解析\",{\"1\":{\"51\":1}}],[\"浏览器会自动解析html代码\",{\"1\":{\"19\":1}}],[\"交给浏览器\",{\"1\":{\"51\":1}}],[\"除开那些必要的标签外\",{\"1\":{\"51\":1}}],[\"除了以上三个\",{\"1\":{\"28\":1}}],[\"客户端渲染\",{\"2\":{\"53\":1}}],[\"客户端进行渲染\",{\"1\":{\"51\":1}}],[\"客户端发送请求给服务器\",{\"1\":{\"51\":1}}],[\"传统的渲染方式\",{\"0\":{\"51\":1}}],[\"传递vnode\",{\"1\":{\"28\":1}}],[\"介绍\",{\"0\":{\"50\":1}}],[\"介绍项目\",{\"1\":{\"5\":1}}],[\"服务器返回给的html只是一个普通的html\",{\"1\":{\"51\":1}}],[\"服务器将html\",{\"1\":{\"51\":1}}],[\"服务器向数据库请求数据\",{\"1\":{\"51\":1}}],[\"服务器的渲染器\",{\"1\":{\"17\":1}}],[\"服务端渲染\",{\"0\":{\"49\":1},\"2\":{\"53\":1}}],[\"减少dom操作\",{\"1\":{\"45\":1}}],[\"减少dom操作的性能开销\",{\"0\":{\"30\":1}}],[\"时\",{\"1\":{\"44\":1}}],[\"+\",{\"1\":{\"44\":2}}],[\"位置的获取和下面一样\",{\"1\":{\"44\":1}}],[\"尾部提升就行\",{\"1\":{\"44\":1}}],[\"表达式节点\",{\"1\":{\"55\":1}}],[\"表明该节点需要移动\",{\"1\":{\"44\":1}}],[\"表示newchildren中预处理后的尾部索引\",{\"1\":{\"44\":1}}],[\"表示最长递增子序列的尾部索引\",{\"1\":{\"44\":1}}],[\"构建一个s和i\",{\"1\":{\"44\":1}}],[\"找出最长递增子序列的区间\",{\"1\":{\"44\":1}}],[\"找到需要新增的和需要卸载的\",{\"1\":{\"43\":1}}],[\"找到需要移动的元素\",{\"0\":{\"32\":1}}],[\"找到所在的位置\",{\"1\":{\"38\":1}}],[\"计算出一个最长递增子序列\",{\"1\":{\"44\":1}}],[\"精髓所在\",{\"1\":{\"44\":1}}],[\"利用set收集响应函数\",{\"1\":{\"61\":1}}],[\"利用简单diff算法的思路找出需要移动的节点\",{\"1\":{\"43\":1}}],[\"利用插槽函数等\",{\"1\":{\"11\":1}}],[\"按照上面算法来跑\",{\"1\":{\"43\":1}}],[\"世间总是不那么尽人意\",{\"1\":{\"43\":1}}],[\"简明的说\",{\"1\":{\"43\":1}}],[\"简单diff算法执行流程\",{\"1\":{\"38\":1}}],[\"简单diff算法\",{\"0\":{\"29\":1}}],[\"简单的这种操作就可以通过封装一个方法去调用api进行创建和挂载\",{\"1\":{\"17\":1}}],[\"递减\",{\"1\":{\"42\":1}}],[\"直到遇见>之前\",{\"1\":{\"55\":1}}],[\"直到遇到拥有不同\",{\"1\":{\"42\":1}}],[\"直接将该节点移动到他应该所在的位置\",{\"1\":{\"44\":1}}],[\"直接挂载文本\",{\"1\":{\"25\":1}}],[\"直接渲染即可\",{\"1\":{\"8\":1}}],[\"循环开启自动机\",{\"1\":{\"55\":1}}],[\"循环从后向前遍历\",{\"1\":{\"42\":1}}],[\"循环结束\",{\"1\":{\"39\":1}}],[\"索引\",{\"1\":{\"42\":2}}],[\"索引为2\",{\"1\":{\"33\":1}}],[\"开始遍历\",{\"1\":{\"44\":1}}],[\"开两个while循环\",{\"1\":{\"42\":1}}],[\"开头的属性\",{\"1\":{\"23\":1}}],[\"you\",{\"1\":{\"42\":2}}],[\"真正需要操作的其实只有这两个\",{\"1\":{\"42\":1}}],[\"前后都一样\",{\"1\":{\"42\":1}}],[\"仔细发现其实只有vue和react不一样\",{\"1\":{\"42\":1}}],[\"updated\",{\"1\":{\"62\":4}}],[\"utf\",{\"1\":{\"51\":1}}],[\"use\",{\"1\":{\"42\":2}}],[\"unmount和beforeunmounted生命周期就出现了\",{\"1\":{\"21\":1}}],[\"unmount\",{\"1\":{\"21\":1,\"22\":3,\"25\":2,\"30\":1,\"35\":2,\"40\":1,\"60\":1}}],[\"留下不同的\",{\"1\":{\"42\":1}}],[\"晒掉相同的\",{\"1\":{\"42\":1}}],[\"何为预处理\",{\"1\":{\"42\":1}}],[\"相同前置和后置元素\",{\"0\":{\"42\":1}}],[\"快速diff算法与前两个diff算法的区别就是它具有一个预处理的过程\",{\"1\":{\"42\":1}}],[\"快速diff算法\",{\"0\":{\"41\":1}}],[\"满足条件就逐个unmount\",{\"1\":{\"40\":1}}],[\"被遗弃了\",{\"1\":{\"39\":1}}],[\"被transition组件包装后的组件会添加一个transition属性\",{\"1\":{\"10\":1}}],[\"你旧的没有\",{\"1\":{\"39\":1}}],[\"你好\",{\"0\":{\"1\":1}}],[\"白话\",{\"1\":{\"39\":1}}],[\"下一轮变量的时候\",{\"1\":{\"38\":1}}],[\"下面是插入\",{\"1\":{\"44\":1}}],[\"下面是该算法每次都要执行的四步\",{\"1\":{\"38\":1}}],[\"下面\",{\"1\":{\"38\":1}}],[\"避免下一次循环再走\",{\"1\":{\"38\":1}}],[\"避免渲染器真的将组件卸载\",{\"1\":{\"8\":1}}],[\"避免渲染器重新挂载它\",{\"1\":{\"8\":1}}],[\"拿newstartvnode在旧的里面找\",{\"1\":{\"38\":1}}],[\"拿旧子节点\",{\"1\":{\"35\":1}}],[\"都是重新挂载两个问题都会导致性能上产生不必要的开销\",{\"1\":{\"61\":1}}],[\"都是利用副作用\",{\"1\":{\"61\":1}}],[\"都走不了的情况\",{\"1\":{\"38\":1}}],[\"都可以用数组来表示\",{\"1\":{\"25\":1}}],[\"至少有一个分支能走\",{\"1\":{\"38\":1}}],[\"至于transition组件\",{\"1\":{\"11\":1}}],[\"优化\",{\"1\":{\"55\":1}}],[\"优化的一个方向\",{\"1\":{\"38\":1}}],[\"优化过性能后存在一个问题\",{\"1\":{\"23\":1}}],[\"假设如果oldvnode是从p1\",{\"1\":{\"38\":1}}],[\"缺点\",{\"1\":{\"38\":1}}],[\"否则不动\",{\"1\":{\"38\":1}}],[\"里找newchildren\",{\"1\":{\"38\":1}}],[\"里面的内容是中间不理想区域的一个索引\",{\"1\":{\"43\":1}}],[\"里面的内容就是一些关于dom过渡的钩子\",{\"1\":{\"10\":1}}],[\"里面存放的是vnode\",{\"1\":{\"17\":1}}],[\"双端\",{\"1\":{\"38\":1}}],[\"双端比较的原理\",{\"0\":{\"38\":1}}],[\"双端diff算法执行流程\",{\"1\":{\"38\":1}}],[\"双端diff算法\",{\"0\":{\"37\":1}}],[\"改进后是遍历新旧子节点数量\",{\"1\":{\"36\":1}}],[\"改进前是全部卸载再挂载\",{\"1\":{\"36\":1}}],[\"去新的一组子节点中寻找具有相同\",{\"1\":{\"35\":1}}],[\"作为组件来处理\",{\"1\":{\"60\":1}}],[\"作为片段处理\",{\"1\":{\"60\":1}}],[\"作为文本节点处理\",{\"1\":{\"60\":1}}],[\"作为普通元素处理\",{\"1\":{\"60\":1}}],[\"作为锚点\",{\"1\":{\"34\":1}}],[\"作用是解决了vue2不支持多根节点模板的问题\",{\"1\":{\"27\":1}}],[\"作用域和作用域链\",{\"1\":{\"5\":1}}],[\"节点\",{\"1\":{\"34\":3}}],[\"仍然为\",{\"1\":{\"34\":1}}],[\"初始值为\",{\"1\":{\"34\":1}}],[\"初始状态\",{\"1\":{\"10\":1,\"55\":3}}],[\"哪个需要新增\",{\"1\":{\"34\":1}}],[\"哪些是哪些\",{\"1\":{\"5\":1}}],[\"插入到锚点元素前面\",{\"1\":{\"33\":1}}],[\"方法将\",{\"1\":{\"33\":1}}],[\"方案一\",{\"1\":{\"30\":1}}],[\"第五步\",{\"1\":{\"38\":1}}],[\"第四步比较newendvnode和oldstartvnode\",{\"1\":{\"38\":1}}],[\"第三步比较newstartvnode和oldendvnode\",{\"1\":{\"38\":1}}],[\"第二个更像是标签的属性\",{\"1\":{\"63\":1}}],[\"第二个参数是位置\",{\"1\":{\"33\":1}}],[\"第二步比较新旧节点的endvnode\",{\"1\":{\"38\":1}}],[\"第一个就是定义组件时的props\",{\"1\":{\"63\":1}}],[\"第一个参数为需要插入的节点\",{\"1\":{\"33\":1}}],[\"第一步都需要patch\",{\"1\":{\"38\":1}}],[\"第一步比较新旧节点的startvnode\",{\"1\":{\"38\":1}}],[\"两段文本\",{\"1\":{\"42\":1}}],[\"两个参数\",{\"1\":{\"33\":1}}],[\"两组子节点的公共长度\",{\"1\":{\"30\":1}}],[\"锚点\",{\"1\":{\"33\":1,\"44\":1}}],[\"看如下的图\",{\"1\":{\"42\":1}}],[\"看这边例子\",{\"1\":{\"42\":1}}],[\"看例子\",{\"1\":{\"39\":1}}],[\"看图\",{\"1\":{\"33\":1}}],[\"看代码\",{\"1\":{\"33\":1}}],[\"看下图\",{\"1\":{\"24\":1}}],[\"跟找p\",{\"1\":{\"33\":1}}],[\"由新子节点的顺序规定\",{\"1\":{\"33\":1}}],[\"由于当前处于标签名称状态\",{\"1\":{\"55\":1}}],[\"由于我们要将\",{\"1\":{\"33\":1}}],[\"由于绑定了一个ref变量\",{\"1\":{\"24\":1}}],[\"由于每个http请求都会建立一个新的连接并且在结束时销毁\",{\"1\":{\"8\":1}}],[\"值是undefined直接跳过就好了\",{\"1\":{\"38\":1}}],[\"值的节点为止\",{\"1\":{\"42\":1}}],[\"值的节点\",{\"1\":{\"35\":2}}],[\"值的两个节点\",{\"1\":{\"31\":1}}],[\"值为0\",{\"1\":{\"33\":1}}],[\"最后调用\",{\"1\":{\"60\":1}}],[\"最后\",{\"1\":{\"55\":1}}],[\"最后通过jsast生成render\",{\"1\":{\"55\":1}}],[\"最大索引记为lastindex\",{\"1\":{\"33\":1}}],[\"最长递增子序列\",{\"1\":{\"44\":1}}],[\"最长公共子序列\",{\"1\":{\"2\":1}}],[\"最长重复子数组\",{\"1\":{\"2\":1}}],[\"起始的索引是0\",{\"1\":{\"33\":1}}],[\"等于白干\",{\"1\":{\"33\":1}}],[\"中\",{\"1\":{\"61\":1}}],[\"中端\",{\"1\":{\"55\":1}}],[\"中间代码生成和优化这两个环节有时也叫\",{\"1\":{\"55\":1}}],[\"中间代码生成\",{\"1\":{\"55\":1}}],[\"中的索引不小于最大索引值\",{\"1\":{\"32\":1}}],[\"中的索引小于最大索引值\",{\"1\":{\"32\":1}}],[\"中去\",{\"1\":{\"11\":1}}],[\"lang=\",{\"1\":{\"51\":1}}],[\"lastindex则将newchildren\",{\"1\":{\"38\":1}}],[\"lastindex\",{\"1\":{\"32\":5,\"33\":3,\"34\":3,\"35\":1}}],[\"link标签后\",{\"1\":{\"51\":1}}],[\"lis\",{\"1\":{\"44\":1}}],[\"like\",{\"1\":{\"42\":2}}],[\"length\",{\"1\":{\"30\":2,\"31\":2,\"32\":2,\"33\":2,\"34\":2,\"35\":2,\"42\":2,\"44\":2,\"55\":3}}],[\"leave\",{\"1\":{\"10\":9}}],[\"let\",{\"1\":{\"8\":2,\"24\":1,\"30\":3,\"31\":2,\"32\":3,\"33\":3,\"34\":5,\"35\":3,\"40\":1,\"42\":5,\"44\":2,\"55\":1,\"61\":1}}],[\"job\",{\"1\":{\"61\":5}}],[\"join\",{\"1\":{\"55\":3}}],[\"juejin\",{\"1\":{\"44\":1}}],[\"j++\",{\"1\":{\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"42\":1}}],[\"j\",{\"1\":{\"31\":3,\"32\":5,\"33\":6,\"34\":6,\"42\":5}}],[\"js\",{\"1\":{\"51\":1}}],[\"js发送给客户端\",{\"1\":{\"51\":1}}],[\"js中的object底层是什么\",{\"1\":{\"23\":1}}],[\"jsweeta\",{\"1\":{\"15\":1}}],[\"唯一标识符\",{\"1\":{\"31\":1}}],[\"次\",{\"1\":{\"30\":1}}],[\"遍历newchildren\",{\"1\":{\"38\":1}}],[\"遍历旧子数组\",{\"1\":{\"35\":1}}],[\"遍历旧的一组子节点\",{\"1\":{\"35\":1}}],[\"遍历旧的\",{\"1\":{\"31\":1}}],[\"遍历新子节点数组\",{\"1\":{\"33\":1}}],[\"遍历新的\",{\"1\":{\"31\":1}}],[\"遍历\",{\"1\":{\"30\":1}}],[\"新旧子数组不能保证他能直接找到\",{\"1\":{\"39\":1}}],[\"新旧vnode\",{\"1\":{\"31\":1}}],[\"新增分支5用来做特殊处理\",{\"1\":{\"39\":1}}],[\"新增的该放哪\",{\"1\":{\"34\":1}}],[\"新增节点考虑的问题如下\",{\"1\":{\"34\":1}}],[\"新的往上走\",{\"1\":{\"38\":1}}],[\"新的往下走\",{\"1\":{\"38\":1}}],[\"新的一组子节点的长度\",{\"1\":{\"30\":1}}],[\"新的多了应该挂载\",{\"1\":{\"30\":1}}],[\"新特性\",{\"1\":{\"5\":1}}],[\"逐个比较新旧vnode\",{\"1\":{\"30\":1}}],[\"单纯可能只是文本值改变了\",{\"1\":{\"30\":1}}],[\"旧的往下走\",{\"1\":{\"38\":1}}],[\"旧的往上走\",{\"1\":{\"38\":1}}],[\"旧的一组子节点的长度\",{\"1\":{\"30\":1}}],[\"旧的多了应该卸载\",{\"1\":{\"30\":1}}],[\"旧的patchchildren在处理新旧vnode都是array时\",{\"1\":{\"30\":1}}],[\"旧子节点是文本子节点\",{\"1\":{\"25\":1}}],[\"旧子节点是一组子节点\",{\"1\":{\"25\":1}}],[\"那变量的值改变的时候\",{\"1\":{\"61\":1}}],[\"那么这说明\",{\"1\":{\"42\":1}}],[\"那么就一直会走分支2\",{\"1\":{\"39\":1}}],[\"那么什么都不需要做\",{\"1\":{\"25\":1}}],[\"那又需要挂载\",{\"1\":{\"33\":1}}],[\"那只能是null\",{\"1\":{\"28\":1}}],[\"会触发父组件的重新渲染\",{\"1\":{\"63\":1}}],[\"会存储到\",{\"1\":{\"55\":1}}],[\"会发现尾部一直相同\",{\"1\":{\"39\":1}}],[\"会判断节点是组件还是节点\",{\"1\":{\"28\":1}}],[\"会关联多个dom\",{\"1\":{\"19\":1}}],[\"取出newvnode的类型\",{\"1\":{\"28\":1}}],[\"进入patch函数后判断新旧vnode的类型是否一样\",{\"1\":{\"28\":1}}],[\"进入render函数后会进行判断vnode是否是null\",{\"1\":{\"28\":1}}],[\"进行收集不同的数据\",{\"1\":{\"55\":1}}],[\"进行了两次操作\",{\"1\":{\"38\":1}}],[\"进行创建dom\",{\"1\":{\"28\":1}}],[\"进行对oldvnode和newvnode比较\",{\"1\":{\"28\":1}}],[\"进行重新渲染\",{\"1\":{\"24\":1}}],[\"进行匹配\",{\"1\":{\"8\":1}}],[\"首先获取当前\",{\"1\":{\"34\":1}}],[\"首先调用render函数\",{\"1\":{\"28\":1}}],[\"首次渲染后\",{\"1\":{\"21\":1}}],[\"章节总结自己翻书\",{\"1\":{\"28\":1}}],[\"名为片段\",{\"1\":{\"27\":1}}],[\"文本状态\",{\"1\":{\"55\":2}}],[\"文本注释和注释节点\",{\"0\":{\"26\":1}}],[\"文本子节点\",{\"1\":{\"25\":1}}],[\"既不是string也不是array\",{\"1\":{\"28\":1}}],[\"既不是\",{\"1\":{\"25\":1}}],[\"判断是否需要移动\",{\"1\":{\"43\":1,\"44\":1}}],[\"判断是否需要进行dom的移动\",{\"0\":{\"43\":1}}],[\"判断新增是通过判断oldend是否小于oldstart并且满足newstart要小于等于newend\",{\"1\":{\"40\":1}}],[\"判断newchildren是否有遗留\",{\"1\":{\"39\":1}}],[\"判断newvnode\",{\"1\":{\"28\":2}}],[\"判断该vnode是否已经移动过了\",{\"1\":{\"39\":1}}],[\"判断他们是否可复用\",{\"1\":{\"38\":1}}],[\"判断oldvnode\",{\"1\":{\"28\":2}}],[\"判断oldvnode是否是空\",{\"1\":{\"28\":1}}],[\"判断\",{\"1\":{\"25\":2}}],[\"判断绑定事件的时间是否小于触发事件即可\",{\"1\":{\"24\":1}}],[\"分类\",{\"1\":{\"67\":1}}],[\"分析了在理想状态和非理想状态的情况\",{\"1\":{\"39\":1}}],[\"分析如下\",{\"1\":{\"25\":1}}],[\"分别是\",{\"1\":{\"8\":1}}],[\"说明状态是开启了一个新标签\",{\"1\":{\"55\":1}}],[\"说明该位置的节点不需要移动\",{\"1\":{\"44\":1}}],[\"说明该节点对应的真实\",{\"1\":{\"32\":1}}],[\"说明该节点需要移动\",{\"1\":{\"32\":1,\"44\":1}}],[\"说明i\",{\"1\":{\"44\":1}}],[\"说明这之间的又得全部卸载和全部挂在\",{\"1\":{\"43\":1}}],[\"说明即将挂载的新节点是第一个子节点\",{\"1\":{\"34\":1}}],[\"说明当前\",{\"1\":{\"34\":1}}],[\"说明是新增\",{\"1\":{\"34\":1}}],[\"说明\",{\"1\":{\"33\":1}}],[\"说明需要移动\",{\"1\":{\"33\":1}}],[\"说明不需要移动\",{\"1\":{\"32\":1}}],[\"说明可以复用\",{\"1\":{\"31\":1}}],[\"说明有旧子节点需要卸载\",{\"1\":{\"30\":1}}],[\"说明有新子节点需要挂载\",{\"1\":{\"30\":1}}],[\"说明新子节点不存在\",{\"1\":{\"25\":1}}],[\"说还可以\",{\"1\":{\"6\":1}}],[\"安装新的\",{\"1\":{\"25\":1}}],[\"可选项\",{\"0\":{\"68\":1}}],[\"可选\",{\"1\":{\"60\":1}}],[\"可能是文本和元素的混合\",{\"1\":{\"25\":1}}],[\"可以把有限的状态列出来\",{\"1\":{\"55\":1}}],[\"可以看到\",{\"1\":{\"55\":1}}],[\"可以在视觉上被认为是在teleport组件外渲染的\",{\"1\":{\"11\":1}}],[\"可以明确的知道对于该组件是否是第一次挂载以及后期的激活和失活\",{\"1\":{\"8\":1}}],[\"无论是单个元素子节点\",{\"1\":{\"25\":1}}],[\"无法被\",{\"1\":{\"8\":1}}],[\"代表是否正在刷新任务队列\",{\"1\":{\"61\":1}}],[\"代表是否在旧的一组子节点中找到可复用的节点\",{\"1\":{\"34\":1}}],[\"代表指令\",{\"1\":{\"55\":1}}],[\"代表没找到\",{\"1\":{\"34\":1}}],[\"代表文本的内容\",{\"1\":{\"25\":1}}],[\"代码检测props是否改变的通过调用haspropschanged方法\",{\"1\":{\"63\":1}}],[\"代码也简单\",{\"1\":{\"42\":1}}],[\"代码如上\",{\"1\":{\"25\":1}}],[\"代码运行到这里\",{\"1\":{\"22\":1,\"25\":1,\"33\":1}}],[\"具有文本子节点\",{\"1\":{\"25\":1}}],[\"具体来说\",{\"1\":{\"11\":1}}],[\"具体体现的是在组件的进入和组件的退出\",{\"1\":{\"10\":1}}],[\"子节点使用数组表示\",{\"1\":{\"25\":1}}],[\"子元素的状态\",{\"1\":{\"25\":1}}],[\"子序列问题\",{\"0\":{\"2\":1},\"2\":{\"4\":1}}],[\"99\",{\"1\":{\"55\":1}}],[\"98\",{\"1\":{\"55\":1}}],[\"97\",{\"1\":{\"55\":1}}],[\"96\",{\"1\":{\"55\":1}}],[\"95\",{\"1\":{\"55\":1}}],[\"94\",{\"1\":{\"55\":1}}],[\"93\",{\"1\":{\"55\":1}}],[\"92\",{\"1\":{\"55\":1}}],[\"91\",{\"1\":{\"55\":1}}],[\"90\",{\"1\":{\"55\":1}}],[\"9\",{\"0\":{\"25\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1},\"1\":{\"43\":1}}],[\"严格来讲\",{\"1\":{\"24\":1}}],[\"因此\",{\"1\":{\"24\":1}}],[\"因为快所以叫快速\",{\"1\":{\"45\":1}}],[\"因为在新子节点数组里是规定好了顺序\",{\"1\":{\"34\":1}}],[\"因为是第一次挂载\",{\"1\":{\"28\":1}}],[\"因为非组件的虚拟节点无法被\",{\"1\":{\"8\":1}}],[\"因为其他的一下子忘记了\",{\"1\":{\"5\":1}}],[\"因为我自己开发舒服\",{\"1\":{\"5\":1}}],[\"即可\",{\"1\":{\"61\":1}}],[\"即重新渲染\",{\"1\":{\"61\":1}}],[\"即客户端渲染和服务器渲染\",{\"1\":{\"50\":1}}],[\"即锚点元素\",{\"1\":{\"34\":2}}],[\"即两者中较短的那一组子节点的长度\",{\"1\":{\"30\":1}}],[\"即\",{\"1\":{\"24\":1,\"33\":1,\"60\":3}}],[\"来自书中的补充\",{\"1\":{\"24\":1}}],[\"来自书里所讲\",{\"1\":{\"19\":1}}],[\"存储事件处理函数被绑定的时间\",{\"1\":{\"24\":1}}],[\"存在\",{\"1\":{\"22\":1}}],[\"存在一个html\",{\"1\":{\"19\":1}}],[\"冒泡往前走\",{\"1\":{\"24\":1}}],[\"提前改变了使得div的点击事件进行了分支切换\",{\"1\":{\"24\":1}}],[\"于是diff算法就是来解决这个问题的\",{\"1\":{\"30\":1}}],[\"于是执行了副作用函数\",{\"1\":{\"24\":1}}],[\"于是就是接着在patchprops函数上打补丁\",{\"1\":{\"20\":1}}],[\"也并不是总能找到\",{\"1\":{\"39\":1}}],[\"也出现在newvnode\",{\"1\":{\"31\":1}}],[\"也不是数组\",{\"1\":{\"25\":1}}],[\"也不需要进行触发点击事件\",{\"1\":{\"24\":1}}],[\"也可能是非高精时间\",{\"1\":{\"24\":1}}],[\"也就是通过defineprops内定义的内容\",{\"1\":{\"63\":1}}],[\"也就是针对某一种特定环境而产生的语言\",{\"1\":{\"55\":1}}],[\"也就是序列保持递增时说明不需要移动\",{\"1\":{\"43\":1}}],[\"也就是对于新节点在旧节点上的索引值\",{\"1\":{\"43\":1}}],[\"也就是对于头和尾能不能找到对应的并且移动的情况\",{\"1\":{\"39\":1}}],[\"也就是newstartindex\",{\"1\":{\"39\":1}}],[\"也就是\",{\"1\":{\"33\":1}}],[\"也就是移动到newvnode\",{\"1\":{\"33\":1}}],[\"也就是diff\",{\"1\":{\"17\":1}}],[\"也就是mounted和unmounted这两个钩子\",{\"1\":{\"10\":1}}],[\"也就是说\",{\"1\":{\"9\":1,\"34\":1}}],[\"queue\",{\"1\":{\"61\":5}}],[\"queuejob\",{\"1\":{\"61\":3,\"62\":1}}],[\"queryselector\",{\"1\":{\"24\":1}}],[\"qwq\",{\"1\":{\"5\":1}}],[\"父元素div的分支应该是处于\",{\"1\":{\"24\":1}}],[\"父元素\",{\"1\":{\"24\":1}}],[\"父组件包了子组件\",{\"1\":{\"9\":1}}],[\"后续通过它\",{\"1\":{\"44\":1}}],[\"后面\",{\"1\":{\"33\":1}}],[\"后面还有需求是一个事件可以绑定多个函数\",{\"1\":{\"23\":1}}],[\"后期改成新旧组件比较即可解决\",{\"1\":{\"61\":1}}],[\"后期渲染的vnode如果传的是null说明要执行卸载操作\",{\"1\":{\"21\":1}}],[\"后期更新的时候也只需要patchchildren即可\",{\"1\":{\"9\":1}}],[\"确实嗷\",{\"1\":{\"23\":1}}],[\"之前看过一个问题\",{\"1\":{\"23\":1}}],[\"解决了dom的开销\",{\"1\":{\"30\":1}}],[\"解决了组件的反复挂载和卸载造成的额外开销\",{\"1\":{\"11\":1}}],[\"解决方案\",{\"1\":{\"24\":1}}],[\"解决\",{\"1\":{\"23\":1}}],[\"缓存只缓存了一个\",{\"1\":{\"23\":1}}],[\"并开始刷新队列\",{\"1\":{\"61\":1}}],[\"并添加到\",{\"1\":{\"55\":2}}],[\"并作为函数的返回值返回\",{\"1\":{\"55\":1}}],[\"并将模板切割为\",{\"1\":{\"55\":1}}],[\"并将其作为锚点\",{\"1\":{\"33\":1}}],[\"并让\",{\"1\":{\"44\":1}}],[\"并不一定意味着可以直接复用\",{\"1\":{\"31\":1}}],[\"并不需要卸载和挂载操作\",{\"1\":{\"30\":1}}],[\"并且提炼出attrs\",{\"1\":{\"63\":1}}],[\"并且还能精确到当前组件\",{\"1\":{\"45\":1}}],[\"并且对该部分进行crud操作\",{\"1\":{\"42\":1}}],[\"并且将这个oldtovnode移动到oldstartvnode的上面\",{\"1\":{\"38\":1}}],[\"并且将函数缓存在invoker\",{\"1\":{\"23\":1}}],[\"并且记录为oldtovnode\",{\"1\":{\"38\":1}}],[\"并且更新对应的index\",{\"1\":{\"38\":1}}],[\"并且更新lastindex\",{\"1\":{\"38\":1}}],[\"并且更新lastindex为2\",{\"1\":{\"33\":1}}],[\"并且把oldstartvnode插入到oldendvnode的下面\",{\"1\":{\"38\":1}}],[\"并且把oldendvnode插入到oldstartvnode的上面\",{\"1\":{\"38\":1}}],[\"并且维护一个lastindex记录最大索引\",{\"1\":{\"38\":1}}],[\"并且最大程度上来复用dom元素\",{\"1\":{\"36\":1}}],[\"并且也跟对应的真实dom有联系\",{\"1\":{\"34\":1}}],[\"并且挂在文本\",{\"1\":{\"25\":1}}],[\"并且绑定到了div上\",{\"1\":{\"24\":1}}],[\"并标记为\",{\"1\":{\"8\":1}}],[\"性能优化\",{\"1\":{\"23\":1}}],[\"绑定事件\",{\"1\":{\"23\":1}}],[\"例如\",{\"1\":{\"23\":1}}],[\"^on\",{\"1\":{\"23\":1,\"24\":1}}],[\"视其为事件\",{\"1\":{\"23\":1}}],[\"79\",{\"1\":{\"55\":1}}],[\"78\",{\"1\":{\"55\":1}}],[\"77\",{\"1\":{\"55\":1}}],[\"76\",{\"1\":{\"55\":1}}],[\"75\",{\"1\":{\"55\":1}}],[\"74\",{\"1\":{\"55\":1}}],[\"73\",{\"1\":{\"55\":1}}],[\"72\",{\"1\":{\"55\":1}}],[\"71\",{\"1\":{\"55\":1}}],[\"7134499769803603999\",{\"1\":{\"44\":1}}],[\"70\",{\"1\":{\"55\":1}}],[\"7\",{\"0\":{\"23\":1,\"36\":1},\"1\":{\"43\":2}}],[\"处理其他类型的\",{\"1\":{\"22\":1}}],[\"处理该属性有一个normalizeclass函数\",{\"1\":{\"20\":1}}],[\"xxx\",{\"1\":{\"22\":1}}],[\"所对应真实\",{\"1\":{\"33\":2}}],[\"所描述的内容相同\",{\"1\":{\"22\":1}}],[\"所以vue会通过resolveprops方法将两个props进行合并\",{\"1\":{\"63\":1}}],[\"所以他的位置也很清晰\",{\"1\":{\"62\":1}}],[\"所以我干脆用监视器来描述\",{\"1\":{\"61\":1}}],[\"所以我们需要获取\",{\"1\":{\"33\":1}}],[\"所以基于组件自身的状态\",{\"1\":{\"61\":1}}],[\"所以将一些重复的或者会经常用到的抽离出来\",{\"1\":{\"59\":1}}],[\"所以不需要切换状态\",{\"1\":{\"55\":1}}],[\"所以通过这种思想\",{\"1\":{\"55\":1}}],[\"所以就会出现白屏的现象\",{\"1\":{\"51\":1}}],[\"所以这些节点就是喜欢来给你出问题\",{\"1\":{\"43\":1}}],[\"所以这种调用api的东西\",{\"1\":{\"17\":1}}],[\"所以\",{\"1\":{\"39\":1,\"43\":1}}],[\"所以新增\",{\"1\":{\"39\":1}}],[\"所以把它置为undefined\",{\"1\":{\"38\":1}}],[\"所以直接挂载就可以了\",{\"1\":{\"34\":1}}],[\"所以p\",{\"1\":{\"33\":1}}],[\"所以可以利用它来进行dom的移动\",{\"1\":{\"33\":1}}],[\"所以下一个优化方向是\",{\"1\":{\"31\":1}}],[\"所以需要考虑新旧vnode\",{\"1\":{\"30\":1}}],[\"所以需要做一些判断\",{\"1\":{\"25\":1}}],[\"所以需要自己去把这个活接过来\",{\"1\":{\"19\":1}}],[\"所以行不通\",{\"1\":{\"24\":1}}],[\"所以会触发div的点击事件\",{\"1\":{\"24\":1}}],[\"所以还需要进一步的判断\",{\"1\":{\"22\":1}}],[\"所以封装成unmount函数\",{\"1\":{\"21\":1}}],[\"所以考虑到以上三点\",{\"1\":{\"21\":1}}],[\"所以用的是el\",{\"1\":{\"20\":1}}],[\"所以要正确的设置元素属性\",{\"1\":{\"19\":1}}],[\"所以要多加个特判来决定是否需要移动\",{\"1\":{\"9\":1}}],[\"所以引入了一些策略上的属性\",{\"1\":{\"11\":1}}],[\"所以当多个请求进行发送时就会导致额外的性能开销\",{\"1\":{\"8\":1}}],[\"所以想问一下怎么样\",{\"1\":{\"6\":1}}],[\"证明\",{\"1\":{\"22\":1}}],[\"更新组件\",{\"1\":{\"60\":1}}],[\"更新相同的后置节点\",{\"1\":{\"42\":1}}],[\"更新相同的前置节点\",{\"1\":{\"42\":1}}],[\"更新children通过调用patchchildren\",{\"1\":{\"28\":1}}],[\"更新props通过调用patchprops方法\",{\"1\":{\"28\":1}}],[\"更新子节点\",{\"0\":{\"25\":1}}],[\"更新的时候覆盖invoker\",{\"1\":{\"23\":1}}],[\"更新跟更新vnode一样\",{\"1\":{\"23\":1}}],[\"更新\",{\"1\":{\"22\":1}}],[\"更新和渲染\",{\"1\":{\"17\":1}}],[\"再将模板ast转换成jsast\",{\"1\":{\"55\":1}}],[\"再挂载数组\",{\"1\":{\"25\":1}}],[\"再挂载newvnode\",{\"1\":{\"22\":1,\"30\":1}}],[\"再渲染成真实dom\",{\"1\":{\"22\":1}}],[\"又会进行判断\",{\"1\":{\"22\":1}}],[\"又称http\",{\"1\":{\"8\":1}}],[\"走到这里一定是进行patch了的\",{\"1\":{\"22\":1}}],[\"此时子组件被动更新的话\",{\"1\":{\"63\":1}}],[\"此时渲染函数也会去更新子组件\",{\"1\":{\"63\":1}}],[\"此时应该创建文本\",{\"1\":{\"55\":1}}],[\"此时2比起始索引大\",{\"1\":{\"33\":1}}],[\"此时\",{\"1\":{\"25\":2,\"38\":1,\"51\":1,\"55\":3}}],[\"此时点击p会触发他的点击事件\",{\"1\":{\"24\":1}}],[\"此时所作的操作应该时先卸载oldvnode\",{\"1\":{\"22\":1}}],[\"此时的render函数会进行判断\",{\"1\":{\"22\":1}}],[\"此时还有一个好处就是\",{\"1\":{\"21\":1}}],[\"先理清组件的props有哪些\",{\"1\":{\"63\":1}}],[\"先聊聊什么是组件\",{\"1\":{\"59\":1}}],[\"先获取\",{\"1\":{\"33\":1}}],[\"先卸载\",{\"1\":{\"23\":1}}],[\"先梳理一下执行流程\",{\"1\":{\"22\":1}}],[\"先贴链接\",{\"1\":{\"2\":1}}],[\"区分vnode的类型\",{\"0\":{\"22\":1}}],[\"69\",{\"1\":{\"55\":1}}],[\"68\",{\"1\":{\"55\":1}}],[\"67\",{\"1\":{\"55\":1}}],[\"66\",{\"1\":{\"55\":1}}],[\"65\",{\"1\":{\"55\":1}}],[\"64\",{\"1\":{\"55\":1}}],[\"63\",{\"1\":{\"55\":1}}],[\"62\",{\"1\":{\"55\":1}}],[\"61\",{\"1\":{\"55\":1}}],[\"60\",{\"1\":{\"55\":1}}],[\"6\",{\"0\":{\"22\":1,\"35\":1},\"1\":{\"28\":1,\"43\":1,\"55\":1}}],[\"根据上面的算法来模拟一遍\",{\"1\":{\"33\":1}}],[\"根据属性自身特性进行对应挂载\",{\"1\":{\"28\":1}}],[\"根据属性名称得到对应的事件名称\",{\"1\":{\"23\":1}}],[\"根据\",{\"1\":{\"21\":1}}],[\"应该保存结束标签名称\",{\"1\":{\"55\":1}}],[\"应该再开一个分支进行去处理它\",{\"1\":{\"43\":1}}],[\"应该接着patch指令\",{\"1\":{\"28\":1}}],[\"应该是通过vnode获取到真实dom\",{\"1\":{\"21\":1}}],[\"应该执行unmount操作\",{\"1\":{\"17\":1}}],[\"他应该有一个render函数\",{\"1\":{\"60\":1}}],[\"他并没有做任何操作\",{\"1\":{\"39\":1}}],[\"他们终究都需要去做两件事情\",{\"1\":{\"43\":1}}],[\"他们开始跑代码\",{\"1\":{\"39\":1}}],[\"他们的children可能会不一样\",{\"1\":{\"31\":1}}],[\"他就会走第五步\",{\"1\":{\"38\":1}}],[\"他就是进行对dom的进场和离场做一个分析\",{\"1\":{\"11\":1}}],[\"他能跑起来的前提是\",{\"1\":{\"38\":1}}],[\"他是不是会进行操作n\",{\"1\":{\"38\":1}}],[\"他是将p\",{\"1\":{\"38\":1}}],[\"他修改了ref变量\",{\"1\":{\"24\":1}}],[\"他说hashmap\",{\"1\":{\"23\":1}}],[\"他独立出去了\",{\"1\":{\"21\":1}}],[\"他不会移除那些绑定在dom元素上的钩子\",{\"1\":{\"21\":1}}],[\"有时候只是父组件的状态有变化\",{\"1\":{\"63\":1}}],[\"有时候有一些节点\",{\"1\":{\"30\":1}}],[\"有了props就可以来检测是否需要更新子组件了\",{\"1\":{\"63\":1}}],[\"有些还是比较类似的\",{\"1\":{\"43\":1}}],[\"有些时候\",{\"1\":{\"31\":1}}],[\"有些元素存在自定义指令\",{\"1\":{\"21\":1}}],[\"有没有兼容性问题\",{\"1\":{\"5\":1}}],[\"卸载oldvnode\",{\"1\":{\"28\":1}}],[\"卸载文本\",{\"1\":{\"25\":1}}],[\"卸载原有的\",{\"1\":{\"25\":1}}],[\"卸载\",{\"1\":{\"22\":1}}],[\"卸载时应该要正确执行对应的指令钩子\",{\"1\":{\"21\":1}}],[\"卸载时应该调用这些组件的unmounted\",{\"1\":{\"21\":1}}],[\"卸载操作\",{\"0\":{\"21\":1},\"1\":{\"21\":1}}],[\"卸载的时候把他放进去\",{\"1\":{\"8\":1}}],[\"全部转换为字符串的格式设置该属性有el\",{\"1\":{\"20\":1}}],[\"finally\",{\"1\":{\"61\":1}}],[\"find\",{\"1\":{\"34\":6,\"35\":1}}],[\"firstchild\",{\"1\":{\"34\":2}}],[\"firefox\",{\"1\":{\"24\":1}}],[\"frontmatter\",{\"0\":{\"66\":1},\"1\":{\"66\":1}}],[\"from\",{\"1\":{\"10\":7}}],[\"fragment\",{\"0\":{\"27\":1},\"1\":{\"28\":1,\"34\":1,\"60\":1}}],[\"fn\",{\"1\":{\"24\":2}}],[\"for\",{\"1\":{\"30\":3,\"31\":2,\"32\":2,\"33\":2,\"34\":2,\"35\":2,\"40\":1,\"42\":2,\"44\":1}}],[\"foreach\",{\"1\":{\"24\":1,\"25\":3,\"61\":1}}],[\"foo\",{\"1\":{\"20\":3}}],[\"false\",{\"1\":{\"24\":1,\"34\":3,\"61\":2,\"62\":1}}],[\"function\",{\"1\":{\"21\":2,\"22\":2,\"25\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":3,\"35\":1,\"42\":1,\"55\":2,\"60\":2,\"61\":2,\"62\":1}}],[\"自动去重\",{\"1\":{\"61\":1}}],[\"自动机就会一直运行\",{\"1\":{\"55\":1}}],[\"自动分析并且设置dom\",{\"1\":{\"19\":1}}],[\"自我介绍\",{\"1\":{\"5\":1}}],[\"需要增加的增加\",{\"1\":{\"36\":1}}],[\"需要卸载的卸载\",{\"1\":{\"36\":1}}],[\"需要更新的更新\",{\"1\":{\"36\":1}}],[\"需要挂载\",{\"1\":{\"34\":1}}],[\"需要锚点元素\",{\"1\":{\"33\":1}}],[\"需要移动\",{\"1\":{\"32\":1,\"33\":1}}],[\"需要做特殊处理\",{\"1\":{\"28\":1}}],[\"需要看情况来进行判断赋值\",{\"1\":{\"19\":1}}],[\"需要考虑三个点\",{\"1\":{\"10\":1}}],[\"设置与之对应的dom\",{\"1\":{\"19\":1}}],[\"设置初始状态\",{\"1\":{\"10\":1}}],[\"只要模板字符串没有被消费尽\",{\"1\":{\"55\":1}}],[\"只有一个<div\",{\"1\":{\"51\":1}}],[\"只有削去了前面第一个和后面第一个\",{\"1\":{\"43\":1}}],[\"只是需要特判一下是否是最下面\",{\"1\":{\"44\":1}}],[\"只是索引变量名字稍微有点变化\",{\"1\":{\"42\":1}}],[\"只需找到不同即可\",{\"1\":{\"42\":1}}],[\"只需要处理后面即可\",{\"1\":{\"42\":1}}],[\"只需要将pn移动到最下面\",{\"1\":{\"38\":1}}],[\"只需要更新文本值即可\",{\"1\":{\"30\":1}}],[\"只需要把后面挂载文本改成挂在\",{\"1\":{\"25\":1}}],[\"只需要记住一个原则\",{\"1\":{\"19\":1}}],[\"只需逐个卸载即可\",{\"1\":{\"25\":1}}],[\"只说了\",{\"1\":{\"5\":1}}],[\"问题二其实也简单\",{\"1\":{\"34\":1}}],[\"问题一在前面设置key的时候就已经解决了\",{\"1\":{\"34\":1}}],[\"问题代码示例\",{\"1\":{\"24\":1}}],[\"问题\",{\"1\":{\"19\":1}}],[\"问我怎么学的\",{\"1\":{\"6\":1}}],[\"它是通过逐步遍历模板字符串\",{\"1\":{\"55\":1}}],[\"它通常与目标平台无关\",{\"1\":{\"55\":1}}],[\"它不需要移动\",{\"1\":{\"33\":1}}],[\"它既可能是高精时间\",{\"1\":{\"24\":1}}],[\"它会去判断vnode\",{\"1\":{\"19\":1}}],[\"它的实例上存在特殊的\",{\"1\":{\"8\":1}}],[\"89\",{\"1\":{\"55\":1}}],[\"88\",{\"1\":{\"55\":1}}],[\"87\",{\"1\":{\"55\":1}}],[\"86\",{\"1\":{\"55\":1}}],[\"85\",{\"1\":{\"55\":1}}],[\"84\",{\"1\":{\"55\":1}}],[\"83\",{\"1\":{\"55\":1}}],[\"82\",{\"1\":{\"55\":1}}],[\"81\",{\"1\":{\"55\":1}}],[\"80\",{\"1\":{\"55\":1}}],[\"8\",{\"0\":{\"19\":2,\"20\":1,\"21\":1,\"22\":1,\"23\":1,\"24\":2,\"25\":1,\"26\":1,\"27\":1,\"28\":1},\"1\":{\"43\":2,\"51\":1}}],[\"挂载函数\",{\"1\":{\"60\":1}}],[\"挂载组件\",{\"1\":{\"60\":1}}],[\"挂载时将锚点元素作为第三个参数传递给\",{\"1\":{\"34\":1}}],[\"挂载\",{\"1\":{\"34\":1}}],[\"挂载与更新\",{\"0\":{\"18\":1}}],[\"挂在子节点和元素属性和正确的设置元素属性\",{\"0\":{\"19\":1}}],[\"挂在的东西都是外部传进这个createrenderer函数里的\",{\"1\":{\"17\":1}}],[\"转换后应该是<h1>我是一个vnodeobj<\",{\"1\":{\"17\":1}}],[\"忘记了\",{\"1\":{\"17\":1}}],[\"属于第一次\",{\"1\":{\"17\":1}}],[\"属性\",{\"1\":{\"8\":2,\"24\":1}}],[\"容器可能是由多个组件渲染\",{\"1\":{\"21\":1}}],[\"容器\",{\"1\":{\"17\":1}}],[\"虚拟节点\",{\"1\":{\"17\":1}}],[\"渲染\",{\"1\":{\"24\":1}}],[\"渲染函数\",{\"1\":{\"17\":1}}],[\"渲染器的作用就是将vnode渲染成真实dom\",{\"1\":{\"17\":1}}],[\"渲染器的设计\",{\"0\":{\"17\":1}}],[\"渲染器\",{\"1\":{\"17\":1}}],[\"渲染器和响应式结合\",{\"1\":{\"16\":1}}],[\"渲染器设计\",{\"0\":{\"16\":1}}],[\"渲染组件\",{\"1\":{\"8\":1}}],[\"详细请看仓库源码注释\",{\"1\":{\"15\":1}}],[\"响应式设计\",{\"0\":{\"15\":1}}],[\"响应式设计和渲染器设计\",{\"0\":{\"14\":1}}],[\"网络\",{\"2\":{\"12\":1}}],[\"源码里面其实还做了其他的操作\",{\"1\":{\"28\":1}}],[\"源码\",{\"2\":{\"12\":1,\"47\":1,\"52\":1,\"56\":1,\"64\":1}}],[\"降低了打包体积\",{\"1\":{\"11\":1}}],[\"从组件选项对象中取得组件的生命周期函数\",{\"1\":{\"62\":1}}],[\"从\",{\"1\":{\"55\":2}}],[\"从而达到过渡效果\",{\"1\":{\"11\":1}}],[\"从而减少了渲染器的工作量和代码膨胀\",{\"1\":{\"11\":1}}],[\"从哪来\",{\"1\":{\"10\":1}}],[\"操作\",{\"1\":{\"11\":1}}],[\"主要是因为它可以将子组件的内容直接移动到指定位置\",{\"1\":{\"11\":1}}],[\"以避免重复刷新\",{\"1\":{\"61\":1}}],[\"以上代码有两个缺陷\",{\"1\":{\"61\":1}}],[\"以简单diff算法来说\",{\"1\":{\"38\":1}}],[\"以及新增特殊判断\",{\"1\":{\"39\":1}}],[\"以及之后的版本中\",{\"1\":{\"24\":1}}],[\"以及使打包体积更小的原因\",{\"1\":{\"11\":1}}],[\"以下是调用该函数的返回值\",{\"1\":{\"17\":1}}],[\"以便在渲染器中访问\",{\"1\":{\"8\":1}}],[\"是否收藏\",{\"1\":{\"67\":1}}],[\"是否是数组\",{\"1\":{\"25\":3}}],[\"是否是\",{\"1\":{\"25\":1}}],[\"是在理想状态下的\",{\"1\":{\"43\":1}}],[\"是diff算法里一个非常重要的角色\",{\"1\":{\"36\":1}}],[\"是新增节点\",{\"1\":{\"34\":1}}],[\"是第一个节点\",{\"1\":{\"33\":1}}],[\"是先全部卸载oldvnode\",{\"1\":{\"30\":1}}],[\"是string则进行挂载文本\",{\"1\":{\"28\":1}}],[\"是空的话则调用mountelement方法\",{\"1\":{\"28\":1}}],[\"是null则进行unmount的操作\",{\"1\":{\"28\":1}}],[\"是事件发生的时间\",{\"1\":{\"24\":1}}],[\"是通过createrenderer内所传的options带来的\",{\"1\":{\"23\":1}}],[\"是组件就可以调用前面所说的生命周期函数\",{\"1\":{\"21\":1}}],[\"是\",{\"1\":{\"19\":1}}],[\"是的话就直接挂在文本内容\",{\"1\":{\"19\":1}}],[\"是基于tcp\",{\"1\":{\"11\":1}}],[\"是什么时候该封装\",{\"1\":{\"5\":1}}],[\"本质上来讲就是想尽可能地减少dom操作\",{\"1\":{\"43\":1}}],[\"本质上来讲就是\",{\"1\":{\"42\":1}}],[\"本质上的实现是将组件缓存下来\",{\"1\":{\"11\":1}}],[\"本身它的意思也很明确\",{\"1\":{\"9\":1}}],[\"总之\",{\"1\":{\"17\":1}}],[\"总结\",{\"0\":{\"11\":1,\"28\":1,\"36\":1,\"45\":1}}],[\"总体设计不难\",{\"1\":{\"8\":1}}],[\"四\",{\"0\":{\"11\":1}}],[\"比lastindex要小\",{\"1\":{\"33\":1}}],[\"比如当读取到<时\",{\"1\":{\"55\":1}}],[\"比如以下的节点\",{\"1\":{\"43\":1}}],[\"比如\",{\"1\":{\"10\":1}}],[\"比之前面试人要好\",{\"1\":{\"6\":1}}],[\"记得调用\",{\"1\":{\"10\":1}}],[\"事件冒泡与更新时机问题\",{\"0\":{\"24\":1}}],[\"事件这个也算vnode\",{\"1\":{\"23\":1}}],[\"事件的处理\",{\"0\":{\"23\":1}}],[\"事件做收尾工作\",{\"1\":{\"10\":1}}],[\"事件循环\",{\"1\":{\"5\":1}}],[\"监听\",{\"1\":{\"10\":1}}],[\"order\",{\"1\":{\"68\":1}}],[\"ok\",{\"1\":{\"55\":2}}],[\"oldend\",{\"1\":{\"42\":6}}],[\"oldendidx\",{\"1\":{\"40\":4}}],[\"oldendindex\",{\"1\":{\"39\":1}}],[\"oldstartidx\",{\"1\":{\"40\":4}}],[\"oldstartindex\",{\"1\":{\"39\":1}}],[\"oldstartindex还是1\",{\"1\":{\"39\":1}}],[\"oldlen\",{\"1\":{\"30\":7}}],[\"oldchildren\",{\"1\":{\"30\":4,\"31\":3,\"32\":3,\"33\":3,\"34\":3,\"35\":3,\"39\":1,\"40\":1,\"42\":6,\"43\":1}}],[\"oldvnode\",{\"1\":{\"17\":4,\"22\":4,\"25\":2,\"31\":3,\"32\":3,\"33\":3,\"34\":3,\"35\":4,\"42\":8}}],[\"opera\",{\"1\":{\"24\":1}}],[\"onclick\",{\"1\":{\"23\":1,\"24\":2}}],[\"on\",{\"1\":{\"23\":1}}],[\"offsetheight\",{\"1\":{\"10\":1}}],[\"object\",{\"1\":{\"8\":2,\"22\":1,\"60\":1}}],[\"强制\",{\"1\":{\"10\":1}}],[\"类型为\",{\"1\":{\"55\":1}}],[\"类似的有html这些\",{\"1\":{\"55\":1}}],[\"类\",{\"1\":{\"10\":1}}],[\"离场动画\",{\"1\":{\"10\":1}}],[\"添加到任务队列\",{\"1\":{\"61\":1}}],[\"添加新节点\",{\"1\":{\"40\":1}}],[\"添加新元素\",{\"0\":{\"34\":1,\"39\":1}}],[\"添加el的属性有两种方式\",{\"1\":{\"19\":1}}],[\"添加\",{\"1\":{\"10\":2,\"24\":1}}],[\"移动节点五个分支\",{\"1\":{\"40\":1}}],[\"移动到\",{\"1\":{\"33\":1}}],[\"移动到何处\",{\"1\":{\"33\":1}}],[\"移动到另一个容器中\",{\"1\":{\"8\":1}}],[\"移动\",{\"1\":{\"11\":1,\"44\":1}}],[\"移除操作\",{\"1\":{\"40\":1}}],[\"移除旧节点\",{\"0\":{\"40\":1}}],[\"移除不存在的元素\",{\"0\":{\"35\":1}}],[\"移除元素\",{\"1\":{\"21\":1}}],[\"移除\",{\"1\":{\"10\":1}}],[\"嵌套调用\",{\"1\":{\"10\":1}}],[\"运动过程\",{\"1\":{\"10\":1}}],[\"为了将节点挂载到正确位置\",{\"1\":{\"34\":1}}],[\"为了更明确的知道属性里哪个是事件\",{\"1\":{\"23\":1}}],[\"为了使这种模板可以在不同环境下运行\",{\"1\":{\"17\":1}}],[\"为事件处理函数\",{\"1\":{\"23\":1}}],[\"为\",{\"1\":{\"10\":1}}],[\"为什么用\",{\"1\":{\"5\":2}}],[\"入场动画\",{\"1\":{\"10\":1}}],[\"过渡效果就呈现出来了\",{\"1\":{\"10\":1}}],[\"当父组件的props数据发生变化的时候\",{\"1\":{\"63\":1}}],[\"当客户端接收这个html后\",{\"1\":{\"51\":1}}],[\"当\",{\"1\":{\"44\":1}}],[\"当不是\",{\"1\":{\"25\":1}}],[\"当过渡完成后\",{\"1\":{\"10\":1}}],[\"当设计好这三个点后\",{\"1\":{\"10\":1}}],[\"当前\",{\"1\":{\"8\":1,\"34\":1}}],[\"如下面代码\",{\"1\":{\"51\":1}}],[\"如图所示\",{\"1\":{\"38\":1}}],[\"如何在旧子节点数组里第一个元素p\",{\"1\":{\"33\":1}}],[\"如何移动\",{\"0\":{\"33\":1,\"44\":1}}],[\"如何判断该元素需要移动\",{\"1\":{\"32\":1}}],[\"如何知道这个dom既出现在oldvnode\",{\"1\":{\"31\":1}}],[\"如何过渡\",{\"1\":{\"10\":1}}],[\"如果还没有开始刷新队列\",{\"1\":{\"61\":1}}],[\"如果改变\",{\"1\":{\"61\":1}}],[\"如果跟页面双向绑定了\",{\"1\":{\"61\":1}}],[\"如果前两个分支都没走\",{\"1\":{\"44\":1}}],[\"如果source\",{\"1\":{\"44\":1}}],[\"如果引申到vnode上\",{\"1\":{\"42\":1}}],[\"如果没找到\",{\"1\":{\"38\":1}}],[\"如果没有找到重复的key那就将newstartvnoe插入到oldstartvnode的上面即可\",{\"1\":{\"39\":1}}],[\"如果没有找到具有相同\",{\"1\":{\"35\":1}}],[\"如果没有前一个\",{\"1\":{\"34\":1}}],[\"如果没有缓存\",{\"1\":{\"8\":1}}],[\"如果可复用\",{\"1\":{\"38\":1}}],[\"如果i\",{\"1\":{\"38\":1,\"44\":1}}],[\"如果旧的有而新的没有说明要移除\",{\"1\":{\"35\":1}}],[\"如果有前一个\",{\"1\":{\"34\":1}}],[\"如果有缓存的内容\",{\"1\":{\"8\":1}}],[\"如果代码运行到这里\",{\"1\":{\"34\":1}}],[\"如果新子节点数组内有的而旧的没有的话\",{\"1\":{\"34\":1}}],[\"如果新旧vnode的个数不一样\",{\"1\":{\"30\":1}}],[\"如果新旧\",{\"1\":{\"22\":1}}],[\"如果anchor为null\",{\"1\":{\"33\":1}}],[\"如果移动的是vnode\",{\"1\":{\"33\":1}}],[\"如果当前找到的节点在旧\",{\"1\":{\"32\":2}}],[\"如果索引值具有单调递增的特性\",{\"1\":{\"32\":1}}],[\"如果找到了具有相同\",{\"1\":{\"31\":1}}],[\"如果是就进行diff算法\",{\"1\":{\"28\":1}}],[\"如果是就逐个卸载\",{\"1\":{\"25\":1}}],[\"如果是节点则调用processelement方法\",{\"1\":{\"28\":1}}],[\"如果是前四种类型的节点\",{\"1\":{\"28\":1}}],[\"如果是\",{\"1\":{\"25\":2}}],[\"如果也没有旧子节点\",{\"1\":{\"25\":1}}],[\"如果事件发生的时间早于事件处理函数绑定的时间\",{\"1\":{\"24\":1}}],[\"如果直接使用innerhtml去清空的话\",{\"1\":{\"21\":1}}],[\"如果该节点什么都没有\",{\"1\":{\"17\":1}}],[\"如果\",{\"1\":{\"8\":1,\"22\":3,\"30\":2,\"33\":1}}],[\"如果不是组件\",{\"1\":{\"8\":1}}],[\"到哪去\",{\"1\":{\"10\":1}}],[\"三\",{\"0\":{\"10\":1}}],[\"然后进行对状态的逐步改变\",{\"1\":{\"55\":1}}],[\"然后当遇见script\",{\"1\":{\"51\":1}}],[\"然后再去移动dom\",{\"1\":{\"44\":1}}],[\"然后通过判断是否有旧组件来进行决策执行mounted还是update\",{\"1\":{\"62\":1}}],[\"然后通过这个source函数\",{\"1\":{\"43\":1}}],[\"然后通过dom的原生方法进行移除\",{\"1\":{\"21\":1}}],[\"然后从顶部和底部遍历掉这些相同节点\",{\"1\":{\"42\":1}}],[\"然后oldendindex会变成\",{\"1\":{\"39\":1}}],[\"然后一直跳过\",{\"1\":{\"39\":1}}],[\"然后还讲了如何移动添加删除等等\",{\"1\":{\"36\":1}}],[\"然后赋值给anchor\",{\"1\":{\"33\":1}}],[\"然后就是p\",{\"1\":{\"33\":1}}],[\"然后判断children类型是string还是array\",{\"1\":{\"28\":1}}],[\"然后我去问chatgpt\",{\"1\":{\"23\":1}}],[\"然后我开始道谢\",{\"1\":{\"6\":1}}],[\"然后调用的时候就调用这个\",{\"1\":{\"23\":1}}],[\"然后把不同的地方进行替换\",{\"1\":{\"22\":1}}],[\"然后考虑到该操作会很频繁页很常见\",{\"1\":{\"21\":1}}],[\"然后最后插入到container\",{\"1\":{\"19\":1}}],[\"然后在组件的进场和离场之前\",{\"1\":{\"11\":1}}],[\"然后讨论出三个钩子函数\",{\"1\":{\"11\":1}}],[\"然后将children挂载上去即可\",{\"1\":{\"9\":1}}],[\"通过render所提供的vnode就可以将该组件渲染出来了\",{\"1\":{\"60\":1}}],[\"通过\",{\"1\":{\"60\":1}}],[\"通过parser编译后\",{\"1\":{\"55\":1}}],[\"通过预处理后\",{\"1\":{\"43\":1}}],[\"通过比较key值\",{\"1\":{\"38\":1}}],[\"通过调用addeventlistener绑定事件\",{\"1\":{\"23\":1}}],[\"通过调用renderer\",{\"1\":{\"22\":1}}],[\"通过createrenderer函数创建一个renderer\",{\"1\":{\"22\":1}}],[\"通过不断地patch\",{\"1\":{\"17\":1}}],[\"通过teleport组件渲染出的子组件内容\",{\"1\":{\"11\":1}}],[\"通过dom操作获取到指定的节点\",{\"1\":{\"9\":1}}],[\"通过以上的构建就得到了一些信息\",{\"1\":{\"8\":1}}],[\"还需要在分支5加个判断\",{\"1\":{\"39\":1}}],[\"还有vue的指令挂载\",{\"1\":{\"28\":1}}],[\"还有一个\",{\"1\":{\"17\":1}}],[\"还是多个子节点\",{\"1\":{\"25\":1}}],[\"还是随便放\",{\"1\":{\"9\":1}}],[\"还可以进行检测该东东是否是组件了\",{\"1\":{\"21\":1}}],[\"还可以\",{\"1\":{\"6\":1}}],[\"break\",{\"1\":{\"31\":2,\"32\":2,\"33\":1,\"34\":1,\"55\":6}}],[\"beforeupdate\",{\"1\":{\"62\":4}}],[\"beforeunmounted生命周期函数\",{\"1\":{\"21\":1}}],[\"beforemount\",{\"1\":{\"62\":4}}],[\"beforecreate\",{\"1\":{\"62\":4}}],[\"beforeenter\",{\"1\":{\"10\":1}}],[\"bar\",{\"1\":{\"20\":3}}],[\"bol\",{\"1\":{\"24\":3}}],[\"box\",{\"1\":{\"10\":2}}],[\"body>\",{\"1\":{\"51\":1}}],[\"body\",{\"1\":{\"9\":1,\"10\":2}}],[\"bind\",{\"1\":{\"9\":1}}],[\"而问题一\",{\"1\":{\"61\":1}}],[\"而watch又是对effect的扩展\",{\"1\":{\"61\":1}}],[\"而这些导致页面会重新渲染的变量\",{\"1\":{\"61\":1}}],[\"而判断移除也差不多\",{\"1\":{\"40\":1}}],[\"而newvnode的顺序是pn\",{\"1\":{\"38\":1}}],[\"而不是移动虚拟dom\",{\"1\":{\"33\":1}}],[\"而不需要创建新的真实dom节点\",{\"1\":{\"11\":1}}],[\"而且对于上面的问题二\",{\"1\":{\"62\":1}}],[\"而且patch\",{\"1\":{\"28\":1}}],[\"而且除了类型上\",{\"1\":{\"22\":1}}],[\"而且这个to属性还可以进行v\",{\"1\":{\"9\":1}}],[\"而render可以将这种vnode转换成真实dom\",{\"1\":{\"17\":1}}],[\"而旧的存在的话\",{\"1\":{\"17\":1}}],[\"而渲染器则是由createrenderer所创建\",{\"1\":{\"17\":1}}],[\"而他们的定义是基于组件上进行修改\",{\"1\":{\"11\":1}}],[\"而应该执行激活\",{\"1\":{\"8\":1}}],[\"hope\",{\"1\":{\"66\":1}}],[\"head>\",{\"1\":{\"51\":1}}],[\"href=\",{\"1\":{\"51\":1}}],[\"has\",{\"1\":{\"35\":2}}],[\"html>\",{\"1\":{\"51\":2}}],[\"html\",{\"1\":{\"19\":2,\"66\":1}}],[\"http是tcp\",{\"1\":{\"11\":1}}],[\"http的长连接本质上是tcp的长连接\",{\"1\":{\"11\":1}}],[\"https\",{\"1\":{\"8\":1,\"15\":1,\"44\":1,\"66\":1}}],[\"http\",{\"1\":{\"8\":1},\"2\":{\"13\":1}}],[\"h1\",{\"1\":{\"17\":1,\"55\":2}}],[\"h1>`\",{\"1\":{\"17\":1}}],[\"h1>\",{\"1\":{\"9\":1,\"17\":1,\"55\":1}}],[\"hydrate\",{\"1\":{\"17\":1}}],[\"<script\",{\"1\":{\"51\":1}}],[\"<div>\",{\"1\":{\"55\":1}}],[\"<div\",{\"1\":{\"51\":1}}],[\"<body>\",{\"1\":{\"51\":1}}],[\"<link\",{\"1\":{\"51\":1}}],[\"<title>my\",{\"1\":{\"51\":1}}],[\"<teleport\",{\"1\":{\"9\":1}}],[\"<meta\",{\"1\":{\"51\":2}}],[\"<h1\",{\"1\":{\"55\":1}}],[\"<h1>title<\",{\"1\":{\"9\":1}}],[\"<head>\",{\"1\":{\"51\":1}}],[\"<html\",{\"1\":{\"51\":1}}],[\"<=\",{\"1\":{\"39\":1,\"40\":5,\"55\":2}}],[\"<\",{\"1\":{\"9\":1,\"17\":1,\"24\":1,\"30\":3,\"31\":2,\"32\":3,\"33\":3,\"34\":3,\"35\":2,\"38\":1,\"40\":2,\"44\":1,\"51\":4,\"55\":6}}],[\"<p>content<\",{\"1\":{\"9\":1}}],[\">vue\",{\"1\":{\"55\":1}}],[\"><\",{\"1\":{\"51\":3}}],[\">=\",{\"1\":{\"44\":1,\"55\":2}}],[\">func\",{\"1\":{\"23\":1}}],[\">\",{\"1\":{\"9\":1,\"23\":1,\"30\":4,\"39\":1,\"51\":4,\"55\":7}}],[\"该节点的下一个节点的位置索引\",{\"1\":{\"44\":1}}],[\"该节点在新的一组子节点中的真实位置索引\",{\"1\":{\"44\":1}}],[\"该区间记录的是在newchildren中这段上升子序列的索引值\",{\"1\":{\"44\":1}}],[\"该组件的诞生是为了解决组件的层级关系不依赖与模板结构\",{\"1\":{\"9\":1}}],[\"该对象会暴露渲染器的一些内部方法\",{\"1\":{\"8\":1}}],[\"该对象由渲染器注入\",{\"1\":{\"8\":1}}],[\"二\",{\"0\":{\"9\":1}}],[\"不管是effect还是watch\",{\"1\":{\"61\":1}}],[\"不管哪种diff算法\",{\"1\":{\"43\":1}}],[\"不带有前缀\",{\"1\":{\"55\":1}}],[\"不符合快速的这一名称\",{\"1\":{\"43\":1}}],[\"不存在\",{\"1\":{\"33\":1}}],[\"不需要去管理庞大的页面模板\",{\"1\":{\"59\":1}}],[\"不需要切换状态\",{\"1\":{\"55\":1}}],[\"不需要做任何dom操作\",{\"1\":{\"44\":1}}],[\"不需要做改动的操作\",{\"1\":{\"31\":1}}],[\"不需要更新也不需要挂载和卸载\",{\"1\":{\"31\":1}}],[\"不能只是单纯的更新\",{\"1\":{\"30\":1}}],[\"不是一样就先卸载oldvnode\",{\"1\":{\"28\":1}}],[\"不是数组就不需要管\",{\"1\":{\"25\":1}}],[\"不是背的\",{\"1\":{\"6\":1}}],[\"不过为了使这个方法更加强大\",{\"1\":{\"25\":1}}],[\"不过在\",{\"1\":{\"24\":1}}],[\"不过考虑到所传进来的vnode并不是同一种类型\",{\"1\":{\"22\":1}}],[\"不过考虑到耦合性\",{\"1\":{\"17\":1}}],[\"不过考虑到缓存过多成本也很大\",{\"1\":{\"11\":1}}],[\"不过考虑到to的值会发送变化\",{\"1\":{\"9\":1}}],[\"不对其进行后续的缓存操作\",{\"1\":{\"8\":1}}],[\"||\",{\"1\":{\"8\":1,\"24\":1,\"55\":1}}],[\"匹配以\",{\"1\":{\"23\":1}}],[\"匹配\",{\"1\":{\"8\":2}}],[\"内部什么都没有\",{\"1\":{\"51\":1}}],[\"内部组件\",{\"1\":{\"8\":2}}],[\"内建组件和模块\",{\"0\":{\"7\":1}}],[\"获取组件要渲染的内容\",{\"1\":{\"60\":1}}],[\"获取组件的渲染函数\",{\"1\":{\"60\":1}}],[\"获取组件的选项对象\",{\"1\":{\"60\":1}}],[\"获取兄弟节点的下一个节点\",{\"1\":{\"33\":1}}],[\"获取要卸载的真实\",{\"1\":{\"21\":1}}],[\"获取\",{\"1\":{\"8\":1,\"21\":1}}],[\"省略部分代码\",{\"1\":{\"8\":2,\"23\":3,\"24\":3,\"30\":2,\"31\":2,\"32\":2,\"33\":4,\"34\":6,\"35\":3,\"40\":2}}],[\"就叫做组件自身的状态\",{\"1\":{\"61\":1}}],[\"就跟抽离函数一样\",{\"1\":{\"59\":1}}],[\"就属于新增节点\",{\"1\":{\"39\":1}}],[\"就将newstartvode的位置排好了\",{\"1\":{\"38\":1}}],[\"就意味着新增了\",{\"1\":{\"38\":1}}],[\"就能完成操作\",{\"1\":{\"38\":1}}],[\"就一定时空了\",{\"1\":{\"25\":1}}],[\"就算事件冒泡\",{\"1\":{\"24\":1}}],[\"就避免了一次remove的操作\",{\"1\":{\"23\":1}}],[\"就统一安排on为前缀\",{\"1\":{\"23\":1}}],[\"就可以达到那种数据跟页面同步的效果\",{\"1\":{\"16\":1}}],[\"就是利用变量存储旧组件\",{\"1\":{\"62\":1}}],[\"就是判断newend是否小于newstart并且满足oldstart要小于等于oldend\",{\"1\":{\"40\":1}}],[\"就是在分支5中加个判断\",{\"1\":{\"39\":1}}],[\"就是属性了\",{\"1\":{\"28\":1}}],[\"就是将children全部挂载到body下面去\",{\"1\":{\"9\":1}}],[\"就是说\",{\"1\":{\"9\":1}}],[\"就是对include和exclude以及max的实现了\",{\"1\":{\"8\":1}}],[\"就差不多是一道设计一个缓存机制的算法题\",{\"1\":{\"8\":1}}],[\"59\",{\"1\":{\"55\":1}}],[\"58\",{\"1\":{\"55\":1}}],[\"5\",{\"0\":{\"21\":1,\"34\":1,\"63\":1},\"1\":{\"28\":2,\"43\":2,\"55\":1}}],[\"57\",{\"1\":{\"8\":1,\"34\":1,\"55\":1}}],[\"56\",{\"1\":{\"8\":1,\"34\":1,\"55\":1}}],[\"55\",{\"1\":{\"8\":1,\"34\":1,\"55\":1}}],[\"54\",{\"1\":{\"8\":1,\"24\":1,\"34\":1,\"55\":1}}],[\"53\",{\"1\":{\"8\":1,\"34\":1,\"55\":1}}],[\"52\",{\"1\":{\"8\":1,\"34\":1,\"55\":1}}],[\"51\",{\"1\":{\"8\":1,\"34\":1,\"55\":1}}],[\"50\",{\"1\":{\"8\":1,\"34\":1,\"55\":1}}],[\"上一步的更新操作完成后\",{\"1\":{\"35\":1}}],[\"上面的代码片段就是parser所需要实现的功能\",{\"1\":{\"55\":1}}],[\"上面分析了该算法如何执行\",{\"1\":{\"39\":1}}],[\"上面是理想状态下的双端diff算法比较\",{\"1\":{\"38\":1}}],[\"上面是该算法的变量\",{\"1\":{\"38\":1}}],[\"上面解决了找到可复用的节点\",{\"1\":{\"32\":1}}],[\"上面就只需要进行调用unmount\",{\"1\":{\"21\":1}}],[\"上\",{\"1\":{\"8\":1}}],[\"上添加\",{\"1\":{\"8\":2}}],[\"将该标志设置为\",{\"1\":{\"61\":1}}],[\"将当前字符缓存到\",{\"1\":{\"55\":2}}],[\"将当前字母缓存到\",{\"1\":{\"55\":1}}],[\"将索引去指向需要diff的区域即可\",{\"1\":{\"42\":1}}],[\"将锚点元素透传给\",{\"1\":{\"34\":1}}],[\"将渲染往后推\",{\"1\":{\"24\":1}}],[\"将el\",{\"1\":{\"23\":1}}],[\"将这些钩子函数执行\",{\"1\":{\"11\":1}}],[\"将卸载动作封装到\",{\"1\":{\"10\":1}}],[\"将元素添加到页面\",{\"1\":{\"10\":1}}],[\"将初始状态和运动过程定义到元素上\",{\"1\":{\"10\":1}}],[\"将\",{\"1\":{\"8\":1,\"61\":1}}],[\"将不用的组件缓存到一个看不见的地方\",{\"1\":{\"8\":1}}],[\"则刷新之\",{\"1\":{\"61\":1}}],[\"则走对应分支\",{\"1\":{\"38\":1}}],[\"则使用它的下一个兄弟节点作为锚点元素\",{\"1\":{\"34\":1}}],[\"则将变量\",{\"1\":{\"34\":1}}],[\"则将其添加到缓存中\",{\"1\":{\"8\":1}}],[\"则会插入到最后面\",{\"1\":{\"33\":1}}],[\"则会调用对应的process方法进行挂载到container上\",{\"1\":{\"28\":1}}],[\"则说明需要删除该节点\",{\"1\":{\"35\":1}}],[\"则说明当前\",{\"1\":{\"33\":1}}],[\"则说明不应该执行挂载\",{\"1\":{\"8\":1}}],[\"则更新\",{\"1\":{\"32\":1}}],[\"则判断\",{\"1\":{\"25\":2}}],[\"则不执行事件处理函数\",{\"1\":{\"24\":1}}],[\"则它描述的是组件\",{\"1\":{\"22\":1}}],[\"则它描述的是普通标签元素\",{\"1\":{\"22\":1}}],[\"则它叫做挂在\",{\"1\":{\"17\":1}}],[\"则直接将旧\",{\"1\":{\"22\":1}}],[\"则直接渲染\",{\"1\":{\"8\":1}}],[\"则对比\",{\"1\":{\"22\":1}}],[\"则进行将数组内的内容全部挂在到vnode\",{\"1\":{\"19\":1}}],[\"emits\",{\"1\":{\"63\":1}}],[\"emmm这种补丁加个判断就好了\",{\"1\":{\"23\":1}}],[\"event都是特殊属性\",{\"1\":{\"28\":1}}],[\"e\",{\"1\":{\"24\":7}}],[\"expression\",{\"1\":{\"55\":1}}],[\"exp\",{\"1\":{\"55\":1}}],[\"exist\",{\"1\":{\"17\":2}}],[\"exclude\",{\"1\":{\"8\":4,\"11\":1}}],[\"effect\",{\"1\":{\"17\":1,\"24\":2,\"61\":1,\"62\":1}}],[\"element\",{\"1\":{\"55\":2}}],[\"el记录的是真实dom\",{\"1\":{\"33\":1}}],[\"el\",{\"1\":{\"10\":17,\"20\":1,\"21\":7,\"23\":3,\"24\":7,\"28\":1,\"33\":5,\"34\":4,\"44\":2}}],[\"else\",{\"1\":{\"8\":1,\"17\":1,\"21\":1,\"22\":6,\"23\":3,\"24\":6,\"25\":4,\"30\":3,\"31\":2,\"32\":3,\"33\":3,\"34\":7,\"35\":2,\"40\":1,\"44\":2,\"55\":5,\"60\":4,\"62\":1}}],[\"enter\",{\"1\":{\"10\":10}}],[\"es6\",{\"1\":{\"5\":1}}],[\"在这里调用\",{\"1\":{\"62\":6}}],[\"在微任务中刷新缓冲队列\",{\"1\":{\"61\":1}}],[\"在vnode的层次上\",{\"1\":{\"60\":1}}],[\"在vnode对象上创建一个el属性\",{\"1\":{\"21\":1}}],[\"在非理想状态下\",{\"1\":{\"39\":1}}],[\"在加个对oldstartvnode做一下特殊处理\",{\"1\":{\"38\":1}}],[\"在而oldtovnode的位置的vnode是已经走过了的\",{\"1\":{\"38\":1}}],[\"在oldchildren\",{\"1\":{\"38\":1}}],[\"在插入节点时\",{\"1\":{\"34\":1}}],[\"在第一层循环中定义变量\",{\"1\":{\"34\":1}}],[\"在关于时间的存储和比较方面\",{\"1\":{\"24\":1}}],[\"在点击后\",{\"1\":{\"24\":1}}],[\"在挂载\",{\"1\":{\"23\":1}}],[\"在挂载时先获取缓存的组件\",{\"1\":{\"8\":1}}],[\"在下一帧切换状态\",{\"1\":{\"10\":1}}],[\"在设计原生的过渡效果的时候\",{\"1\":{\"10\":1}}],[\"在组件\",{\"1\":{\"8\":1}}],[\"在\",{\"1\":{\"8\":1,\"10\":1}}],[\"4\",{\"0\":{\"20\":1,\"33\":1,\"45\":1,\"62\":1},\"1\":{\"28\":1,\"39\":1,\"43\":2,\"55\":4}}],[\"49\",{\"1\":{\"8\":1,\"24\":1,\"34\":1,\"55\":1}}],[\"48\",{\"1\":{\"8\":1,\"34\":1,\"55\":1}}],[\"47\",{\"1\":{\"8\":1,\"34\":1,\"55\":1}}],[\"46\",{\"1\":{\"8\":1,\"34\":1,\"55\":1}}],[\"45\",{\"1\":{\"8\":1,\"34\":1,\"55\":1}}],[\"44\",{\"1\":{\"8\":1,\"34\":1,\"55\":1}}],[\"43\",{\"1\":{\"8\":1,\"34\":1,\"55\":1}}],[\"42\",{\"1\":{\"8\":1,\"34\":1,\"55\":1}}],[\"41\",{\"1\":{\"8\":1,\"34\":1,\"55\":1}}],[\"40\",{\"1\":{\"8\":1,\"33\":1,\"34\":1,\"55\":1}}],[\"继承组件实例\",{\"1\":{\"8\":1}}],[\"github\",{\"1\":{\"15\":1}}],[\"getelementbyid\",{\"1\":{\"17\":1}}],[\"get\",{\"1\":{\"8\":1}}],[\"gzip\",{\"1\":{\"5\":1}}],[\"3不需要移动\",{\"1\":{\"33\":1}}],[\"3可得\",{\"1\":{\"33\":1}}],[\"3\",{\"0\":{\"19\":1,\"32\":1,\"40\":1,\"44\":1,\"61\":1},\"1\":{\"28\":1,\"39\":2,\"43\":1,\"55\":7}}],[\"39\",{\"1\":{\"8\":1,\"33\":1,\"34\":1,\"55\":1,\"62\":1}}],[\"38\",{\"1\":{\"8\":1,\"33\":1,\"34\":1,\"55\":1,\"62\":1}}],[\"37\",{\"1\":{\"8\":1,\"33\":1,\"34\":1,\"55\":1,\"62\":1}}],[\"36\",{\"1\":{\"8\":1,\"24\":1,\"33\":1,\"34\":1,\"55\":1,\"62\":1}}],[\"35\",{\"1\":{\"8\":2,\"24\":1,\"33\":1,\"34\":1,\"42\":1,\"55\":1,\"62\":1}}],[\"34\",{\"1\":{\"8\":2,\"24\":1,\"33\":1,\"34\":1,\"42\":1,\"55\":1,\"62\":1}}],[\"33\",{\"1\":{\"8\":2,\"24\":1,\"33\":1,\"34\":1,\"42\":1,\"55\":1,\"62\":1}}],[\"32\",{\"1\":{\"8\":2,\"24\":1,\"32\":1,\"33\":1,\"34\":1,\"42\":1,\"55\":1,\"62\":1}}],[\"31\",{\"1\":{\"8\":2,\"24\":1,\"30\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"42\":1,\"55\":1,\"62\":1}}],[\"30\",{\"1\":{\"8\":2,\"24\":1,\"30\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"42\":1,\"55\":2,\"62\":1}}],[\"root\",{\"1\":{\"55\":1}}],[\"resolve\",{\"1\":{\"61\":2}}],[\"rel=\",{\"1\":{\"51\":1}}],[\"react\",{\"1\":{\"42\":1}}],[\"reactivebasis\",{\"1\":{\"15\":1}}],[\"reactive\",{\"1\":{\"15\":1,\"61\":1,\"62\":1}}],[\"render函数\",{\"1\":{\"28\":1}}],[\"render方法将vnode挂载到container上\",{\"1\":{\"22\":1}}],[\"render\",{\"1\":{\"17\":2,\"21\":1,\"24\":1,\"60\":5,\"61\":2,\"62\":2}}],[\"renderer\",{\"1\":{\"17\":2,\"24\":1,\"33\":1}}],[\"ref\",{\"1\":{\"17\":1,\"24\":2}}],[\"reflow\",{\"1\":{\"10\":1}}],[\"removeeventlistener\",{\"1\":{\"24\":1}}],[\"removechild\",{\"1\":{\"10\":1,\"21\":3}}],[\"remove\",{\"1\":{\"10\":4}}],[\"requestanimationframe\",{\"1\":{\"10\":5}}],[\"regexp\",{\"1\":{\"8\":2}}],[\"return\",{\"1\":{\"8\":6,\"24\":1,\"55\":2,\"60\":1}}],[\"rawvnode\",{\"1\":{\"8\":16}}],[\"2往下移\",{\"1\":{\"38\":1}}],[\"2\",{\"0\":{\"31\":1,\"39\":1,\"43\":1,\"60\":1},\"1\":{\"23\":1,\"24\":1,\"28\":1,\"33\":1,\"39\":2,\"43\":5,\"55\":12}}],[\"29\",{\"1\":{\"8\":2,\"24\":1,\"30\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"42\":1,\"44\":1,\"55\":2,\"62\":1}}],[\"28\",{\"1\":{\"8\":2,\"10\":1,\"24\":2,\"30\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"42\":1,\"44\":1,\"55\":2,\"61\":1,\"62\":1}}],[\"27\",{\"1\":{\"8\":2,\"10\":1,\"24\":2,\"30\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"42\":1,\"44\":1,\"55\":2,\"61\":1,\"62\":1}}],[\"26\",{\"1\":{\"8\":2,\"10\":1,\"24\":2,\"30\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"42\":1,\"44\":1,\"55\":2,\"61\":1,\"62\":1}}],[\"25\",{\"1\":{\"8\":2,\"10\":1,\"24\":2,\"25\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":1,\"42\":1,\"44\":1,\"55\":2,\"60\":1,\"61\":1,\"62\":1}}],[\"24\",{\"1\":{\"8\":2,\"10\":1,\"24\":2,\"25\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":1,\"42\":1,\"44\":1,\"55\":2,\"60\":1,\"61\":1,\"62\":1}}],[\"23\",{\"1\":{\"8\":2,\"10\":1,\"24\":2,\"25\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":1,\"42\":1,\"44\":1,\"55\":2,\"60\":1,\"61\":1,\"62\":1}}],[\"22\",{\"1\":{\"8\":2,\"10\":1,\"24\":2,\"25\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":1,\"42\":1,\"44\":1,\"55\":2,\"60\":1,\"61\":1,\"62\":1}}],[\"21\",{\"1\":{\"8\":2,\"10\":1,\"24\":2,\"25\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":1,\"42\":1,\"44\":1,\"55\":2,\"60\":1,\"61\":1,\"62\":1}}],[\"20\",{\"1\":{\"8\":2,\"10\":1,\"22\":1,\"24\":2,\"25\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":1,\"42\":1,\"44\":1,\"55\":2,\"60\":1,\"61\":1,\"62\":1}}],[\"data\",{\"1\":{\"61\":2,\"62\":2}}],[\"directive\",{\"1\":{\"55\":2}}],[\"dist\",{\"1\":{\"51\":2}}],[\"diff算法\",{\"1\":{\"43\":1}}],[\"diff算法是用来计算两组子节点的差异\",{\"1\":{\"36\":1}}],[\"diff\",{\"1\":{\"25\":2}}],[\"div>\",{\"1\":{\"51\":1,\"55\":1}}],[\"div>这个东西\",{\"1\":{\"51\":1}}],[\"div\",{\"1\":{\"8\":1,\"10\":1,\"24\":1,\"25\":3,\"55\":2,\"60\":1}}],[\"doctype\",{\"1\":{\"51\":1}}],[\"document\",{\"1\":{\"10\":3,\"17\":1,\"24\":1}}],[\"dom复用和key的作用\",{\"0\":{\"31\":1}}],[\"dom\",{\"1\":{\"8\":1,\"10\":3,\"19\":1,\"21\":1,\"32\":1,\"33\":6,\"60\":3}}],[\"descritption\",{\"1\":{\"67\":1}}],[\"development\",{\"1\":{\"42\":2}}],[\"default\",{\"1\":{\"8\":2,\"28\":1}}],[\"deactivate\",{\"1\":{\"8\":2}}],[\"创建一个立即\",{\"1\":{\"61\":1}}],[\"创建一个缓存对象\",{\"1\":{\"8\":1}}],[\"创建应该invoker\",{\"1\":{\"23\":1}}],[\"创建\",{\"1\":{\"10\":1,\"24\":1}}],[\"创建隐藏容器\",{\"1\":{\"8\":1}}],[\"其返回值必须为虚拟\",{\"1\":{\"60\":1}}],[\"其他情况\",{\"1\":{\"25\":2}}],[\"其他叫做打补丁\",{\"1\":{\"17\":1}}],[\"其他两个就只是单纯匹配了\",{\"1\":{\"8\":1}}],[\"其实我第一想法是key\",{\"1\":{\"23\":1}}],[\"其实不同的标签应该有不同的处理方式\",{\"1\":{\"22\":1}}],[\"其实不管是第一次渲染还是第二次渲染\",{\"1\":{\"17\":1}}],[\"其实都可以叫做打补丁\",{\"1\":{\"17\":1}}],[\"其中引入了key\",{\"1\":{\"36\":1}}],[\"其中有type\",{\"1\":{\"17\":1}}],[\"其中第二步是指新的不存在\",{\"1\":{\"17\":1}}],[\"其中\",{\"1\":{\"8\":1}}],[\"其作用是允许多个请求或响应共用一个\",{\"1\":{\"8\":1}}],[\"对应index往上走\",{\"1\":{\"38\":1}}],[\"对应index往下走\",{\"1\":{\"38\":1}}],[\"对应真实\",{\"1\":{\"33\":1}}],[\"对应的真实\",{\"1\":{\"33\":3}}],[\"对\",{\"1\":{\"8\":1}}],[\"对keepalive组件的实现后\",{\"1\":{\"8\":1}}],[\"对象数组\",{\"1\":{\"17\":1}}],[\"对象\",{\"1\":{\"8\":1}}],[\"对于create生命周期是在组件状态设置好之前就调用的\",{\"1\":{\"62\":1}}],[\"对于class\",{\"1\":{\"28\":1}}],[\"对于组件的挂载\",{\"1\":{\"62\":1}}],[\"对于组件的过渡效果来说\",{\"1\":{\"10\":1}}],[\"对于问题二\",{\"1\":{\"61\":1}}],[\"对于响应式变量来说\",{\"1\":{\"61\":1}}],[\"对于这个对象里\",{\"1\":{\"60\":1}}],[\"对于不同的vnode\",{\"1\":{\"60\":1}}],[\"对于编译来说\",{\"1\":{\"55\":1}}],[\"对于vue来说\",{\"1\":{\"55\":1}}],[\"对于非理想情况\",{\"1\":{\"43\":1}}],[\"对于上面的节点\",{\"1\":{\"43\":1}}],[\"对于以上的预处理以及算法的设计\",{\"1\":{\"43\":1}}],[\"对于相同的\",{\"1\":{\"42\":1}}],[\"对于双端diff算法的原理\",{\"1\":{\"39\":1}}],[\"对于每一个分支\",{\"1\":{\"38\":1}}],[\"对于新旧vnode去操作dom的时候\",{\"1\":{\"38\":1}}],[\"对于更新children\",{\"1\":{\"25\":1}}],[\"对于teleport组件来说\",{\"1\":{\"11\":1}}],[\"对于keepalive组件是借用了http中的长连接的概率\",{\"1\":{\"11\":1}}],[\"对于max\",{\"1\":{\"8\":1}}],[\"对于\",{\"1\":{\"8\":1}}],[\"对于一个组件\",{\"1\":{\"8\":1}}],[\"1此dom的移动\",{\"1\":{\"38\":1}}],[\"1同理\",{\"1\":{\"33\":1}}],[\"1的索引\",{\"1\":{\"33\":1}}],[\"1\",{\"0\":{\"19\":1,\"30\":1,\"38\":1,\"42\":1,\"59\":1},\"1\":{\"17\":1,\"28\":1,\"33\":2,\"34\":2,\"38\":3,\"39\":3,\"42\":2,\"43\":2,\"44\":5,\"55\":23}}],[\"19\",{\"1\":{\"8\":2,\"10\":1,\"22\":1,\"24\":2,\"25\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":1,\"42\":1,\"44\":1,\"55\":2,\"60\":1,\"61\":1,\"62\":1}}],[\"18\",{\"1\":{\"8\":2,\"10\":2,\"22\":1,\"24\":2,\"25\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":1,\"42\":1,\"44\":1,\"55\":2,\"60\":1,\"61\":1,\"62\":1}}],[\"17\",{\"1\":{\"8\":2,\"10\":2,\"22\":1,\"24\":2,\"25\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":1,\"42\":1,\"44\":1,\"55\":2,\"60\":1,\"61\":1,\"62\":1}}],[\"16\",{\"1\":{\"8\":2,\"10\":2,\"21\":1,\"22\":1,\"24\":2,\"25\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":1,\"42\":1,\"44\":1,\"55\":2,\"60\":1,\"61\":1,\"62\":1}}],[\"15\",{\"1\":{\"8\":2,\"10\":2,\"21\":1,\"22\":1,\"23\":1,\"24\":2,\"25\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":1,\"42\":1,\"44\":1,\"55\":2,\"60\":1,\"61\":1,\"62\":1}}],[\"145\",{\"1\":{\"55\":1}}],[\"144\",{\"1\":{\"55\":1}}],[\"143\",{\"1\":{\"55\":1}}],[\"142\",{\"1\":{\"55\":1}}],[\"141\",{\"1\":{\"55\":1}}],[\"140\",{\"1\":{\"55\":1}}],[\"14\",{\"1\":{\"8\":2,\"10\":2,\"21\":1,\"22\":2,\"23\":1,\"24\":2,\"25\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":1,\"42\":1,\"44\":1,\"51\":1,\"55\":2,\"60\":1,\"61\":2,\"62\":1}}],[\"139\",{\"1\":{\"55\":1}}],[\"138\",{\"1\":{\"55\":1}}],[\"137\",{\"1\":{\"55\":1}}],[\"136\",{\"1\":{\"55\":1}}],[\"135\",{\"1\":{\"55\":1}}],[\"134\",{\"1\":{\"55\":1}}],[\"133\",{\"1\":{\"55\":1}}],[\"132\",{\"1\":{\"55\":1}}],[\"131\",{\"1\":{\"55\":1}}],[\"130\",{\"1\":{\"55\":1}}],[\"13\",{\"1\":{\"8\":2,\"10\":2,\"21\":1,\"22\":2,\"23\":1,\"24\":2,\"25\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":1,\"40\":1,\"42\":1,\"44\":1,\"51\":1,\"55\":2,\"60\":1,\"61\":2,\"62\":1}}],[\"129\",{\"1\":{\"55\":1}}],[\"128\",{\"1\":{\"55\":1}}],[\"127\",{\"1\":{\"55\":1}}],[\"126\",{\"1\":{\"55\":1}}],[\"125\",{\"1\":{\"55\":1}}],[\"124\",{\"1\":{\"55\":1}}],[\"123\",{\"1\":{\"55\":1}}],[\"122\",{\"1\":{\"55\":1}}],[\"121\",{\"1\":{\"55\":1}}],[\"120\",{\"1\":{\"55\":1}}],[\"12\",{\"0\":{\"28\":1},\"1\":{\"8\":2,\"10\":2,\"21\":1,\"22\":2,\"23\":1,\"24\":2,\"25\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":1,\"40\":1,\"42\":1,\"44\":1,\"51\":1,\"55\":2,\"60\":2,\"61\":2,\"62\":1}}],[\"119\",{\"1\":{\"55\":1}}],[\"118\",{\"1\":{\"55\":1}}],[\"117\",{\"1\":{\"55\":1}}],[\"116\",{\"1\":{\"55\":1}}],[\"115\",{\"1\":{\"55\":1}}],[\"114\",{\"1\":{\"55\":1}}],[\"113\",{\"1\":{\"55\":1}}],[\"113286469\",{\"1\":{\"8\":1}}],[\"112\",{\"1\":{\"55\":1}}],[\"111\",{\"1\":{\"55\":1}}],[\"110\",{\"1\":{\"55\":1}}],[\"11\",{\"0\":{\"27\":1,\"42\":1,\"43\":1,\"44\":1,\"45\":1},\"1\":{\"8\":2,\"10\":2,\"21\":1,\"22\":2,\"23\":1,\"24\":2,\"25\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":1,\"40\":1,\"42\":1,\"44\":1,\"51\":1,\"55\":2,\"60\":2,\"61\":2,\"62\":1}}],[\"109\",{\"1\":{\"55\":1}}],[\"108\",{\"1\":{\"55\":1}}],[\"107\",{\"1\":{\"55\":1}}],[\"106\",{\"1\":{\"55\":1}}],[\"105\",{\"1\":{\"55\":1}}],[\"104\",{\"1\":{\"55\":1}}],[\"103\",{\"1\":{\"55\":1}}],[\"102\",{\"1\":{\"55\":1}}],[\"101\",{\"1\":{\"55\":1}}],[\"100\",{\"1\":{\"55\":1}}],[\"10\",{\"0\":{\"26\":1,\"38\":1,\"39\":1,\"40\":1},\"1\":{\"8\":2,\"10\":2,\"21\":1,\"22\":2,\"23\":1,\"24\":2,\"25\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":2,\"34\":2,\"35\":1,\"40\":1,\"42\":1,\"44\":1,\"51\":1,\"55\":2,\"60\":3,\"61\":2,\"62\":1}}],[\"mycomponent\",{\"1\":{\"60\":2}}],[\"min\",{\"1\":{\"30\":1}}],[\"math\",{\"1\":{\"30\":1}}],[\"max\",{\"1\":{\"11\":1}}],[\"map\",{\"1\":{\"8\":2}}],[\"mounted\",{\"1\":{\"62\":4}}],[\"mountelement\",{\"1\":{\"22\":3,\"34\":4}}],[\"mountelement函数\",{\"1\":{\"19\":1,\"28\":1}}],[\"mountcomponent\",{\"1\":{\"60\":2,\"61\":1,\"62\":1}}],[\"mount\",{\"1\":{\"17\":1}}],[\"moved\",{\"1\":{\"44\":1}}],[\"move\",{\"1\":{\"8\":4,\"11\":1}}],[\"monorepo\",{\"1\":{\"5\":1}}],[\"now\",{\"1\":{\"24\":2}}],[\"not\",{\"1\":{\"22\":2}}],[\"nextpos\",{\"1\":{\"44\":3}}],[\"nextend\",{\"1\":{\"42\":1}}],[\"nextsibling\",{\"1\":{\"33\":2,\"34\":2}}],[\"nextvalue\",{\"1\":{\"23\":4,\"24\":5}}],[\"newstart\",{\"1\":{\"44\":1}}],[\"newstartidx\",{\"1\":{\"40\":3}}],[\"newend\",{\"1\":{\"42\":5}}],[\"newendidx\",{\"1\":{\"40\":3}}],[\"newendindex\",{\"1\":{\"39\":1}}],[\"newlen\",{\"1\":{\"30\":7}}],[\"newchildren\",{\"1\":{\"30\":4,\"31\":3,\"32\":3,\"33\":4,\"34\":5,\"35\":3,\"39\":1,\"42\":6,\"43\":1,\"44\":3}}],[\"newvnode\",{\"1\":{\"22\":3,\"25\":3,\"31\":3,\"32\":3,\"33\":9,\"34\":9,\"42\":8,\"44\":2}}],[\"new\",{\"1\":{\"8\":2,\"61\":1}}],[\"n2\",{\"1\":{\"22\":12,\"25\":5,\"30\":4,\"31\":4,\"32\":4,\"33\":4,\"34\":7,\"35\":4,\"42\":2,\"60\":5}}],[\"n1\",{\"1\":{\"22\":16,\"25\":7,\"30\":2,\"31\":2,\"32\":2,\"33\":2,\"34\":5,\"35\":2,\"42\":2,\"60\":7}}],[\"null\",{\"1\":{\"17\":1,\"22\":5,\"25\":3,\"30\":1,\"33\":1,\"34\":2,\"44\":1,\"60\":2,\"61\":2,\"62\":2}}],[\"name=\",{\"1\":{\"51\":1}}],[\"name\",{\"1\":{\"8\":8,\"23\":2,\"24\":3,\"55\":3,\"60\":1}}],[\"nginx\",{\"1\":{\"5\":1}}],[\"category\",{\"1\":{\"67\":1}}],[\"call\",{\"1\":{\"61\":1,\"62\":6}}],[\"case\",{\"1\":{\"55\":6}}],[\"cachedvnode\",{\"1\":{\"8\":3}}],[\"cache\",{\"1\":{\"8\":4}}],[\"currentstate\",{\"1\":{\"55\":10}}],[\"currentinstance\",{\"1\":{\"8\":1}}],[\"css\",{\"1\":{\"51\":2}}],[\"cn\",{\"1\":{\"44\":1}}],[\"created\",{\"1\":{\"62\":4}}],[\"createrenderer\",{\"1\":{\"33\":1}}],[\"createelement\",{\"1\":{\"8\":2,\"10\":1}}],[\"c\",{\"1\":{\"25\":6}}],[\"chars\",{\"1\":{\"55\":25}}],[\"charset=\",{\"1\":{\"51\":1}}],[\"char\",{\"1\":{\"55\":23}}],[\"chrome\",{\"1\":{\"24\":1}}],[\"children的内容有很多相同\",{\"1\":{\"31\":1}}],[\"children的长度\",{\"1\":{\"30\":1}}],[\"children是不是array\",{\"1\":{\"28\":2}}],[\"children是不是array是的话就循环卸载oldvnode\",{\"1\":{\"28\":1}}],[\"children是不是string\",{\"1\":{\"28\":1}}],[\"children属性是否是string\",{\"1\":{\"19\":1}}],[\"children\",{\"1\":{\"17\":3,\"24\":2,\"25\":15,\"28\":2,\"30\":5,\"31\":8,\"32\":6,\"33\":4,\"34\":4,\"35\":4,\"42\":2,\"55\":2,\"60\":1}}],[\"clear\",{\"1\":{\"61\":1}}],[\"clicked\",{\"1\":{\"24\":1}}],[\"click\",{\"1\":{\"10\":1,\"23\":1}}],[\"classname\",{\"1\":{\"20\":2}}],[\"class=\",{\"1\":{\"20\":3}}],[\"class的处理\",{\"0\":{\"20\":1}}],[\"classlist三种方法\",{\"1\":{\"20\":1}}],[\"classlist\",{\"1\":{\"10\":11}}],[\"class\",{\"1\":{\"10\":1,\"23\":1,\"24\":1,\"63\":1}}],[\"count\",{\"1\":{\"17\":3,\"44\":1}}],[\"config\",{\"1\":{\"66\":1}}],[\"content\",{\"1\":{\"55\":2}}],[\"content=\",{\"1\":{\"51\":1}}],[\"contaienr\",{\"1\":{\"22\":1}}],[\"container两个参数\",{\"1\":{\"28\":1}}],[\"container\",{\"1\":{\"8\":2,\"17\":3,\"19\":1,\"21\":8,\"22\":6,\"25\":5,\"30\":3,\"31\":2,\"32\":2,\"33\":3,\"34\":9,\"35\":1,\"42\":3,\"44\":1,\"60\":4,\"61\":2,\"62\":3}}],[\"const\",{\"1\":{\"8\":9,\"10\":2,\"17\":1,\"21\":3,\"22\":1,\"23\":1,\"24\":5,\"30\":5,\"31\":4,\"32\":4,\"33\":7,\"34\":7,\"35\":4,\"42\":2,\"44\":5,\"55\":5,\"60\":5,\"61\":6,\"62\":5}}],[\"connection\",{\"1\":{\"8\":1}}],[\"commonlength\",{\"1\":{\"30\":5}}],[\"comment\",{\"1\":{\"28\":1}}],[\"componentoptions\",{\"1\":{\"60\":2,\"61\":2,\"62\":2}}],[\"component\",{\"1\":{\"8\":2,\"62\":1}}],[\"computed\",{\"1\":{\"5\":1}}],[\"com\",{\"1\":{\"8\":1,\"15\":1}}],[\"cors\",{\"1\":{\"5\":1}}],[\"keptalive\",{\"1\":{\"8\":2}}],[\"key相同\",{\"1\":{\"31\":1}}],[\"key\",{\"1\":{\"8\":1,\"23\":6,\"24\":7,\"31\":3,\"32\":2,\"33\":2,\"34\":2,\"35\":4,\"42\":5}}],[\"keepaliveinstance\",{\"1\":{\"8\":1}}],[\"keepalivectx\",{\"1\":{\"8\":2}}],[\"keepalive本质上是对组件的缓存\",{\"1\":{\"8\":1}}],[\"keepalive就是用来解决这个问题的\",{\"1\":{\"8\":1}}],[\"keepalive\",{\"1\":{\"8\":11},\"2\":{\"13\":1}}],[\"keepalive组件的实现原理\",{\"0\":{\"8\":1}}],[\"subtree\",{\"1\":{\"60\":3,\"61\":3,\"62\":7}}],[\"switch\",{\"1\":{\"55\":2}}],[\"scheduler\",{\"1\":{\"61\":1,\"62\":1}}],[\"script>\",{\"1\":{\"51\":1}}],[\"scale=1\",{\"1\":{\"51\":1}}],[\"src=\",{\"1\":{\"51\":1}}],[\"seq\",{\"1\":{\"44\":6}}],[\"setelementtext\",{\"1\":{\"25\":3}}],[\"setattribute\",{\"1\":{\"20\":1}}],[\"set\",{\"1\":{\"8\":1,\"61\":2}}],[\"setup\",{\"1\":{\"8\":2}}],[\"s\",{\"1\":{\"44\":8}}],[\"source\",{\"1\":{\"44\":1}}],[\"sources\",{\"1\":{\"44\":1}}],[\"source数组\",{\"1\":{\"44\":1}}],[\"sourcecode\",{\"1\":{\"15\":1}}],[\"some\",{\"1\":{\"25\":2}}],[\"shouldsetasprops\",{\"1\":{\"23\":1,\"24\":1}}],[\"shouldkeepalive\",{\"1\":{\"8\":2}}],[\"slice\",{\"1\":{\"23\":1,\"24\":1,\"55\":11}}],[\"slots\",{\"1\":{\"8\":4}}],[\"star\",{\"1\":{\"67\":1}}],[\"state\",{\"1\":{\"55\":16,\"61\":3,\"62\":9}}],[\"static\",{\"1\":{\"28\":1}}],[\"str\",{\"1\":{\"55\":25}}],[\"string\",{\"1\":{\"22\":1,\"25\":5,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":1,\"60\":1}}],[\"stylesheet\",{\"1\":{\"51\":1}}],[\"style\",{\"1\":{\"28\":1,\"63\":1}}],[\"style属性也需要这种整合函数进行字符串化进行设置\",{\"1\":{\"20\":1}}],[\"study\",{\"1\":{\"15\":1}}],[\"storagecontainer\",{\"1\":{\"8\":2}}],[\"id=\",{\"1\":{\"51\":2}}],[\"image\",{\"1\":{\"51\":1,\"68\":1}}],[\"i++\",{\"1\":{\"30\":3,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":2,\"40\":1}}],[\"i\",{\"1\":{\"30\":10,\"31\":3,\"32\":3,\"33\":5,\"34\":5,\"35\":5,\"38\":3,\"40\":3,\"42\":4,\"44\":11}}],[\"ismounted\",{\"1\":{\"62\":3}}],[\"isflushing\",{\"1\":{\"61\":4}}],[\"isalpha\",{\"1\":{\"55\":7}}],[\"isarray\",{\"1\":{\"24\":1,\"25\":4,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1}}],[\"is\",{\"1\":{\"17\":2,\"22\":4}}],[\"iskeepalive\",{\"1\":{\"8\":2}}],[\"ip的应用层服务\",{\"1\":{\"11\":1}}],[\"ip协议簇的子集之一\",{\"1\":{\"11\":1}}],[\"if=\",{\"1\":{\"55\":1}}],[\"if\",{\"1\":{\"8\":4,\"17\":2,\"21\":4,\"22\":9,\"23\":3,\"24\":8,\"25\":6,\"30\":4,\"31\":3,\"32\":4,\"33\":5,\"34\":11,\"35\":3,\"40\":2,\"44\":3,\"55\":14,\"60\":6,\"61\":1,\"62\":1}}],[\"info\",{\"1\":{\"66\":1}}],[\"initial\",{\"1\":{\"51\":1,\"55\":5}}],[\"insert\",{\"1\":{\"33\":3,\"34\":3,\"44\":1}}],[\"insertbefore\",{\"1\":{\"33\":3}}],[\"instance\",{\"1\":{\"8\":5,\"62\":6}}],[\"invoker\",{\"1\":{\"24\":14}}],[\"invokers\",{\"1\":{\"24\":2}}],[\"include\",{\"1\":{\"8\":4,\"11\":1}}],[\"indexof\",{\"1\":{\"5\":1}}],[\"组件自身的props\",{\"1\":{\"63\":1}}],[\"组件状态与自更新\",{\"0\":{\"61\":1}}],[\"组件名称\",{\"1\":{\"60\":1}}],[\"组件也不例外\",{\"1\":{\"60\":1}}],[\"组件实现原理\",{\"0\":{\"58\":1}}],[\"组件来说\",{\"1\":{\"8\":1}}],[\"组件的更新其实都表达的很明显了\",{\"1\":{\"62\":1}}],[\"组件的销毁\",{\"1\":{\"62\":1}}],[\"组件的vnode\",{\"1\":{\"60\":1}}],[\"组件的渲染函数\",{\"1\":{\"60\":1}}],[\"组件的渲染\",{\"0\":{\"60\":1}}],[\"组件的用法有两个用途\",{\"1\":{\"59\":1}}],[\"组件的实现原理\",{\"0\":{\"46\":1}}],[\"组件的实例与组件的生命周期\",{\"0\":{\"62\":1}}],[\"组件的实例也添加到\",{\"1\":{\"8\":1}}],[\"组件的实例上会被添加两个内部函数\",{\"1\":{\"8\":1}}],[\"组件的实例\",{\"1\":{\"8\":1}}],[\"组件的意义\",{\"1\":{\"5\":1}}],[\"组件独有的属性\",{\"1\":{\"8\":1}}],[\"0\",{\"1\":{\"30\":1,\"31\":2,\"32\":3,\"33\":3,\"34\":3,\"35\":3,\"42\":1,\"44\":1,\"51\":1,\"55\":4,\"61\":1}}],[\"09\",{\"1\":{\"8\":2,\"10\":2,\"21\":1,\"22\":2,\"23\":1,\"24\":2,\"25\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":2,\"34\":2,\"35\":1,\"40\":1,\"42\":1,\"44\":1,\"51\":1,\"55\":2,\"60\":3,\"61\":2,\"62\":1}}],[\"08\",{\"1\":{\"8\":2,\"10\":2,\"21\":1,\"22\":2,\"23\":1,\"24\":2,\"25\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":2,\"34\":2,\"35\":1,\"40\":1,\"42\":1,\"44\":1,\"51\":1,\"55\":2,\"60\":3,\"61\":2,\"62\":1}}],[\"07\",{\"1\":{\"8\":2,\"10\":2,\"21\":2,\"22\":2,\"23\":1,\"24\":2,\"25\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":2,\"34\":2,\"35\":1,\"40\":1,\"42\":1,\"44\":1,\"51\":1,\"55\":2,\"60\":3,\"61\":2,\"62\":1}}],[\"06\",{\"1\":{\"8\":2,\"10\":2,\"21\":2,\"22\":2,\"23\":1,\"24\":2,\"25\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":2,\"34\":2,\"35\":1,\"40\":1,\"42\":1,\"44\":1,\"51\":1,\"55\":2,\"60\":3,\"61\":2,\"62\":1}}],[\"05\",{\"1\":{\"8\":2,\"10\":2,\"21\":2,\"22\":2,\"23\":1,\"24\":2,\"25\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":2,\"34\":2,\"35\":1,\"40\":1,\"42\":1,\"44\":1,\"51\":1,\"55\":2,\"60\":3,\"61\":2,\"62\":1}}],[\"04\",{\"1\":{\"8\":2,\"9\":1,\"10\":2,\"21\":2,\"22\":2,\"23\":1,\"24\":2,\"25\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":2,\"34\":2,\"35\":1,\"40\":1,\"42\":1,\"44\":1,\"51\":1,\"55\":2,\"60\":3,\"61\":2,\"62\":1}}],[\"03\",{\"1\":{\"8\":2,\"9\":1,\"10\":2,\"21\":2,\"22\":2,\"23\":1,\"24\":2,\"25\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":2,\"34\":2,\"35\":1,\"40\":1,\"42\":1,\"44\":1,\"51\":1,\"55\":3,\"60\":3,\"61\":2,\"62\":1}}],[\"02\",{\"1\":{\"8\":2,\"9\":1,\"10\":2,\"21\":2,\"22\":2,\"23\":1,\"24\":2,\"25\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":2,\"34\":2,\"35\":1,\"40\":1,\"42\":3,\"44\":1,\"51\":1,\"55\":3,\"60\":3,\"61\":2,\"62\":1}}],[\"01\",{\"1\":{\"8\":2,\"9\":1,\"10\":2,\"21\":2,\"22\":2,\"23\":1,\"24\":2,\"25\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":2,\"34\":2,\"35\":1,\"40\":1,\"42\":3,\"44\":1,\"51\":1,\"55\":3,\"60\":3,\"61\":2,\"62\":1}}],[\"===\",{\"1\":{\"22\":3,\"23\":1,\"24\":1,\"25\":2,\"30\":1,\"31\":2,\"32\":2,\"33\":2,\"34\":5,\"35\":2,\"42\":2,\"44\":3,\"55\":5,\"60\":4}}],[\"==\",{\"1\":{\"8\":2,\"22\":2,\"44\":2,\"60\":1}}],[\"=>\",{\"1\":{\"8\":4,\"10\":7,\"17\":1,\"24\":5,\"25\":3,\"35\":1,\"61\":3,\"62\":1}}],[\"=\",{\"1\":{\"8\":17,\"10\":2,\"17\":4,\"21\":4,\"22\":3,\"23\":1,\"24\":13,\"25\":3,\"30\":8,\"31\":6,\"32\":8,\"33\":12,\"34\":16,\"35\":7,\"40\":1,\"42\":13,\"44\":7,\"55\":28,\"60\":6,\"61\":10,\"62\":8}}],[\"用一个\",{\"1\":{\"61\":1}}],[\"用于缓存字符\",{\"1\":{\"55\":1}}],[\"用于判断是否是字母\",{\"1\":{\"55\":1}}],[\"用于移动到哪\",{\"1\":{\"33\":1}}],[\"用来将一个任务添加到缓冲队列中\",{\"1\":{\"61\":1}}],[\"用来监听是否有改变\",{\"1\":{\"61\":1}}],[\"用来返回该组件所对应的vnode\",{\"1\":{\"60\":1}}],[\"用来存储寻找过程中遇到的最大索引值\",{\"1\":{\"32\":1}}],[\"用来对元素属性打补丁的函数\",{\"1\":{\"23\":1}}],[\"用来记录真实dom\",{\"1\":{\"21\":1}}],[\"用来整合这些定义\",{\"1\":{\"20\":1}}],[\"用作标识\",{\"1\":{\"8\":1}}],[\"用的时候再拿出来\",{\"1\":{\"8\":1}}],[\"用了些什么控制代码规范\",{\"1\":{\"5\":1}}],[\"反之进行循环遍历数组进行patch子节点\",{\"1\":{\"28\":1}}],[\"反之调用patchelement方法\",{\"1\":{\"28\":1}}],[\"反之则需要移动\",{\"1\":{\"43\":1}}],[\"反之则循环挂载newvnode\",{\"1\":{\"28\":1}}],[\"反之则调用processcomponent方法\",{\"1\":{\"28\":1}}],[\"反之则进行patch操作\",{\"1\":{\"28\":1}}],[\"反之则是oldvnode和newvnode通过patch方法比较打补丁进行渲染\",{\"1\":{\"17\":1}}],[\"反之如果是数组\",{\"1\":{\"19\":1}}],[\"反复的挂载和卸载会导致很多额外的开销\",{\"1\":{\"8\":1}}],[\"反问\",{\"0\":{\"6\":1}}],[\"width\",{\"1\":{\"51\":1}}],[\"width=device\",{\"1\":{\"51\":1}}],[\"while\",{\"1\":{\"40\":1,\"42\":3,\"55\":2}}],[\"websocket和http\",{\"1\":{\"8\":1}}],[\"watch\",{\"1\":{\"5\":1}}],[\"这种更新叫做被动更新\",{\"1\":{\"63\":1}}],[\"这种情况\",{\"1\":{\"39\":1}}],[\"这也就是父子传值的props\",{\"1\":{\"63\":1}}],[\"这之间所遇到的所有字符串都将成为标签名\",{\"1\":{\"55\":1}}],[\"这取决于具体的场景和实现\",{\"1\":{\"55\":1}}],[\"这是传统的客户端的渲染方式\",{\"1\":{\"51\":1}}],[\"这是可复用的节点\",{\"1\":{\"44\":1}}],[\"这表明该节点需要新增\",{\"1\":{\"44\":1}}],[\"这说明也还是可以复用\",{\"1\":{\"43\":1}}],[\"这明显又回到了原地\",{\"1\":{\"43\":1}}],[\"这段也一样\",{\"1\":{\"42\":1}}],[\"这时候需要将newstartindex到newendindex之间的所有结点挂载到头部\",{\"1\":{\"39\":1}}],[\"这时我们使用容器元素的\",{\"1\":{\"34\":1}}],[\"这就是没必要的开销\",{\"1\":{\"63\":1}}],[\"这就是双端diff算法\",{\"1\":{\"38\":1}}],[\"这就回到了如何移动这些可复用的dom元素上\",{\"1\":{\"43\":1}}],[\"这就避免了因为teleport组件造成的额外dom节点的创建\",{\"1\":{\"11\":1}}],[\"这些相同的dom是可以保留下面\",{\"1\":{\"31\":1}}],[\"这些内置组件的创建都跟渲染器有紧密联系\",{\"1\":{\"11\":1}}],[\"这个函数利用的算法是有限状态自动机\",{\"1\":{\"55\":1}}],[\"这个source数组可不一般\",{\"1\":{\"44\":1}}],[\"这个时候\",{\"1\":{\"31\":1,\"38\":1}}],[\"这个分支是default的执行\",{\"1\":{\"28\":1}}],[\"这章主要讲的是patchchildren函数\",{\"1\":{\"25\":1}}],[\"这里也可以说成添加一个对组件自身状态的副作用\",{\"1\":{\"61\":1}}],[\"这里只是查看\",{\"1\":{\"55\":1}}],[\"这里是挂载\",{\"1\":{\"44\":1}}],[\"这里暂不考虑没找到的情况\",{\"1\":{\"38\":1}}],[\"这里就是用来考虑该节点是否需要移动\",{\"1\":{\"32\":1}}],[\"这里需要\",{\"1\":{\"31\":1,\"32\":1}}],[\"这里需要做兼容处理\",{\"1\":{\"24\":1}}],[\"这里有text\",{\"1\":{\"28\":1}}],[\"这里有一个新知识\",{\"1\":{\"23\":1}}],[\"这里的新增节点和需要移除的节点跟双端那边类似\",{\"1\":{\"42\":1}}],[\"这里的移动是值移动真实dom\",{\"1\":{\"33\":1}}],[\"这里的\",{\"1\":{\"25\":1}}],[\"这三个点对挂载和卸载都有效\",{\"1\":{\"10\":1}}],[\"这样就讲这两个生命周期给分离了\",{\"1\":{\"62\":1}}],[\"这样就可以自动对任务进行去重\",{\"1\":{\"61\":1}}],[\"这样就可以知道在不在了\",{\"1\":{\"31\":1}}],[\"这样就方便处理了\",{\"1\":{\"23\":1}}],[\"这样就能使用长连接的http协议\",{\"1\":{\"8\":1}}],[\"这样\",{\"1\":{\"11\":1}}],[\"这样下次激活组件时就不会执行新的挂载动作了\",{\"1\":{\"8\":1}}],[\"这两个方式的本质区别就是对于谁负责解析模板\",{\"1\":{\"50\":1}}],[\"这两个函数会在渲染器中被调用\",{\"1\":{\"8\":1}}],[\"这两题都是子序列问题\",{\"1\":{\"2\":1}}],[\"author\",{\"1\":{\"66\":1}}],[\"a\",{\"1\":{\"55\":2}}],[\"ast\",{\"1\":{\"55\":1},\"2\":{\"48\":1,\"57\":1,\"65\":1}}],[\"attribute\",{\"1\":{\"63\":1}}],[\"attributes与dom\",{\"1\":{\"19\":1}}],[\"attributes\",{\"1\":{\"19\":3}}],[\"attrs\",{\"1\":{\"63\":1}}],[\"attached\",{\"1\":{\"24\":3}}],[\"algorithm\",{\"0\":{\"71\":1}}],[\"alert\",{\"1\":{\"24\":1}}],[\"alive\",{\"1\":{\"8\":1}}],[\"app<\",{\"1\":{\"51\":1}}],[\"app\",{\"1\":{\"17\":1,\"24\":1,\"42\":2,\"51\":4}}],[\"appendchild\",{\"1\":{\"10\":1}}],[\"addeventlistener\",{\"1\":{\"10\":2,\"23\":1,\"24\":1}}],[\"add\",{\"1\":{\"10\":7,\"61\":1}}],[\"actived和unactived我不清楚是否也能激活过渡效果\",{\"1\":{\"10\":1}}],[\"active\",{\"1\":{\"10\":5}}],[\"activate\",{\"1\":{\"8\":2}}],[\"anchor\",{\"1\":{\"8\":2,\"33\":6,\"34\":10,\"44\":2,\"60\":5,\"61\":2,\"62\":3}}],[\"array\",{\"1\":{\"5\":1,\"24\":1,\"25\":4,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1}}],[\"但应该将当前字符缓存到\",{\"1\":{\"55\":1}}],[\"但需要将当前字符缓存到\",{\"1\":{\"55\":2}}],[\"但仍然需要调用\",{\"1\":{\"31\":1}}],[\"但问题却是\",{\"1\":{\"30\":1}}],[\"但根据浏览器的不同\",{\"1\":{\"24\":1}}],[\"但实际上它们并没有被添加到任何额外的dom节点中\",{\"1\":{\"11\":1}}],[\"但是并不是所有的子组件都必须跟着父组件更新的\",{\"1\":{\"63\":1}}],[\"但是这中间这个过程需要先将模板语法编译成模板ast\",{\"1\":{\"55\":1}}],[\"但是这还有缺陷\",{\"1\":{\"39\":1}}],[\"但是由于这个html是什么都没有的\",{\"1\":{\"51\":1}}],[\"但是在这个阶段\",{\"1\":{\"51\":1}}],[\"但是对于子组件来说没有任何变化\",{\"1\":{\"63\":1}}],[\"但是对于newchildren的4\",{\"1\":{\"39\":1}}],[\"但是对于非理性状态\",{\"1\":{\"39\":1}}],[\"但是有时候会出现\",{\"1\":{\"38\":1}}],[\"但是实际上\",{\"1\":{\"38\":1}}],[\"但是中途有索引比当前状态下的最大索引要小\",{\"1\":{\"32\":1}}],[\"但是\",{\"1\":{\"31\":1,\"55\":1}}],[\"但是结果却是触发了\",{\"1\":{\"24\":1}}],[\"但是考虑到冒泡的事件何时开始与何时结束都是不可预料的\",{\"1\":{\"24\":1}}],[\"但是考虑到以下几点问题\",{\"1\":{\"21\":1}}],[\"但是考虑到性能问题\",{\"1\":{\"20\":1}}],[\"但是vue所采用的是vnode\",{\"1\":{\"19\":1}}],[\"但是子组件最终挂载的地方并不是当前父组件下面\",{\"1\":{\"9\":1}}],[\"但是还未理清\",{\"1\":{\"2\":1}}],[\"但在响应头里把connection字段的值设置成keep\",{\"1\":{\"8\":1}}],[\"连接\",{\"1\":{\"8\":1}}],[\"theme\",{\"1\":{\"66\":1}}],[\"then\",{\"1\":{\"61\":1}}],[\"this\",{\"1\":{\"5\":2}}],[\"tagendname\",{\"1\":{\"55\":3}}],[\"tagend\",{\"1\":{\"55\":4}}],[\"tagname\",{\"1\":{\"55\":3}}],[\"tagopen\",{\"1\":{\"55\":4}}],[\"tag\",{\"1\":{\"55\":3,\"67\":1}}],[\"target\",{\"1\":{\"11\":1}}],[\"title\",{\"1\":{\"67\":1}}],[\"title>\",{\"1\":{\"51\":1}}],[\"timestamp\",{\"1\":{\"24\":4}}],[\"tokens\",{\"1\":{\"55\":9}}],[\"tokenize\",{\"1\":{\"55\":1}}],[\"token\",{\"1\":{\"55\":5}}],[\"too\",{\"1\":{\"42\":1}}],[\"tolowercase\",{\"1\":{\"23\":1,\"24\":1}}],[\"to\",{\"1\":{\"10\":5}}],[\"to=\",{\"1\":{\"9\":1}}],[\"try\",{\"1\":{\"61\":1}}],[\"tree\",{\"1\":{\"15\":1}}],[\"transitionend\",{\"1\":{\"10\":2}}],[\"transition组件的实现原理\",{\"0\":{\"10\":1}}],[\"true\",{\"1\":{\"8\":6,\"20\":3,\"24\":1,\"34\":2,\"61\":2,\"62\":1}}],[\"template<\",{\"1\":{\"55\":1}}],[\"text2\",{\"1\":{\"42\":2}}],[\"text1\",{\"1\":{\"42\":2}}],[\"text\",{\"1\":{\"24\":1,\"25\":2,\"34\":1,\"55\":4,\"60\":1}}],[\"teleport组件的实现方式是使用了dom中的\",{\"1\":{\"11\":1}}],[\"teleport组件的实现原理\",{\"0\":{\"9\":1}}],[\"teleport组件可以避免渲染器的代码膨胀\",{\"1\":{\"11\":1}}],[\"teleport>\",{\"1\":{\"9\":1}}],[\"test\",{\"1\":{\"8\":2,\"23\":1,\"24\":1}}],[\"type是一个对象\",{\"1\":{\"60\":1}}],[\"type上\",{\"1\":{\"19\":1}}],[\"typeof\",{\"1\":{\"8\":2,\"22\":2,\"25\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":1,\"60\":2}}],[\"type\",{\"1\":{\"8\":6,\"17\":1,\"22\":10,\"24\":2,\"25\":4,\"34\":3,\"55\":8,\"60\":11,\"61\":1,\"62\":1}}],[\"tcp\",{\"1\":{\"8\":1}}],[\"push\",{\"1\":{\"55\":9}}],[\"pos\",{\"1\":{\"44\":3}}],[\"posts\",{\"0\":{\"72\":1}}],[\"post\",{\"1\":{\"44\":1}}],[\"p1\",{\"1\":{\"38\":1}}],[\"png\",{\"1\":{\"51\":1}}],[\"pn\",{\"1\":{\"38\":2}}],[\"press\",{\"1\":{\"66\":1}}],[\"prevvnode\",{\"1\":{\"33\":8,\"34\":6}}],[\"prevvalue\",{\"1\":{\"23\":1,\"24\":1}}],[\"promise\",{\"1\":{\"61\":2}}],[\"processelement函数\",{\"1\":{\"28\":1}}],[\"properties的初始值\",{\"1\":{\"19\":1}}],[\"properties的情况\",{\"1\":{\"19\":1}}],[\"properties不是直接映射\",{\"1\":{\"19\":1}}],[\"properties\",{\"1\":{\"19\":2}}],[\"props与组件的被动更新\",{\"0\":{\"63\":1}}],[\"props里\",{\"1\":{\"23\":1}}],[\"props下的class属性有以下三种定义\",{\"1\":{\"20\":1}}],[\"props等属性\",{\"1\":{\"17\":1}}],[\"props\",{\"1\":{\"8\":7,\"17\":1,\"24\":2,\"55\":1,\"63\":1}}],[\"proxy\",{\"1\":{\"5\":1}}],[\"parent\",{\"1\":{\"21\":6,\"33\":2}}],[\"parentnode\",{\"1\":{\"10\":1,\"21\":2}}],[\"patchcomponent\",{\"1\":{\"60\":1}}],[\"patchchildren函数\",{\"1\":{\"28\":1}}],[\"patchchildren\",{\"1\":{\"25\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1}}],[\"patchkeyedchildren\",{\"1\":{\"42\":1}}],[\"patch函数会采用不同的方案会进行渲染\",{\"1\":{\"60\":1}}],[\"patch函数\",{\"1\":{\"28\":1}}],[\"patch函数的作用是将新旧vnode进行对比\",{\"1\":{\"22\":1}}],[\"patchprops\",{\"1\":{\"23\":1,\"24\":1,\"25\":1}}],[\"patchprops函数\",{\"1\":{\"23\":1,\"28\":1}}],[\"patchelement函数\",{\"1\":{\"28\":1}}],[\"patchelement函数主要执行两个功能\",{\"1\":{\"25\":1}}],[\"patchelement\",{\"1\":{\"22\":2,\"34\":1}}],[\"patch\",{\"1\":{\"17\":1,\"21\":1,\"22\":3,\"25\":1,\"30\":2,\"31\":2,\"32\":1,\"33\":1,\"34\":4,\"42\":3,\"60\":3,\"61\":1,\"62\":2}}],[\"performance\",{\"1\":{\"24\":2}}],[\"performremove\",{\"1\":{\"10\":4}}],[\"persistent\",{\"1\":{\"8\":1}}],[\"p>\",{\"1\":{\"9\":1}}],[\"p\",{\"1\":{\"8\":1,\"24\":1,\"25\":1,\"38\":1,\"61\":2}}],[\"持久连接\",{\"1\":{\"8\":1}}],[\"一个标志\",{\"1\":{\"61\":1}}],[\"一个辅助函数\",{\"1\":{\"55\":1}}],[\"一旦找到可复用的节点\",{\"1\":{\"34\":1}}],[\"一般来讲第一次叫做挂载\",{\"1\":{\"17\":1}}],[\"一\",{\"0\":{\"8\":1,\"50\":1},\"1\":{\"61\":1}}],[\"听着都像自己理解的\",{\"1\":{\"6\":1}}],[\"影响大吗\",{\"1\":{\"6\":1}}],[\"要是八股没有太多答出来\",{\"1\":{\"6\":1}}],[\"面试官有点意外\",{\"1\":{\"6\":1}}],[\"面试官\",{\"1\":{\"6\":2}}],[\"我只需要去管理不同的部分\",{\"1\":{\"42\":1}}],[\"我新数组里有\",{\"1\":{\"39\":1}}],[\"我们可以设置一个监视器\",{\"1\":{\"61\":1}}],[\"我们实现了两个目标\",{\"1\":{\"44\":1}}],[\"我们完全不需要去处理它\",{\"1\":{\"42\":1}}],[\"我们需要先获取锚点元素\",{\"1\":{\"34\":1}}],[\"我们使用的是高精时间\",{\"1\":{\"24\":1}}],[\"我这些总结是一部分书上一部分源码上的\",{\"1\":{\"28\":1}}],[\"我的想法是\",{\"1\":{\"25\":1}}],[\"我看到这的时候第一想法是\",{\"1\":{\"24\":1}}],[\"我是一个vnodeobj\",{\"1\":{\"17\":1}}],[\"我是第一次面\",{\"1\":{\"6\":1}}],[\"我八股记得少\",{\"1\":{\"6\":1}}],[\"我\",{\"1\":{\"6\":2}}],[\"手写题\",{\"1\":{\"5\":1}}],[\"函数来挂载组件所描述的内容\",{\"1\":{\"60\":1}}],[\"函数返回的虚拟\",{\"1\":{\"60\":1}}],[\"函数返回函数\",{\"1\":{\"5\":1}}],[\"函数进行更新\",{\"1\":{\"42\":1}}],[\"函数需要增加第三个参数\",{\"1\":{\"34\":1}}],[\"函数需要接收第四个参数\",{\"1\":{\"34\":1}}],[\"函数更新\",{\"1\":{\"31\":1}}],[\"函数名都能从源码里找到的\",{\"1\":{\"28\":1}}],[\"函数\",{\"1\":{\"28\":1,\"34\":2}}],[\"函数将其卸载\",{\"1\":{\"35\":1}}],[\"函数将\",{\"1\":{\"10\":1}}],[\"函数中\",{\"1\":{\"10\":1}}],[\"函数用来将一段\",{\"1\":{\"8\":1}}],[\"函数和箭头函数区别\",{\"1\":{\"5\":1}}],[\"什么是高阶函数\",{\"1\":{\"5\":1}}],[\"做了哪些优化\",{\"1\":{\"5\":1}}],[\"v\",{\"1\":{\"55\":3}}],[\"viewport\",{\"1\":{\"51\":1}}],[\"vite\",{\"1\":{\"5\":1}}],[\"vei\",{\"1\":{\"24\":3}}],[\"vei设置为一个对象\",{\"1\":{\"23\":1}}],[\"value的数据结构\",{\"1\":{\"23\":1}}],[\"value的值即可\",{\"1\":{\"23\":1}}],[\"value里面\",{\"1\":{\"23\":1}}],[\"value++\",{\"1\":{\"17\":1}}],[\"value\",{\"1\":{\"8\":1,\"17\":1,\"24\":7}}],[\"vnode是oldvnode\",{\"1\":{\"21\":1}}],[\"vnode是一个object\",{\"1\":{\"17\":1}}],[\"vnode\",{\"1\":{\"8\":11,\"17\":6,\"19\":1,\"21\":13,\"22\":6,\"24\":4,\"25\":5,\"33\":2,\"34\":4,\"35\":2,\"60\":5,\"61\":2,\"62\":3},\"2\":{\"48\":1}}],[\"vue源码\",{\"0\":{\"73\":1}}],[\"vuejs\",{\"1\":{\"66\":1}}],[\"vue编译出来的这种语言叫做dsl\",{\"1\":{\"55\":1}}],[\"vue框架提供了两种渲染模式\",{\"1\":{\"50\":1}}],[\"vuereactivity\",{\"1\":{\"24\":1}}],[\"vue设计与实现第十二章\",{\"0\":{\"46\":1}}],[\"vue设计与实现第十一章\",{\"0\":{\"41\":1}}],[\"vue设计与实现第十章\",{\"0\":{\"37\":1}}],[\"vue设计与实现第九章\",{\"0\":{\"29\":1}}],[\"vue设计与实现第八章\",{\"0\":{\"18\":1}}],[\"vue设计与实现第七章\",{\"0\":{\"17\":1}}],[\"vue\",{\"1\":{\"15\":1,\"42\":1},\"2\":{\"13\":1,\"48\":1,\"53\":1,\"57\":1,\"65\":1}}],[\"vue3\",{\"1\":{\"5\":1}}],[\"vue2\",{\"1\":{\"5\":1}}],[\"的真实dom移动到newchildren\",{\"1\":{\"38\":1}}],[\"的索引\",{\"1\":{\"38\":1}}],[\"的下一个兄弟节点\",{\"1\":{\"33\":1}}],[\"的前一个\",{\"1\":{\"33\":1,\"34\":1}}],[\"的后面\",{\"1\":{\"33\":2}}],[\"的时候\",{\"1\":{\"25\":1}}],[\"的值是选项对象\",{\"1\":{\"60\":1}}],[\"的值是字符串类型\",{\"1\":{\"22\":1}}],[\"的值设为\",{\"1\":{\"34\":1}}],[\"的值\",{\"1\":{\"32\":1}}],[\"的值为字符串\",{\"1\":{\"25\":1}}],[\"的值为\",{\"1\":{\"25\":1,\"44\":1}}],[\"的值都是高精时间\",{\"1\":{\"24\":1}}],[\"的值也会有所不同\",{\"1\":{\"24\":1}}],[\"的值的类型是对象\",{\"1\":{\"22\":1}}],[\"的类型不同\",{\"1\":{\"22\":1}}],[\"的类型\",{\"1\":{\"22\":1}}],[\"的父元素\",{\"1\":{\"21\":1}}],[\"的组件\",{\"1\":{\"8\":1}}],[\"的默认插槽就是要被\",{\"1\":{\"8\":1}}],[\"的\",{\"1\":{\"5\":1,\"8\":1,\"10\":1,\"44\":1,\"61\":1,\"63\":1}}],[\"的响应式区别\",{\"1\":{\"5\":1}}],[\"微宏任务队列\",{\"1\":{\"5\":1}}],[\"没有消费该字符\",{\"1\":{\"55\":1}}],[\"没有在旧的一组子节点中找到可复用的节点\",{\"1\":{\"34\":1}}],[\"没有子节点\",{\"1\":{\"25\":2}}],[\"没背八股\",{\"1\":{\"5\":1}}],[\"没答好\",{\"1\":{\"5\":2}}],[\"和函数提升\",{\"1\":{\"5\":1}}],[\"和\",{\"1\":{\"5\":2,\"8\":1,\"10\":1,\"22\":2,\"42\":1}}],[\"原型和原型链\",{\"1\":{\"5\":1}}],[\"滴滴一面\",{\"0\":{\"5\":1}}],[\"动态规划\",{\"2\":{\"4\":1}}],[\"算法的设计如下\",{\"1\":{\"44\":1}}],[\"算法的设计是建立一个source数组\",{\"1\":{\"43\":1}}],[\"算法的成本很大\",{\"1\":{\"30\":1}}],[\"算法\",{\"1\":{\"25\":1},\"2\":{\"3\":1,\"56\":1}}],[\"题目类似\",{\"1\":{\"2\":1}}],[\"博主简介\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
