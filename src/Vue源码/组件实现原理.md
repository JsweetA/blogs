---
title: 组件实现原理
description:  关于Vue3源码里组件的实现方式以及组件
category:
  - 源码
tag:
  - Vue
  - AST
 
star: true
---
<a name="z7N5A"></a>
##### 1.引言
先聊聊什么是组件，组件的用法有两个用途

- 拆分页面，让页面功能单一，不需要去管理庞大的页面模板。每个组件有自己职责，出事找对应组件即可。
- 复用，就跟抽离函数一样，页面有很多东西有时候也是可以复用的，所以将一些重复的或者会经常用到的抽离出来。
<a name="xhkMT"></a>
##### 2.组件的渲染
对于不同的`vnode`，`patch`函数会采用不同的方案会进行渲染。组件也不例外，在`vnode`的层次上，组件的`vnode.type`是一个对象，毕竟他也不是任何一个标签。
```javascript
01 function patch(n1, n2, container, anchor) {
02   if (n1 && n1.type !== n2.type) {
03     unmount(n1)
04     n1 = null
05   }
06
07   const { type } = n2
08
09   if (typeof type === 'string') {
10     // 作为普通元素处理
11   } else if (type === Text) {
12     // 作为文本节点处理
13   } else if (type === Fragment) {
14     // 作为片段处理
15   } else if (typeof type === 'object') {
16     // vnode.type 的值是选项对象，作为组件来处理
17     if (!n1) {
18       // 挂载组件
19       mountComponent(n2, container, anchor)
20     } else {
21       // 更新组件
22       patchComponent(n1, n2, anchor)
23     }
24   }
25 }
```
对于这个对象里，他应该有一个`render`函数，用来返回该组件所对应的`vnode`。格式如下：
```javascript
01 const MyComponent = {
02   // 组件名称，可选
03   name: 'MyComponent',
04   // 组件的渲染函数，其返回值必须为虚拟 DOM
05   render() {
06     // 返回虚拟 DOM
07     return {
08       type: 'div',
09       children: `我是文本内容`
10     }
11   }
12 }
// 挂载函数
01 function mountComponent(vnode, container, anchor) {
02   // 通过 vnode 获取组件的选项对象，即 vnode.type
03   const componentOptions = vnode.type
04   // 获取组件的渲染函数 render
05   const { render } = componentOptions
06   // 执行渲染函数，获取组件要渲染的内容，即 render 函数返回的虚拟 DOM
07   const subTree = render()
08   // 最后调用 patch 函数来挂载组件所描述的内容，即 subTree
09   patch(null, subTree, container, anchor)
10 }
```
通过`render`所提供的`vnode`就可以将该组件渲染出来了。
<a name="UvkDE"></a>
##### 3.组件状态与自更新
对于响应式变量来说，如果跟页面双向绑定了。那变量的值改变的时候，页面应该需要重新渲染。而这些导致页面会重新渲染的变量，就叫做组件自身的状态。<br />所以基于组件自身的状态，我们可以设置一个监视器，用来监听是否有改变，如果改变，即重新渲染。
> 不管是effect还是watch，都是利用副作用，而watch又是对effect的扩展，所以我干脆用监视器来描述。这里也可以说成添加一个对组件自身状态的副作用，功能是重新渲染

```javascript
01 function mountComponent(vnode, container, anchor) {
02   const componentOptions = vnode.type
03   const { render, data } = componentOptions
04
05   const state = reactive(data())
06
07   effect(() => {
08     const subTree = render.call(state, state)
09     patch(null, subTree, container, anchor)
10   }, {
11     // 指定该副作用函数的调度器为 queueJob 即可
12     scheduler: queueJob
13   })
14 }
```
以上代码有两个缺陷，<br />一，状态反复修改，页面会反复渲染<br />二，每次都是`patch(null,subTree)`都是重新挂载<br />两个问题都会导致性能上产生不必要的开销。对于问题二，后期改成新旧组件比较即可解决。而问题一，个人见解是做一个防抖，书上是做了一个任务调度器`queueJob`，利用`set`收集响应函数，自动去重。
```javascript
01 // 任务缓存队列，用一个 Set 数据结构来表示，这样就可以自动对任务进行去重
02 const queue = new Set()
03 // 一个标志，代表是否正在刷新任务队列
04 let isFlushing = false
05 // 创建一个立即 resolve 的 Promise 实例
06 const p = Promise.resolve()
07
08 // 调度器的主要函数，用来将一个任务添加到缓冲队列中，并开始刷新队列
09 function queueJob(job) {
10   // 将 job 添加到任务队列 queue 中
11   queue.add(job)
12   // 如果还没有开始刷新队列，则刷新之
13   if (!isFlushing) {
14     // 将该标志设置为 true 以避免重复刷新
15     isFlushing = true
16     // 在微任务中刷新缓冲队列
17     p.then(() => {
18       try {
19         // 执行任务队列中的任务
20         queue.forEach(job => job())
21       } finally {
22         // 重置状态
23         isFlushing = false
24         queue.clear = 0
25       }
26     })
27   }
28 }
```
<a name="pspEQ"></a>
##### 4.组件的实例与组件的生命周期
基于上面的方案，对于组件的挂载，组件的销毁，组件的更新其实都表达的很明显了，而且对于上面的问题二，就是利用变量存储旧组件，然后通过判断是否有旧组件来进行决策执行`mounted`还是`update`，这样就讲这两个生命周期给分离了。<br />对于`create`生命周期是在组件状态设置好之前就调用的，所以他的位置也很清晰。
```javascript
01 function mountComponent(vnode, container, anchor) {
02   const componentOptions = vnode.type
03   // 从组件选项对象中取得组件的生命周期函数
04   const { render, data, beforeCreate, created, beforeMount, mounted, beforeUpdate, updated } = componentOptions
05
06   // 在这里调用 beforeCreate 钩子
07   beforeCreate && beforeCreate()
08
09   const state = reactive(data())
10
11   const instance = {
12     state,
13     isMounted: false,
14     subTree: null
15   }
16   vnode.component = instance
17
18   // 在这里调用 created 钩子
19   created && created.call(state)
20
21   effect(() => {
22     const subTree = render.call(state, state)
23     if (!instance.isMounted) {
24       // 在这里调用 beforeMount 钩子
25       beforeMount && beforeMount.call(state)
26       patch(null, subTree, container, anchor)
27       instance.isMounted = true
28       // 在这里调用 mounted 钩子
29       mounted && mounted.call(state)
30     } else {
31       // 在这里调用 beforeUpdate 钩子
32       beforeUpdate && beforeUpdate.call(state)
33       patch(instance.subTree, subTree, container, anchor)
34       // 在这里调用 updated 钩子
35       updated && updated.call(state)
36     }
37     instance.subTree = subTree
38   }, { scheduler: queueJob })
39 }
```
<a name="iNbax"></a>
##### 5.props与组件的被动更新
先理清组件的props有哪些？

- 给组件的`props`：这也就是父子传值的`props`
- 组件自身的`props`：`class`，`style`

第一个就是定义组件时的`props`，也就是通过`defineProps`内定义的内容，第二个更像是标签的属性。所以`vue`会通过`resolveProps`方法将两个`props`进行合并，并且提炼出`attrs`。
> attrs：指的是传递给一个组件，却没有被该组件声明为 [props](https://cn.vuejs.org/guide/components/props.html) 或 [emits](https://cn.vuejs.org/guide/components/events.html#defining-custom-events) 的 attribute。

有了`props`就可以来检测是否需要更新子组件了。当父组件的`props`数据发生变化的时候，会触发父组件的重新渲染，此时渲染函数也会去更新子组件。这种更新叫做被动更新。<br />但是并不是所有的子组件都必须跟着父组件更新的，有时候只是父组件的状态有变化，但是对于子组件来说没有任何变化，此时子组件被动更新的话，这就是没必要的开销。
> 代码检测props是否改变的通过调用hasPropsChanged方法。


