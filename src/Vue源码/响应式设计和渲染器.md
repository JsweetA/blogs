---
title: 响应式设计和渲染器设计
description: 针对Vue3源码里响应式的设计方法和渲染器的设计。
category:
  - 源码
tag:
  - Vue
  - VNode
  - AST
star: true
---

## 响应式设计

[https://github.com/JsweetA/vue-sourceCode-study/tree/reactive/reactiveBasis](https://github.com/JsweetA/vue-sourceCode-study/tree/reactive/reactiveBasis)

> 详细请看仓库源码注释

## 渲染器设计

渲染器和响应式结合：就可以达到那种数据跟页面同步的效果

---

<a name="NfSj6"></a>

##### vue设计与实现第七章：渲染器的设计

渲染函数：`renderer(vnode,container)`

- vnode:虚拟节点
- container：容器

```javascript
const count = ref(1)
effect(() => {
  renderer(`<h1>${count.value}</h1>`, document.getElementById('app'))
})
count.value++
```

> 如果该节点什么都没有，属于第一次，则它叫做挂在（mount）,反之则是oldVnode和newVnode通过patch方法比较打补丁进行渲染（也就是diff）

而渲染器则是由`createRenderer`所创建，以下是调用该函数的返回值：

- `render`：渲染器
- `hydrate`：服务器的渲染器
- （还有一个，忘记了）

> 其实不管是第一次渲染还是第二次渲染，其实都可以叫做打补丁，一般来讲第一次叫做挂载，其他叫做打补丁，毕竟渲染器的主要工作就是挂载、更新和渲染。

_render：_

1. _if vnode is exist_
   1. _patch(oldVnode,vnode,container)_
2. _else _
   1. _if oldVnode is exist_
   2. _oldVnode = null_
3. _oldVnode = vnode_

> 其中第二步是指新的不存在，而旧的存在的话，应该执行unmount操作。

vnode是一个object，其中有`type`，`children`，`props`等属性，而`render`可以将这种`vnode`转换成真实dom，简单的这种操作就可以通过封装一个方法去调用api进行创建和挂载。<br />不过考虑到耦合性，为了使这种模板可以在不同环境下运行，所以这种调用api的东西，挂在的东西都是外部传进这个`createRenderer`函数里的。

```javascript
vnode = {
	type:'h1',
  props:{
    ...
  },
  children:'我是一个vnodeObj'
  // children:[
  //   {...},
  //]
  // 对象数组，里面存放的是vnode
}
// 转换后应该是<h1>我是一个vnodeObj</h1>
```

总之，渲染器的作用就是将vnode渲染成真实dom，通过不断地patch

---

<a name="dxqXL"></a>

##### vue设计与实现第八章：挂载与更新

<a name="INv7B"></a>

###### 8.1-8.3：挂在子节点和元素属性和正确的设置元素属性

`mountElement`函数

- vnode
- container

它会去判断`vnode.children`属性是否是`string`,是的话就直接挂在文本内容，反之如果是数组，则进行将数组内的内容全部挂在到`vnode.type`上，然后最后插入到`container`。<br />添加`el`的属性有两种方式：

- `HTML Attributes`
- `DOM Properties`

问题：`attributes`与`DOM Properties`不是直接映射,存在一个`HTML Attributes` 会关联多个`DOM Properties`的情况。

> 来自书里所讲：“只需要记住一个原则：`HTML Attributes` 是 设置与之对应的`DOM Properties`的初始值”

所以要正确的设置元素属性，需要看情况来进行判断赋值

> 浏览器会自动解析HTMl代码，自动分析并且设置`DOM Properties`，但是Vue所采用的是vnode，所以需要自己去把这个活接过来。

<a name="BbbQ0"></a>

###### 8.4：class的处理

`props`下的`class`属性有以下三种定义：

- `class="bar foo"`
- `:class='{foo:true,bar:true}'`
- `:class='['bar',{foo:true}]'`

处理该属性有一个`normalizeClass`函数，用来整合这些定义，全部转换为字符串的格式<br />设置该属性有`el.className`,`setAttribute`,`el.classList`三种方法，但是考虑到性能问题，所以用的是`el.className`。于是就是接着在`patchProps`函数上打补丁

> 同理，`style`属性也需要这种整合函数进行字符串化进行设置

<a name="OfDLN"></a>

###### 8.5：卸载操作

首次渲染后，后期渲染的`vnode`如果传的是`null`说明要执行卸载操作,但是考虑到以下几点问题

- 容器可能是由多个组件渲染，卸载时应该调用这些组件的`unmounted`，`beforeUnmounted`生命周期函数
- 有些元素存在自定义指令，卸载时应该要正确执行对应的指令钩子
- 如果直接使用`innerHtml`去清空的话，他不会移除那些绑定在`DOM`元素上的钩子

所以考虑到以上三点，卸载操作，应该是通过`vnode`获取到真实`DOM`,然后通过`DOM`的原生方法进行移除。在`vnode`对象上创建一个`el`属性，用来记录真实`DOM`。

```javascript
01 function render(vnode, container) {
02   if (vnode) {
03     patch(container._vnode, vnode, container)
04   } else {
05     if (container._vnode) {
06       // 根据 vnode 获取要卸载的真实 DOM 元素
07       const el = container._vnode.el
08       // 获取 el 的父元素
09       const parent = el.parentNode
10       // 调用 removeChild 移除元素
11       if (parent) parent.removeChild(el)
12     }
13   }
14   container._vnode = vnode
15 }
16 // container._vnode是oldVnode
```

然后考虑到该操作会很频繁页很常见，所以封装成`unmount`函数。

```javascript
01 function unmount(vnode) {
02   const parent = vnode.el.parentNode
03   if (parent) {
04     parent.removeChild(vnode.el)
05   }
06 }
07 // 上面就只需要进行调用unmount(container._vnode) 
```

> 此时还有一个好处就是，他独立出去了，unmount和beforeunmounted生命周期就出现了，还可以进行检测该东东是否是组件了，是组件就可以调用前面所说的生命周期函数

<a name="MXrmX"></a>

###### 8.6：区分vnode的类型

先梳理一下执行流程

1. 通过`createRenderer`函数创建一个`renderer`
2. 通过调用`renderer.render`方法将`vnode`挂载到`container`上
3. 此时的`render`函数会进行判断
   1. _if vnode is null_ ：`unmount(container._vnode)`
   2. _else vnode not is null_ : `patch(oldVnode,newVnode,container)`
4. 走到这里一定是进行`patch`了的，又会进行判断
   1. _if oldVnode is null :_`mountElement(newVnode,contaienr)`
   2. _else oldVnode not is ：_`patchElement(oldVnode,newVnode)`

`patch`函数的作用是将新旧`vnode`进行对比，然后把不同的地方进行替换，再渲染成真实`DOM`，不过考虑到所传进来的`vnode`并不是同一种类型，此时所作的操作应该时先卸载`oldVnode`,再挂载`newVnode`。

```javascript
01 function patch(n1, n2, container) {
02   // 如果 n1 存在，则对比 n1 和 n2 的类型
03   if (n1 && n1.type !== n2.type) {
04     // 如果新旧 vnode 的类型不同，则直接将旧 vnode 卸载
05     unmount(n1)
06     n1 = null
07   }
08
09   if (!n1) {
10     mountElement(n2, container)
11   } else {
12     // 更新
13   }
14 }
```

而且除了类型上，其实不同的标签应该有不同的处理方式，所以还需要进一步的判断。

```javascript
01 function patch(n1, n2, container) {
02   if (n1 && n1.type !== n2.type) {
03     unmount(n1)
04     n1 = null
05   }
06   // 代码运行到这里，证明 n1 和 n2 所描述的内容相同
07   const { type } = n2
08   // 如果 n2.type 的值是字符串类型，则它描述的是普通标签元素
09   if (typeof type === 'string') {
10     if (!n1) {
11       mountElement(n2, container)
12     } else {
13       patchElement(n1, n2)
14     }
15   } else if (typeof type === 'object') {
16     // 如果 n2.type 的值的类型是对象，则它描述的是组件
17   } else if (type === 'xxx') {
18     // 处理其他类型的 vnode
19   }
20 }
```

<a name="T3Vs4"></a>

###### 8.7：事件的处理

`patchProps`函数：用来对元素属性打补丁的函数。<br />是通过`createRenderer`内所传的`options`带来的。

```javascript
01 patchProps(el, key, prevValue, nextValue) {
02   // 匹配以 on 开头的属性，视其为事件
03   if (/^on/.test(key)) {
04     // 根据属性名称得到对应的事件名称，例如 onClick ---> click
05     const name = key.slice(2).toLowerCase()
06     // 绑定事件，nextValue 为事件处理函数
07     el.addEventListener(name, nextValue)
08   } else if (key === 'class') {
09     // 省略部分代码
10   } else if (shouldSetAsProps(el, key, nextValue)) {
11     // 省略部分代码
12   } else {
13     // 省略部分代码
14   }
15 }
```

事件这个也算`vnode.props`里，为了更明确的知道属性里哪个是事件，就统一安排`on`为前缀，这样就方便处理了。<br />通过调用`addEventListener`绑定事件，更新跟更新`vnode`一样，先卸载，在挂载。

> 性能优化：创建应该invoker,并且将函数缓存在invoker.value里面，然后调用的时候就调用这个，更新的时候覆盖invoker.value的值即可，就避免了一次remove的操作

优化过性能后存在一个问题：缓存只缓存了一个，出现多个事件会进行覆盖。<br />解决：将`el._vei`设置为一个对象 `key->func`。

>  这里有一个新知识，之前看过一个问题，js中的object底层是什么，其实我第一想法是key-value的数据结构，然后我去问chatgpt，他说HashMap（确实嗷）
>  后面还有需求是一个事件可以绑定多个函数，emmm这种补丁加个判断就好了

<a name="Hg9B4"></a>

###### 8.8：事件冒泡与更新时机问题

问题代码示例：

```javascript
01 const { effect, ref } = VueReactivity
02
03 const bol = ref(false)
04
05 effect(() => {
06   // 创建 vnode
07   const vnode = {
08     type: 'div',
09     props: bol.value ? {
10       onClick: () => {
11         alert('父元素 clicked')
12       }
13     } : {},
14     children: [
15       {
16         type: 'p',
17         props: {
18           onClick: () => {
19             bol.value = true
20           }
21         },
22         children: 'text'
23       }
24     ]
25   }
26   // 渲染 vnode
27   renderer.render(vnode, document.querySelector('#app'))
28 })
```

此时点击`p`会触发他的点击事件，由于绑定了一个`ref`变量，父元素`div`的分支应该是处于`{}`,就算事件冒泡，也不需要进行触发点击事件。但是结果却是触发了，看下图：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27119990/1679638067368-def3acdd-bdcb-4a94-9e46-6a40bdef7fd5.png#averageHue=%23d8d8d8&clientId=u8ad3f223-1d49-4&from=paste&height=446&id=u74f5d236&originHeight=1020&originWidth=1034&originalType=binary&ratio=1&rotation=0&showTitle=false&size=192021&status=done&style=none&taskId=u6b87793b-1ccf-46dc-9aab-6204ea877ff&title=&width=452)<br />在点击后，他修改了`ref`变量，于是执行了副作用函数，进行重新渲染，提前改变了使得`div`的点击事件进行了分支切换，并且绑定到了`div`上，所以会触发`div`的点击事件。<br />解决方案：判断绑定事件的时间是否小于触发事件即可。

> 我看到这的时候第一想法是，将渲染往后推，冒泡往前走，但是考虑到冒泡的事件何时开始与何时结束都是不可预料的，所以行不通

```javascript
01 patchProps(el, key, prevValue, nextValue) {
02   if (/^on/.test(key)) {
03     const invokers = el._vei || (el._vei = {})
04     let invoker = invokers[key]
05     const name = key.slice(2).toLowerCase()
06     if (nextValue) {
07       if (!invoker) {
08         invoker = el._vei[key] = (e) => {
09           // e.timeStamp 是事件发生的时间
10           // 如果事件发生的时间早于事件处理函数绑定的时间，则不执行事件处理函数
11           if (e.timeStamp < invoker.attached) return
12           if (Array.isArray(invoker.value)) {
13             invoker.value.forEach(fn => fn(e))
14           } else {
15             invoker.value(e)
16           }
17         }
18         invoker.value = nextValue
19         // 添加 invoker.attached 属性，存储事件处理函数被绑定的时间
20         invoker.attached = performance.now()
21         el.addEventListener(name, invoker)
22       } else {
23         invoker.value = nextValue
24       }
25     } else if (invoker) {
26       el.removeEventListener(name, invoker)
27     }
28   } else if (key === 'class') {
29     // 省略部分代码
30   } else if (shouldSetAsProps(el, key, nextValue)) {
31     // 省略部分代码
32   } else {
33     // 省略部分代码
34   }
35 }
```

> 来自书中的补充：
> “在关于时间的存储和比较方面，我们使用的是高精时间，即 performance.now。但根据浏览器的不同，e.timeStamp 的值也会有所不同。它既可能是高精时间，也可能是非高精时间。因此，严格来讲，这里需要做兼容处理。不过在 Chrome 49、Firefox 54、Opera 36 以及之后的版本中，e.timeStamp 的值都是高精时间。”

<a name="u1Lij"></a>

###### 8.9：更新子节点

子元素的状态：

- 没有子节点，此时 vnode.children 的值为 null。
- 具有文本子节点，此时 vnode.children 的值为字符串，代表文本的内容。
- 其他情况，无论是单个元素子节点，还是多个子节点（可能是文本和元素的混合），都可以用数组来表示。

```javascript
01 // 没有子节点
02 vnode = {
03   type: 'div',
04   children: null
05 }
06 // 文本子节点
07 vnode = {
08   type: 'div',
09   children: 'Some Text'
10 }
11 // 其他情况，子节点使用数组表示
12 vnode = {
13   type: 'div',
14   children: [
15     { type: 'p' },
16     'Some Text'
17   ]
18 }
```

`patchElement`函数主要执行两个功能

- `patchProps`
- `patchChildren`

这章主要讲的是`patchChildren`函数。

> 对于更新children，我的想法是，卸载原有的，安装新的。不过为了使这个方法更加强大，所以需要做一些判断

```javascript
01 function patchChildren(n1, n2, container) {
02   if (typeof n2.children === 'string') {
03     if (Array.isArray(n1.children)) {
04       n1.children.forEach((c) => unmount(c))
05     }
06     setElementText(container, n2.children)
07   } else if (Array.isArray(n2.children)) {
08     if (Array.isArray(n1.children)) {
09       // diff
10     } else {
11       setElementText(container, '')
12       n2.children.forEach(c => patch(null, c, container))
13     }
14   } else {
15     // 代码运行到这里，说明新子节点不存在
16     // 旧子节点是一组子节点，只需逐个卸载即可
17     if (Array.isArray(n1.children)) {
18       n1.children.forEach(c => unmount(c))
19     } else if (typeof n1.children === 'string') {
20       // 旧子节点是文本子节点，清空内容即可
21       setElementText(container, '')
22     }
23     // 如果也没有旧子节点，那么什么都不需要做
24   }
25 }
```

代码如上，分析如下：

1. _判断_`_newVnode_`_是否是_`_string_`
   1. _如果是，则判断_`_oldVnode_`_是否是数组_
      1. _如果是就逐个卸载，并且挂在文本_
   2. _不是数组就不需要管，直接挂载文本_
2. _当不是_`_string_`_的时候，判断_`_newVnode_`_是否是数组_
   1. _如果是，则判断_`_oldVnode_`_是否是数组_
      1. `_Diff_`_算法_
   2. _卸载文本，再挂载数组_
3. _既不是_`_string_`_,也不是数组，这里的_`_newVnode_`_就一定时空了_
   1. _重复如第一步的操作一样，只需要把后面挂载文本改成挂在_`_''_`
      <a name="OqUF5"></a>

###### 8.10：文本注释和注释节点

...
<a name="VeleT"></a>

###### 8.11：Fragment

名为片段，作用是解决了vue2不支持多根节点模板的问题。


<a name="dwKG1"></a>

###### 8.12：总结

章节总结自己翻书。

---

1.`render`函数：

1. 首先调用`render`函数，传递`vnode`，`container`两个参数
   1. 进入`render`函数后会进行判断`vnode`是否是`null`
      1. 是`null`则进行`unmount`的操作
      2. 反之则进行`patch`操作，进行对`oldVnode`和`newVnode`比较

---

2.`patch`函数：

1. 进入`patch`函数后判断新旧`vnode`的类型是否一样，不是一样就先卸载`oldVnode`
2. 取出`newVnode`的类型，这里有`Text`，`Comment`，`Fragment`，`Static`，`default`
   1. 如果是前四种类型的节点，则会调用对应的`process`方法进行挂载到`container`上
   2. 这个分支是`default`的执行，会判断节点是组件还是节点，如果是节点则调用`processElement`方法，反之则调用`processComponent`方法

---

3.`processElement`函数：

1. 判断`oldVnode`是否是空，是空的话则调用`mountElement`方法
2. 反之调用`patchElement`方法

---

4.`mountElement`函数：

1. 因为是第一次挂载，进行创建`DOM el`
2. 然后判断`children`类型是`string`还是`array`
   1. 是`string`则进行挂载文本
   2. 反之进行循环遍历数组进行`patch`子节点	
3. 调用`patchProps`函数添加属性

---

5.`patchProps`函数：

1. 对于`class`，`style`，`event`都是特殊属性，需要做特殊处理，调用对应的`patch-`函数
2. 除了以上三个，就是属性了，根据属性自身特性进行对应挂载。
3. 还有`vue`的指令挂载

---

5.`patchElement`函数：

1. 更新`props`通过调用`patchProps`方法
2. 更新`children`通过调用`patchChildren`

> 源码里面其实还做了其他的操作，而且patch，应该接着patch指令，我这些总结是一部分书上一部分源码上的，函数名都能从源码里找到的


---

6.`patchChildren`函数：

1. 判断`newVnode.children`是不是`string`
   1. 判断`oldVnode.children`是不是`array`是的话就循环卸载`oldVnode.children`
2. 判断`newVnode.children`是不是`array`
   1. 判断`oldVnode.children`是不是`array`,如果是就进行`diff`算法，反之则循环挂载`newVnode.children`
3. 既不是`string`也不是`array`,那只能是`null`
   1. 卸载`oldVnode`
      <a name="SyGDk"></a>

##### vue设计与实现第九章：简单Diff算法

<a name="x9aMU"></a>

###### 9.1：减少DOM操作的性能开销

旧的`patchChildren`在处理新旧`vnode`都是`array`时，是先全部卸载`oldVnode`,再挂载`newVnode`，算法的成本很大。有时候有一些节点，单纯可能只是文本值改变了，并不需要卸载和挂载操作，只需要更新文本值即可。于是`diff`算法就是来解决这个问题的。<br />方案一：逐个比较新旧`vnode.children`，解决了`DOM`的开销，但问题却是，如果新旧`vnode`的个数不一样，所以需要考虑新旧`vnode.children`的长度，旧的多了应该卸载，新的多了应该挂载，不能只是单纯的更新。

```javascript
01 function patchChildren(n1, n2, container) {
02   if (typeof n2.children === 'string') {
03     // 省略部分代码
04   } else if (Array.isArray(n2.children)) {
05     const oldChildren = n1.children
06     const newChildren = n2.children
07     // 旧的一组子节点的长度
08     const oldLen = oldChildren.length
09     // 新的一组子节点的长度
10     const newLen = newChildren.length
11     // 两组子节点的公共长度，即两者中较短的那一组子节点的长度
12     const commonLength = Math.min(oldLen, newLen)
13     // 遍历 commonLength 次
14     for (let i = 0; i < commonLength; i++) {
15       patch(oldChildren[i], newChildren[i], container)
16     }
17     // 如果 newLen > oldLen，说明有新子节点需要挂载
18     if (newLen > oldLen) {
19       for (let i = commonLength; i < newLen; i++) {
20         patch(null, newChildren[i], container)
21       }
22     } else if (oldLen > newLen) {
23       // 如果 oldLen > newLen，说明有旧子节点需要卸载
24       for (let i = commonLength; i < oldLen; i++) {
25         unmount(oldChildren[i])
26       }
27     }
28   } else {
29     // 省略部分代码
30   }
31 }
```

<a name="ilIY2"></a>

###### 9.2：DOM复用和key的作用

有些时候，新旧`vnode.children`的内容有很多相同，不需要做改动的操作，这个时候，这些相同的`DOM`是可以保留下面，不需要更新也不需要挂载和卸载，所以下一个优化方向是，如何知道这个`DOM`既出现在`oldVnode.children`，也出现在`newVnode.children`。<br />引入`key`,唯一标识符。这样就可以知道在不在了。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27119990/1679812023829-38ae91c1-3fc6-445c-95d1-9dbaba92d073.png#averageHue=%23ebebeb&clientId=uc9d64d88-5777-4&from=paste&height=244&id=u5adc75c1&originHeight=244&originWidth=635&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38084&status=done&style=none&taskId=u1afe2894-cf34-4bf5-87ea-940b34303dd&title=&width=635)<br />但是，`key`相同，并不一定意味着可以直接复用，他们的`children`可能会不一样。

```javascript
01 function patchChildren(n1, n2, container) {
02   if (typeof n2.children === 'string') {
03     // 省略部分代码
04   } else if (Array.isArray(n2.children)) {
05     const oldChildren = n1.children
06     const newChildren = n2.children
07
08     // 遍历新的 children
09     for (let i = 0; i < newChildren.length; i++) {
10       const newVNode = newChildren[i]
11       // 遍历旧的 children
12       for (let j = 0; j < oldChildren.length; j++) {
13         const oldVNode = oldChildren[j]
14         // 如果找到了具有相同 key 值的两个节点，说明可以复用，但仍然需要调用 patch 函数更新
15         if (newVNode.key === oldVNode.key) {
16           patch(oldVNode, newVNode, container)
17           break // 这里需要 break
18         }
19       }
20     }
21
22   } else {
23     // 省略部分代码
24   }
25 }
```

<a name="NOGZI"></a>

###### 9.3：找到需要移动的元素

上面解决了找到可复用的节点。这里就是用来考虑该节点是否需要移动。<br />如何判断该元素需要移动：如果索引值具有单调递增的特性，说明不需要移动，但是中途有索引比当前状态下的最大索引要小，说明该节点需要移动。

```javascript
01 function patchChildren(n1, n2, container) {
02   if (typeof n2.children === 'string') {
03     // 省略部分代码
04   } else if (Array.isArray(n2.children)) {
05     const oldChildren = n1.children
06     const newChildren = n2.children
07
08     // 用来存储寻找过程中遇到的最大索引值
09     let lastIndex = 0
10     for (let i = 0; i < newChildren.length; i++) {
11       const newVNode = newChildren[i]
12       for (let j = 0; j < oldChildren.length; j++) {
13         const oldVNode = oldChildren[j]
14         if (newVNode.key === oldVNode.key) {
15           patch(oldVNode, newVNode, container)
16           if (j < lastIndex) {
17             // 如果当前找到的节点在旧 children 中的索引小于最大索引值 lastIndex，
18             // 说明该节点对应的真实 DOM 需要移动
19           } else {
20             // 如果当前找到的节点在旧 children 中的索引不小于最大索引值，
21             // 则更新 lastIndex 的值
22             lastIndex = j
23           }
24           break // 这里需要 break
25         }
26       }
27     }
28
29   } else {
30     // 省略部分代码
31   }
32 }
```

<a name="xG18S"></a>

###### 9.4：如何移动

这里的移动是值移动真实`DOM`，而不是移动虚拟`DOM`。

> 如果移动的是vnode，那又需要挂载，等于白干

`vnode.el`记录的是真实`DOM`,所以可以利用它来进行`DOM`的移动。<br />根据上面的算法来模拟一遍，起始的索引是0，遍历新子节点数组，如何在旧子节点数组里第一个元素`p-3`可得，索引为2，此时2比起始索引大（最大索引记为`lastIndex`），所以`p-3`不需要移动，并且更新`lastIndex`为2。<br />接着找`p-1`的索引，值为0，比`lastIndex`要小，说明需要移动，移动到何处，由新子节点的顺序规定，也就是移动到`newVnode[i - 1]`的后面。<br />然后就是`p-2`，跟找`p-1`同理。<br />看代码：

- `anchor`：锚点，用于移动到哪，配合`insertBefore`使用。
- `el.nextSibling`：获取兄弟节点的下一个节点，然后赋值给`anchor`。
- `insertBefore`：两个参数，第一个参数为需要插入的节点，第二个参数是位置。

```javascript
01 function patchChildren(n1, n2, container) {
02   if (typeof n2.children === 'string') {
03     // 省略部分代码
04   } else if (Array.isArray(n2.children)) {
05     const oldChildren = n1.children
06     const newChildren = n2.children
07
08     let lastIndex = 0
09     for (let i = 0; i < newChildren.length; i++) {
10       const newVNode = newChildren[i]
11       let j = 0
12       for (j; j < oldChildren.length; j++) {
13         const oldVNode = oldChildren[j]
14         if (newVNode.key === oldVNode.key) {
15           patch(oldVNode, newVNode, container)
16           if (j < lastIndex) {
17             // 代码运行到这里，说明 newVNode 对应的真实 DOM 需要移动
18             // 先获取 newVNode 的前一个 vnode，即 prevVNode
19             const prevVNode = newChildren[i - 1]
20             // 如果 prevVNode 不存在，则说明当前 newVNode 是第一个节点，它不需要移动
21             if (prevVNode) {
22               // 由于我们要将 newVNode 对应的真实 DOM 移动到 prevVNode 所对应真实 DOM 后面，
23               // 所以我们需要获取 prevVNode 所对应真实 DOM 的下一个兄弟节点，并将其作为锚点
24               const anchor = prevVNode.el.nextSibling
25               // 调用 insert 方法将 newVNode 对应的真实 DOM 插入到锚点元素前面，
26               // 也就是 prevVNode 对应真实 DOM 的后面
27               insert(newVNode.el, container, anchor)
28             }
29           } else {
30             lastIndex = j
31           }
32           break
33         }
34       }
35     }
36
37   } else {
38     // 省略部分代码
39   }
40 }


01 const renderer = createRenderer({
02   // 省略部分代码
03
04   insert(el, parent, anchor = null) {
05     // insertBefore 需要锚点元素 anchor
06     parent.insertBefore(el, anchor) // 如果anchor为null，则会插入到最后面
07   }
08
09   // 省略部分代码
10 })
```

看图：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27119990/1679814510817-acbe6781-1da2-43b6-9a36-29b086cd2b7e.png#averageHue=%23ececec&clientId=uc9d64d88-5777-4&from=paste&height=412&id=Sy78w&originHeight=412&originWidth=672&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68346&status=done&style=none&taskId=u5c4a942b-6651-4675-9709-b648a1a1619&title=&width=672)
<a name="Rrvlq"></a>

###### 9.5：添加新元素

新增节点考虑的问题如下：

- 哪个需要新增
- 新增的该放哪

问题一在前面设置`key`的时候就已经解决了，如果新子节点数组内有的而旧的没有的话，说明是新增。<br />问题二其实也简单，因为在新子节点数组里是规定好了顺序，并且也跟对应的真实`DOM`有联系，所以直接挂载就可以了。

```javascript
01 function patchChildren(n1, n2, container) {
02   if (typeof n2.children === 'string') {
03     // 省略部分代码
04   } else if (Array.isArray(n2.children)) {
05     const oldChildren = n1.children
06     const newChildren = n2.children
07
08     let lastIndex = 0
09     for (let i = 0; i < newChildren.length; i++) {
10       const newVNode = newChildren[i]
11       let j = 0
12       // 在第一层循环中定义变量 find，代表是否在旧的一组子节点中找到可复用的节点，
13       // 初始值为 false，代表没找到
14       let find = false
15       for (j; j < oldChildren.length; j++) {
16         const oldVNode = oldChildren[j]
17         if (newVNode.key === oldVNode.key) {
18           // 一旦找到可复用的节点，则将变量 find 的值设为 true
19           find = true
20           patch(oldVNode, newVNode, container)
21           if (j < lastIndex) {
22             const prevVNode = newChildren[i - 1]
23             if (prevVNode) {
24               const anchor = prevVNode.el.nextSibling
25               insert(newVNode.el, container, anchor)
26             }
27           } else {
28             lastIndex = j
29           }
30           break
31         }
32       }
33       // 如果代码运行到这里，find 仍然为 false，
34       // 说明当前 newVNode 没有在旧的一组子节点中找到可复用的节点
35       // 也就是说，当前 newVNode 是新增节点，需要挂载
36       if (!find) {
37         // 为了将节点挂载到正确位置，我们需要先获取锚点元素
38         // 首先获取当前 newVNode 的前一个 vnode 节点
39         const prevVNode = newChildren[i - 1]
40         let anchor = null
41         if (prevVNode) {
42           // 如果有前一个 vnode 节点，则使用它的下一个兄弟节点作为锚点元素
43           anchor = prevVNode.el.nextSibling
44         } else {
45           // 如果没有前一个 vnode 节点，说明即将挂载的新节点是第一个子节点
46           // 这时我们使用容器元素的 firstChild 作为锚点
47           anchor = container.firstChild
48         }
49         // 挂载 newVNode
50         patch(null, newVNode, container, anchor)
51       }
52     }
53
54   } else {
55     // 省略部分代码
56   }
57 }


01 // patch 函数需要接收第四个参数，即锚点元素
02 function patch(n1, n2, container, anchor) {
03   // 省略部分代码
04
05   if (typeof type === 'string') {
06     if (!n1) {
07       // 挂载时将锚点元素作为第三个参数传递给 mountElement 函数
08       mountElement(n2, container, anchor)
09     } else {
10       patchElement(n1, n2)
11     }
12   } else if (type === Text) {
13     // 省略部分代码
14   } else if (type === Fragment) {
15     // 省略部分代码
16   }
17 }
18
19 // mountElement 函数需要增加第三个参数，即锚点元素
20 function mountElement(vnode, container, anchor) {
21   // 省略部分代码
22
23   // 在插入节点时，将锚点元素透传给 insert 函数
24   insert(el, container, anchor)
25 }
```

<a name="F71R4"></a>

###### 9.6：移除不存在的元素

遍历旧子数组，如果旧的有而新的没有说明要移除。

```javascript
01 function patchChildren(n1, n2, container) {
02   if (typeof n2.children === 'string') {
03     // 省略部分代码
04   } else if (Array.isArray(n2.children)) {
05     const oldChildren = n1.children
06     const newChildren = n2.children
07
08     let lastIndex = 0
09     for (let i = 0; i < newChildren.length; i++) {
10       // 省略部分代码
11     }
12
13     // 上一步的更新操作完成后
14     // 遍历旧的一组子节点
15     for (let i = 0; i < oldChildren.length; i++) {
16       const oldVNode = oldChildren[i]
17       // 拿旧子节点 oldVNode 去新的一组子节点中寻找具有相同 key 值的节点
18       const has = newChildren.find(
19         vnode => vnode.key === oldVNode.key
20       )
21       if (!has) {
22         // 如果没有找到具有相同 key 值的节点，则说明需要删除该节点
23         // 调用 unmount 函数将其卸载
24         unmount(oldVNode)
25       }
26     }
27
28   } else {
29     // 省略部分代码
30   }
31 }
```

<a name="AQudu"></a>

###### 9.7：总结

`Diff`算法是用来计算两组子节点的差异，并且最大程度上来复用`DOM`元素。改进前是全部卸载再挂载，改进后是遍历新旧子节点数量，需要更新的更新，需要卸载的卸载，需要增加的增加。其中引入了`key`，是`Diff`算法里一个非常重要的角色。<br />然后还讲了如何移动添加删除等等。
<a name="pQjfQ"></a>

##### vue设计与实现第十章：双端Diff算法

<a name="ZY39g"></a>

###### 10.1：双端比较的原理

简单`Diff`算法执行流程：<br />遍历`newChildren`，在`oldChildren` 里找`newChildren[i]`的索引，并且维护一个`lastIndex`记录最大索引

- 如果`i < lastIndex`则将`newChildren[i]`的真实`Dom`移动到`newChildren[i - 1]`下面，
- 否则不动，并且更新`lastIndex`

缺点：如图所示，对于新旧`vnode`去操作`Dom`的时候，他是将`p-1`，`p-2`往下移。进行了两次操作，假设如果`oldVnode`是从`p1-pn`,而`newVnode`的顺序是`pn,p1-pn-1`,以简单`Diff`算法来说，他是不是会进行操作`n-1`此`Dom`的移动，但是实际上，只需要将`pn`移动到最下面，就能完成操作。这就是双端`Diff`算法 优化的一个方向。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27119990/1680918674558-39498fb1-928d-48bd-944e-f21029437c61.png#averageHue=%23f0f0f0&clientId=uea9ba219-d8a1-4&from=paste&height=239&id=u2e74a3d8&originHeight=340&originWidth=390&originalType=binary&ratio=0.8999999761581421&rotation=0&showTitle=false&size=52730&status=done&style=none&taskId=u4ba42473-672d-4b14-aca9-d6319ce3a3f&title=&width=274.31597900390625)![image.png](https://cdn.nlark.com/yuque/0/2023/png/27119990/1680918706069-83b7d8fa-c62e-4f8f-8cd2-06ae8e39516d.png#averageHue=%23efefef&clientId=uea9ba219-d8a1-4&from=paste&height=242&id=u255d7fa8&originHeight=290&originWidth=392&originalType=binary&ratio=0.8999999761581421&rotation=0&showTitle=false&size=40267&status=done&style=none&taskId=u1806a264-07ca-4582-989e-de62729c8a1&title=&width=326.5486145019531)<br />双端`Diff`算法执行流程：<br />上面是该算法的变量，下面是该算法每次都要执行的四步

- 第一步比较新旧节点的`startVnode`：对应`index`往下走
- 第二步比较新旧节点的`endVnode`：对应`index`往上走
- 第三步比较`newStartVnode`和`oldEndVnode`：新的往下走，旧的往上走，并且把`oldEndVnode`插入到`oldStartVnode`的上面
- 第四步比较`newEndVnode`和`oldStartVnode`：新的往上走，旧的往下走，并且把`oldStartVnode`插入到`oldEndVnode`的下面

通过比较`key`值，判断他们是否可复用，如果可复用，则走对应分支，并且更新对应的`index`。

> 对于每一个分支，第一步都需要patch


![image.png](https://cdn.nlark.com/yuque/0/2023/png/27119990/1680922246786-f8c1107e-beb0-4f41-9827-e605f10ac462.png#averageHue=%23eeeeee&clientId=u16e9008d-eec3-4&from=paste&height=255&id=u1d0fb722&originHeight=191&originWidth=420&originalType=binary&ratio=0.8999999761581421&rotation=0&showTitle=false&size=23009&status=done&style=none&taskId=uaa172edb-3449-4c90-838c-5e4ca60ec8b&title=&width=560)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27119990/1680922257749-106dc6f5-36fc-452a-b1cb-78ce400960c0.png#averageHue=%23f2f2f2&clientId=u16e9008d-eec3-4&from=paste&height=271&id=uebdb72ca&originHeight=203&originWidth=403&originalType=binary&ratio=0.8999999761581421&rotation=0&showTitle=false&size=24085&status=done&style=none&taskId=ubaea680b-b676-421b-a042-87d3663f6f3&title=&width=537.3333333333334)<br />上面是理想状态下的双端`Diff`算法比较，他能跑起来的前提是，至少有一个分支能走，但是有时候会出现，双端，都走不了的情况，这个时候，他就会走第五步。

- 第五步，拿`newStartVnode`在旧的里面找，找到所在的位置，并且记录为`oldToVnode`，并且将这个`oldToVnode`移动到`oldStartVnode`的上面。

> 这里暂不考虑没找到的情况，如果没找到，就意味着新增了

此时，就将`newStartVode`的位置排好了，在而`oldToVnode`的位置的`Vnode`是已经走过了的，避免下一次循环再走，所以把它置为`undefined`，下一轮变量的时候，在加个对`oldStartVnode`做一下特殊处理，值是`undefined`直接跳过就好了。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27119990/1680923258397-c52a2c5f-f28b-4b8e-afbe-5021847f428c.png#averageHue=%23ebebeb&clientId=u16e9008d-eec3-4&from=paste&height=369&id=OkQG2&originHeight=277&originWidth=607&originalType=binary&ratio=0.8999999761581421&rotation=0&showTitle=false&size=42586&status=done&style=none&taskId=u64a76d3b-d6ff-4187-b2bd-7079c69bcdc&title=&width=809.3333333333334)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27119990/1680923861027-e5f32aea-f0d8-49d1-af0c-f049d210e8b4.png#averageHue=%23ededed&clientId=u16e9008d-eec3-4&from=paste&height=375&id=u6ae871e9&originHeight=281&originWidth=611&originalType=binary&ratio=0.8999999761581421&rotation=0&showTitle=false&size=46302&status=done&style=none&taskId=u24f7425a-59ba-40aa-8e35-0dbdb39e0ca&title=&width=814.6666666666666)
<a name="lrSdt"></a>

###### 10.2：添加新元素

对于双端`Diff`算法的原理，上面分析了该算法如何执行，分析了在理想状态和非理想状态的情况，也就是对于头和尾能不能找到对应的并且移动的情况。<br />在非理想状态下，新旧子数组不能保证他能直接找到，新增分支5用来做特殊处理，以及新增特殊判断，判断该`Vnode`是否已经移动过了。<br />但是对于非理性状态，也并不是总能找到，这种情况，就属于新增节点。

> 白话：我新数组里有，你旧的没有，所以新增

逻辑还是挺简单的，就是在分支5中加个判断，如果没有找到重复的`key`那就将`newStartVnoe`插入到`oldStartVnode`的上面即可。<br />但是这还有缺陷，看例子：

- `newChildren`：4，1，2，3
- `oldChildren`：1，2，3

他们开始跑代码，会发现尾部一直相同，那么就一直会走分支2，然后一直跳过，然后`oldEndIndex`会变成`-1`，`oldStartIndex`还是`1`，循环结束。但是对于`newChildren`的`4`，他并没有做任何操作，被遗弃了。<br />所以，还需要在分支5加个判断，判断`newChildren`是否有遗留，也就是`newStartIndex <= newEndIndex && oldStartIndex > oldEndIndex`，这时候需要将`newStartIndex`到`newEndIndex`之间的所有结点挂载到头部。
<a name="bWKDQ"></a>

###### 10.3：移除旧节点

判断新增是通过判断`oldEnd`是否小于`oldStart`并且满足`newStart`要小于等于`newEnd`，而判断移除也差不多，就是判断`newEnd`是否小于`newStart`并且满足`oldStart`要小于等于`oldEnd`，满足条件就逐个`unmount`。

```javascript
01 while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
02   // 省略部分代码 移动节点五个分支
03 }
04
05 if (oldEndIdx < oldStartIdx && newStartIdx <= newEndIdx) {
06   // 添加新节点
07   // 省略部分代码
08 } else if (newEndIdx < newStartIdx && oldStartIdx <= oldEndIdx) {
09   // 移除操作
10   for (let i = oldStartIdx; i <= oldEndIdx; i++) {
11     unmount(oldChildren[i])
12   }
13 }
```


<a name="HFIWM"></a>

##### vue设计与实现第十一章：快速Diff算法

<a name="KyzDc"></a>

###### 11.1：相同前置和后置元素

快速`Diff`算法与前两个`Diff`算法的区别就是它具有一个预处理的过程。<br />何为预处理？本质上来讲就是，晒掉相同的，留下不同的，我只需要去管理不同的部分，并且对该部分进行crud操作。<br />看这边例子：

```latex
01 TEXT1: I use vue for app development
02 TEXT2: I use react for app development
```

两段文本，仔细发现其实只有`vue`和`react`不一样，前后都一样。那么这说明，真正需要操作的其实只有这两个。

```latex
01 TEXT1: I like you
02 TEXT2: I like you too
```

这段也一样，只需要处理后面即可。<br />如果引申到`vnode`上，看如下的图：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/27119990/1681519758941-c65b946c-0830-4adf-a7d7-02993c6ae6f9.png#averageHue=%23ececec&clientId=u26280add-9a06-4&from=paste&height=613&id=u43cbf890&originHeight=552&originWidth=462&originalType=binary&ratio=0.8999999761581421&rotation=0&showTitle=false&size=56020&status=done&style=none&taskId=ude6c4498-9b8e-4274-8b9c-0ba9c067ab6&title=&width=513.333346932023)<br />对于相同的，我们完全不需要去处理它，只需找到不同即可。<br />代码也简单，开两个`while`循环，然后从顶部和底部遍历掉这些相同节点，将索引去指向需要`Diff`的区域即可。

```javascript
01 function patchKeyedChildren(n1, n2, container) {
02   const newChildren = n2.children
03   const oldChildren = n1.children
04   // 更新相同的前置节点
05   let j = 0
06   let oldVNode = oldChildren[j]
07   let newVNode = newChildren[j]
08   while (oldVNode.key === newVNode.key) {
09     patch(oldVNode, newVNode, container)
10     j++
11     oldVNode = oldChildren[j]
12     newVNode = newChildren[j]
13   }
14
15   // 更新相同的后置节点
16   // 索引 oldEnd 指向旧的一组子节点的最后一个节点
17   let oldEnd = oldChildren.length - 1
18   // 索引 newEnd 指向新的一组子节点的最后一个节点
19   let newEnd = newChildren.length - 1
20
21   oldVNode = oldChildren[oldEnd]
22   newVNode = newChildren[newEnd]
23
24   // while 循环从后向前遍历，直到遇到拥有不同 key 值的节点为止
25   while (oldVNode.key === newVNode.key) {
26     // 调用 patch 函数进行更新
27     patch(oldVNode, newVNode, container)
28     // 递减 oldEnd 和 nextEnd
29     oldEnd--
30     newEnd--
31     oldVNode = oldChildren[oldEnd]
32     newVNode = newChildren[newEnd]
33   }
34
35 }
```

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27119990/1681520079090-84e931d6-251a-41e1-a9b7-fdceeb48688e.png#averageHue=%23f7f7f7&clientId=u26280add-9a06-4&from=paste&height=506&id=u5f8c2ec6&originHeight=455&originWidth=725&originalType=binary&ratio=0.8999999761581421&rotation=0&showTitle=false&size=63929&status=done&style=none&taskId=uffa62bd0-3e2d-459d-b29e-cc7bded5352&title=&width=805.5555768954906)<br />这里的新增节点和需要移除的节点跟双端那边类似，只是索引变量名字稍微有点变化。
<a name="B64bB"></a>

###### 11.2：判断是否需要进行DOM的移动

简明的说，对于以上的预处理以及算法的设计，是在理想状态下的。世间总是不那么尽人意。所以这些节点就是喜欢来给你出问题。比如以下的节点：

- `newChildren`：2 3 1 5 6 4 7 8
- `oldChildren`：2 9 2 5 4 7 2 8

通过预处理后，只有削去了前面第一个和后面第一个，按照上面算法来跑，说明这之间的又得全部卸载和全部挂在，这明显又回到了原地，不符合快速的这一名称。<br />`Diff`算法，本质上来讲就是想尽可能地减少`DOM`操作，对于上面的节点，有些还是比较类似的，这说明也还是可以复用，这就回到了如何移动这些可复用的`DOM`元素上。

> 不管哪种diff算法，他们终究都需要去做两件事情
> 1、判断是否需要移动
> 2、找到需要新增的和需要卸载的

所以，对于非理想情况，应该再开一个分支进行去处理它。<br />算法的设计是建立一个`source`数组，里面的内容是中间不理想区域的一个索引，也就是对于新节点在旧节点上的索引值。<br />然后通过这个`source`函数，利用简单`Diff`算法的思路找出需要移动的节点，也就是序列保持递增时说明不需要移动，反之则需要移动。
<a name="qhlYP"></a>

###### 11.3：如何移动

基于上面的条件，我们实现了两个目标。

- 判断是否需要移动
- `source`数组

这个`source`数组可不一般，精髓所在，后续通过它，计算出一个最长递增子序列，然后再去移动`Dom`。

> 最长递增子序列：[https://juejin.cn/post/7134499769803603999](https://juejin.cn/post/7134499769803603999)	

找出最长递增子序列的区间，该区间记录的是在`newChildren`中这段上升子序列的索引值。构建一个`s`和`i`。

- `s`：表示最长递增子序列的尾部索引
- `i`：表示`newChildren`中预处理后的尾部索引

![image.png](https://cdn.nlark.com/yuque/0/2023/png/27119990/1681526855864-91ce30ff-f99c-4cb1-a5bc-cc529b8acff4.png#averageHue=%23f9f9f9&clientId=u26280add-9a06-4&from=paste&height=417&id=u0c958191&originHeight=313&originWidth=529&originalType=binary&ratio=0.8999999761581421&rotation=0&showTitle=false&size=27997&status=done&style=none&taskId=u5ef43c84-93c0-469e-b5e0-276d69b70ee&title=&width=705.3333333333334)<br />接着，开始遍历。算法的设计如下：

- 如果`source[i]`的值为`-1`，这表明该节点需要新增
- 如果`i！== seq[s]`，表明该节点需要移动，直接将该节点移动到他应该所在的位置
- 如果前两个分支都没走，说明`i === seq[i]`的，这是可复用的节点，不需要做任何`Dom`操作。尾部提升就行。

```javascript
01 if (moved) {
02   const seq = lis(sources)
03
04   // s 指向最长递增子序列的最后一个元素
05   let s = seq.length - 1
06   let i = count - 1
07   for (i; i >= 0; i--) {
08     if (source[i] === -1) {
09       // 下面是插入，这里是挂载，位置的获取和下面一样，只是需要特判一下是否是最下面
10     } else if (i !== seq[s]) {
11       // 说明该节点需要移动
12       // 该节点在新的一组子节点中的真实位置索引
13       const pos = i + newStart
14       const newVNode = newChildren[pos]
15       // 该节点的下一个节点的位置索引
16       const nextPos = pos + 1
17       // 锚点
18       const anchor = nextPos < newChildren.length
19         ? newChildren[nextPos].el
20         : null
21       // 移动
22       insert(newVNode.el, container, anchor)
23     } else {
24       // 当 i === seq[s] 时，说明该位置的节点不需要移动
25       // 并让 s 指向下一个位置
26       s--
27     }
28   }
29 }
```

<a name="UDuYf"></a>

###### 11.4：总结

预处理，减少`Dom`操作，并且还能精确到当前组件。因为快所以叫快速。
<a name="D5ng1"></a>

##### vue设计与实现第十二章：组件的实现原理



