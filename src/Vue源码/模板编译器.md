---
title: 模板编译器
description: Vue3的模板编译器的实现方式。关于编译的知识。
category:
  - 源码
  - 算法
  - 编译器
tag:
  - Vue
  - 状态机
  - AST
star: true
---

### 编译器的流程以及parser的实现
编译一般的步骤由词法分析，语法分析，语义分析，中间代码生成，优化，目标代码生成等步骤。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/27119990/1682166533169-9f54f5dc-23a5-4e6c-83ad-d1d6f29c3bda.png#averageHue=%23f0f0f0&clientId=u9e1df5ee-a33e-4&from=paste&height=152&id=u0cddac23&originHeight=152&originWidth=764&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21518&status=done&style=none&taskId=ud4459731-51a3-47ab-9796-f997cfa89b9&title=&width=764)
> 可以看到，整个编译过程分为编译前端和编译后端。编译前端包含词法分析、语法分析和语义分析，它通常与目标平台无关，仅负责分析源代码。编译后端则通常与目标平台有关，编译后端涉及中间代码生成和优化以及目标代码生成。但是，编译后端并不一定会包含中间代码生成和优化这两个环节，这取决于具体的场景和实现。中间代码生成和优化这两个环节有时也叫“中端”。


---

对于`vue`来说，编译器的功能就是将模板语法编译成渲染器能识别的`render()`。但是这中间这个过程需要先将模板语法编译成模板AST，再将模板AST转换成JSAST，最后通过JSAST生成`render()`。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/27119990/1682166877039-8dbcb3ee-db32-43fb-9f4d-94dd55c47136.png#averageHue=%23ebebeb&clientId=u9e1df5ee-a33e-4&from=paste&height=166&id=u23a0595e&originHeight=166&originWidth=752&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21848&status=done&style=none&taskId=ud6fd5607-8cc1-4c71-89fb-e58bc76f893&title=&width=752)
> 对于编译来说，vue编译出来的这种语言叫做[DSL（领域特定语言）](https://baike.baidu.com/item/%E9%A2%86%E5%9F%9F%E4%B8%93%E7%94%A8%E8%AF%AD%E8%A8%80/61027566?fromModule=lemma-qiyi_sense-lemma&fromtitle=DSL&fromid=60963557)，也就是针对某一种特定环境而产生的语言，类似的有HTML这些。

```javascript
// 编译前
01 <div>
02   <h1 v-if="ok">Vue Template</h1>
03 </div>
// 通过parser编译后
01 const ast = {
02   // 逻辑根节点
03   type: 'Root',
04   children: [
05     // div 标签节点
06     {
07       type: 'Element',
08       tag: 'div',
09       children: [
10         // h1 标签节点
11         {
12           type: 'Element',
13           tag: 'h1',
14           props: [
15             // v-if 指令节点
16             {
17               type: 'Directive', // 类型为 Directive 代表指令
18               name: 'if'，       // 指令名称为 if，不带有前缀 v-
19               exp: {
20                 // 表达式节点
21                 type: 'Expression',
22                 content: 'ok'
23               }
24             }
25           ]
26         }
27       ]
28     }
29   ]
30 }
```

---

上面的代码片段就是`parser`所需要实现的功能。这个函数利用的算法是[有限状态自动机](https://baike.baidu.com/item/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA/2850046?fr=aladdin)。它是通过逐步遍历模板字符串，然后进行对状态的逐步改变。比如当读取到`<`时，说明状态是开启了一个新标签，直到遇见`>`之前，这之间所遇到的所有字符串都将成为标签名，所以通过这种思想，可以把有限的状态列出来，读取时进行不同状态的转换，进行收集不同的数据。
```javascript
01 // 定义状态机的状态
02 const State = {
03   initial: 1,    // 初始状态
04   tagOpen: 2,    // 标签开始状态
05   tagName: 3,    // 标签名称状态
06   text: 4,       // 文本状态
07   tagEnd: 5,     // 结束标签状态
08   tagEndName: 6  // 结束标签名称状态
09 }
10 // 一个辅助函数，用于判断是否是字母
11 function isAlpha(char) {
12   return char >= 'a' && char <= 'z' || char >= 'A' && char <= 'Z'
13 }
14
15 // 接收模板字符串作为参数，并将模板切割为 Token 返回
16 function tokenize(str) {
17   // 状态机的当前状态：初始状态
18   let currentState = State.initial
19   // 用于缓存字符
20   const chars = []
21   // 生成的 Token 会存储到 tokens 数组中，并作为函数的返回值返回
22   const tokens = []
23   // 使用 while 循环开启自动机，只要模板字符串没有被消费尽，自动机就会一直运行
24   while(str) {
25     // 查看第一个字符，注意，这里只是查看，没有消费该字符
26     const char = str[0]
27     // switch 语句匹配当前状态
28     switch (currentState) {
29       // 状态机当前处于初始状态
30       case State.initial:
31         // 遇到字符 <
32         if (char === '<') {
33           // 1. 状态机切换到标签开始状态
34           currentState = State.tagOpen
35           // 2. 消费字符 <
36           str = str.slice(1)
37         } else if (isAlpha(char)) {
38           // 1. 遇到字母，切换到文本状态
39           currentState = State.text
40           // 2. 将当前字母缓存到 chars 数组
41           chars.push(char)
42           // 3. 消费当前字符
43           str = str.slice(1)
44         }
45         break
46       // 状态机当前处于标签开始状态
47       case State.tagOpen:
48         if (isAlpha(char)) {
49           // 1. 遇到字母，切换到标签名称状态
50           currentState = State.tagName
51           // 2. 将当前字符缓存到 chars 数组
52           chars.push(char)
53           // 3. 消费当前字符
54           str = str.slice(1)
55         } else if (char === '/') {
56           // 1. 遇到字符 /，切换到结束标签状态
57           currentState = State.tagEnd
58           // 2. 消费字符 /
59           str = str.slice(1)
60         }
61         break
62       // 状态机当前处于标签名称状态
63       case State.tagName:
64         if (isAlpha(char)) {
65           // 1. 遇到字母，由于当前处于标签名称状态，所以不需要切换状态，
66           // 但需要将当前字符缓存到 chars 数组
67           chars.push(char)
68           // 2. 消费当前字符
69           str = str.slice(1)
70         } else if (char === '>') {
71           // 1.遇到字符 >，切换到初始状态
72           currentState = State.initial
73           // 2. 同时创建一个标签 Token，并添加到 tokens 数组中
74           // 注意，此时 chars 数组中缓存的字符就是标签名称
75           tokens.push({
76             type: 'tag',
77             name: chars.join('')
78           })
79           // 3. chars 数组的内容已经被消费，清空它
80           chars.length = 0
81           // 4. 同时消费当前字符 >
82           str = str.slice(1)
83         }
84         break
85       // 状态机当前处于文本状态
86       case State.text:
87         if (isAlpha(char)) {
88           // 1. 遇到字母，保持状态不变，但应该将当前字符缓存到 chars 数组
89           chars.push(char)
90           // 2. 消费当前字符
91           str = str.slice(1)
92         } else if (char === '<') {
93           // 1. 遇到字符 <，切换到标签开始状态
94           currentState = State.tagOpen
95           // 2. 从 文本状态 --> 标签开始状态，此时应该创建文本 Token，并添加到 tokens 数组
96           // 注意，此时 chars 数组中的字符就是文本内容
97           tokens.push({
98             type: 'text',
99             content: chars.join('')
100           })
101           // 3. chars 数组的内容已经被消费，清空它
102           chars.length = 0
103           // 4. 消费当前字符
104           str = str.slice(1)
105         }
106         break
107       // 状态机当前处于标签结束状态
108       case State.tagEnd:
109         if (isAlpha(char)) {
110           // 1. 遇到字母，切换到结束标签名称状态
111           currentState = State.tagEndName
112           // 2. 将当前字符缓存到 chars 数组
113           chars.push(char)
114           // 3. 消费当前字符
115           str = str.slice(1)
116         }
117         break
118       // 状态机当前处于结束标签名称状态
119       case State.tagEndName:
120         if (isAlpha(char)) {
121           // 1. 遇到字母，不需要切换状态，但需要将当前字符缓存到 chars 数组
122           chars.push(char)
123           // 2. 消费当前字符
124           str = str.slice(1)
125         } else if (char === '>') {
126           // 1. 遇到字符 >，切换到初始状态
127           currentState = State.initial
128           // 2. 从 结束标签名称状态 --> 初始状态，应该保存结束标签名称 Token
129           // 注意，此时 chars 数组中缓存的内容就是标签名称
130           tokens.push({
131             type: 'tagEnd',
132             name: chars.join('')
133           })
134           // 3. chars 数组的内容已经被消费，清空它
135           chars.length = 0
136           // 4. 消费当前字符
137           str = str.slice(1)
138         }
139         break
140     }
141   }
142
143   // 最后，返回 tokens
144   return tokens
145 }
```

---

