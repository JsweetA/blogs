---
title: 内建组件和模块
description: Vue3的内部组件模块，包括一些KeepAlive，Teleport等
category:
  - 源码
  - 网络
tag:
  - Vue
  - KeepAlive
  - HTTP
star: true
---
<a name="YR0ir"></a>
### 一.keepAlive组件的实现原理
`KeepAlive` 又称`HTTP` 持久连接（HTTP persistent connection），其作用是允许多个请求或响应共用一个 TCP 连接。由于每个`HTTP`请求都会建立一个新的连接并且在结束时销毁。所以当多个请求进行发送时就会导致额外的性能开销。但在响应头里把`Connection`字段的值设置成`keep-alive`，这样就能使用长连接的`HTTP`协议。
> webSocket和HTTP：[https://zhuanlan.zhihu.com/p/113286469](https://zhuanlan.zhihu.com/p/113286469)

同理，对于一个组件，反复的挂载和卸载会导致很多额外的开销，`KeepAlive`就是用来解决这个问题的。<br />`KeepAlive`本质上是对组件的缓存，将不用的组件缓存到一个看不见的地方，卸载的时候把他放进去，用的时候再拿出来。
```javascript
01 const KeepAlive = {
02   // KeepAlive 组件独有的属性，用作标识
03   __isKeepAlive: true,
04   setup(props, { slots }) {
05     // 创建一个缓存对象
06     // key: vnode.type
07     // value: vnode
08     const cache = new Map()
09     // 当前 KeepAlive 组件的实例
10     const instance = currentInstance
11     // 对于 KeepAlive 组件来说，它的实例上存在特殊的 keepAliveCtx 对象，该对象由渲染器注入
12     // 该对象会暴露渲染器的一些内部方法，其中 move 函数用来将一段 DOM 移动到另一个容器中
13     const { move, createElement } = instance.keepAliveCtx
14
15     // 创建隐藏容器
16     const storageContainer = createElement('div')
17
18     // KeepAlive 组件的实例上会被添加两个内部函数，分别是 _deActivate 和 _activate
19     // 这两个函数会在渲染器中被调用
20     instance._deActivate = (vnode) => {
21       move(vnode, storageContainer)
22     }
23     instance._activate = (vnode, container, anchor) => {
24       move(vnode, container, anchor)
25     }
26
27     return () => {
28       // KeepAlive 的默认插槽就是要被 KeepAlive 的组件
29       let rawVNode = slots.default()
30       // 如果不是组件，直接渲染即可，因为非组件的虚拟节点无法被 KeepAlive
31       if (typeof rawVNode.type !== 'object') {
32         return rawVNode
33       }
34
35       // 在挂载时先获取缓存的组件 vnode
36       const cachedVNode = cache.get(rawVNode.type)
37       if (cachedVNode) {
38         // 如果有缓存的内容，则说明不应该执行挂载，而应该执行激活
39         // 继承组件实例
40         rawVNode.component = cachedVNode.component
41         // 在 vnode 上添加 keptAlive 属性，标记为 true，避免渲染器重新挂载它
42         rawVNode.keptAlive = true
43       } else {
44         // 如果没有缓存，则将其添加到缓存中，这样下次激活组件时就不会执行新的挂载动作了
45         cache.set(rawVNode.type, rawVNode)
46       }
47
48       // 在组件 vnode 上添加 shouldKeepAlive 属性，并标记为 true，避免渲染器真的将组件卸载
49       rawVNode.shouldKeepAlive = true
50       // 将 KeepAlive 组件的实例也添加到 vnode 上，以便在渲染器中访问
51       rawVNode.keepAliveInstance = instance
52
53       // 渲染组件 vnode
54       return rawVNode
55     }
56   }
57 }
```
通过以上的构建就得到了一些信息，可以明确的知道对于该组件是否是第一次挂载以及后期的激活和失活。

---

对`KeepAlive`组件的实现后，就是对`include`和`exclude`以及`max`的实现了。对于`max`，就差不多是一道设计一个缓存机制的算法题，其他两个就只是单纯匹配了。总体设计不难。
```javascript
01 const cache = new Map()
02 const KeepAlive = {
03   __isKeepAlive: true,
04   props: {
05     include: RegExp,
06     exclude: RegExp
07   },
08   setup(props, { slots }) {
09     // 省略部分代码
10
11     return () => {
12       let rawVNode = slots.default()
13       if (typeof rawVNode.type !== 'object') {
14         return rawVNode
15       }
16       // 获取“内部组件”的 name
17       const name = rawVNode.type.name
18       // 对 name 进行匹配
19       if (
20         name &&
21         (
22           // 如果 name 无法被 include 匹配
23           (props.include && !props.include.test(name)) ||
24           // 或者被 exclude 匹配
25           (props.exclude && props.exclude.test(name))
26         )
27       ) {
28         // 则直接渲染“内部组件”，不对其进行后续的缓存操作
29         return rawVNode
30       }
31
32       // 省略部分代码
33     }
34   }
35 }
```
<a name="UJTeh"></a>
### 二.Teleport组件的实现原理
该组件的诞生是为了解决组件的层级关系不依赖与模板结构。就是说，父组件包了子组件，但是子组件最终挂载的地方并不是当前父组件下面。
```javascript
01 <Teleport to="body">
02   <h1>Title</h1>
03   <p>content</p>
04 </Teleport>
```
本身它的意思也很明确，就是将`children`全部挂载到`body`下面去。而且这个`to`属性还可以进行`v-bind`，也就是说，还是随便放 -_-  。<br />通过`dom`操作获取到指定的节点，然后将`children`挂载上去即可，后期更新的时候也只需要`patchChildren`即可。不过考虑到`to`的值会发送变化，所以要多加个特判来决定是否需要移动。
<a name="HFmUL"></a>
### 三.Transition组件的实现原理
在设计原生的过渡效果的时候，需要考虑三个点，从哪来`(.enter_from)`,到哪去`(.enter_to)`，如何过渡`(.enter_active)`。当设计好这三个点后，过渡效果就呈现出来了。这三个点对挂载和卸载都有效。
```javascript
// 入场动画
01 // 创建 class 为 box 的 DOM 元素
02 const el = document.createElement('div')
03 el.classList.add('box')
04
05 // 在 DOM 元素被添加到页面之前，将初始状态和运动过程定义到元素上
06 el.classList.add('enter-from')    // 初始状态
07 el.classList.add('enter-active')  // 运动过程
08
09 // 将元素添加到页面
10 document.body.appendChild(el)
11
12 // 嵌套调用 requestAnimationFrame
13 requestAnimationFrame(() => {
14   requestAnimationFrame(() => {
15     el.classList.remove('enter-from')  // 移除 enter-from
16     el.classList.add('enter-to')       // 添加 enter-to
17   })
18 })

// 离场动画
01 el.addEventListener('click', () => {
02   // 将卸载动作封装到 performRemove 函数中
03   const performRemove = () => el.parentNode.removeChild(el)
04
05   // 设置初始状态：添加 leave-from 和 leave-active 类
06   el.classList.add('leave-from')
07   el.classList.add('leave-active')
08
09   // 强制 reflow：使初始状态生效
10   document.body.offsetHeight
11
12   // 在下一帧切换状态
13   requestAnimationFrame(() => {
14     requestAnimationFrame(() => {
15       // 切换到结束状态
16       el.classList.remove('leave-from')
17       el.classList.add('leave-to')
18
19       // 监听 transitionend 事件做收尾工作
20       el.addEventListener('transitionend', () => {
21         el.classList.remove('leave-to')
22         el.classList.remove('leave-active')
23         // 当过渡完成后，记得调用 performRemove 函数将 DOM 元素移除
24         performRemove()
25       })
26     })
27   })
28 })
```
被`Transition`组件包装后的组件会添加一个`transition`属性，里面的内容就是一些关于`DOM`过渡的钩子。比如：`beforeEnter`，`enter`，`leave`。对于组件的过渡效果来说，具体体现的是在组件的进入和组件的退出。也就是`mounted`和`unmounted`这两个钩子。
> actived和unactived我不清楚是否也能激活过渡效果。

<a name="ApD4N"></a>
### 四.总结
这些内置组件的创建都跟渲染器有紧密联系，而他们的定义是基于组件上进行修改，利用插槽函数等。

1. 对于`KeepAlive`组件是借用了`HTTP`中的长连接的概率，解决了组件的反复挂载和卸载造成的额外开销。本质上的实现是将组件缓存下来。不过考虑到缓存过多成本也很大，所以引入了一些策略上的属性，`include`，`exclude`，`max`。
> HTTP的长连接本质上是TCP的长连接，HTTP是TCP/IP协议簇的子集之一，是基于TCP/IP的应用层服务

2. 对于`Teleport`组件来说，实现了跨越`DOM`层级完成渲染的功能。Teleport组件可以避免渲染器的代码膨胀，以及使打包体积更小的原因，主要是因为它可以将子组件的内容直接移动到指定位置，而不需要创建新的真实DOM节点。具体来说，Teleport组件的实现方式是使用了DOM中的"移动"（move）操作，实现了将子组件的内容渲染到指定的目标位置（target）中去。这样，通过Teleport组件渲染出的子组件内容，可以在视觉上被认为是在Teleport组件外渲染的，但实际上它们并没有被添加到任何额外的DOM节点中。这就避免了因为Teleport组件造成的额外DOM节点的创建，从而减少了渲染器的工作量和代码膨胀，降低了打包体积。
3. 至于`Transition`组件，他就是进行对`DOM`的进场和离场做一个分析，然后讨论出三个钩子函数。然后在组件的进场和离场之前，将这些钩子函数执行，从而达到过渡效果。
