import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as s,c as g,b as i,d as a,e as t,a as n}from"./app-9833f5dd.js";const o="/blogs/assets/image-20231128150032853-a55c686e.png",c="/blogs/assets/image-20231127194123118-76a89ba6.png",d="/blogs/assets/image-20231128201321021-16527586.png",p="/blogs/assets/image-20231127193101194-ed824f8d.png",h="/blogs/assets/image-20231127193203639-72a0a717.png",f="/blogs/assets/image-20231128204519239-c188d9ea.png",u="/blogs/assets/image-20231128205752430-4551b944.png",m="/blogs/assets/image-20231129172412206-fb22587a.png",_="/blogs/assets/image-20231128201053314-029c6bb5.png",b="/blogs/assets/image-20231128205712114-dd248482.png",x="/blogs/assets/image-20231128142851889-0574eb1a.png",z="/blogs/assets/image-20231128142829513-bbc2df28.png",y="/blogs/assets/image-20231128143314043-d29dc094.png",k="/blogs/assets/image-20231128143321795-fc22e644.png",E="/blogs/assets/image-20231128144540035-2c5890ba.png",I="/blogs/assets/image-20231128144807819-fee7940c.png",q="/blogs/assets/image-20231128144839640-b6c22722.png",v="/blogs/assets/image-20231128144920540-abb694a6.png",A="/blogs/assets/image-20231129194533951-83c98862.png",N="/blogs/assets/image-20231129194547864-8f22d787.png",C="/blogs/assets/image-20231128145826998-736b0b70.png",B="/blogs/assets/image-20231128145839265-146f2edb.png",V="/blogs/assets/image-20231129195728815-b312bcfa.png",w="/blogs/assets/image-20231129202240736-1b410d37.png",S={},D=n('<h1 id="测试复习" tabindex="-1"><a class="header-anchor" href="#测试复习" aria-hidden="true">#</a> 测试复习</h1><h2 id="testing" tabindex="-1"><a class="header-anchor" href="#testing" aria-hidden="true">#</a> Testing</h2><h3 id="静态测试-动态测试" tabindex="-1"><a class="header-anchor" href="#静态测试-动态测试" aria-hidden="true">#</a> 静态测试-动态测试</h3><p>按照是否被执行可分为<strong>动态测试</strong>和<strong>静态测试</strong></p><ul><li>动态测试：功能确认，接口测试，覆盖率分析，性能分析</li><li>静态测试：代码检查，静态结构分析，代码质量度量</li></ul><blockquote><p>其中黑盒只有动态测试，白盒有静态和动态</p></blockquote><p>按照是否针对系统内部结构和具体实现算法的角度可分为：黑盒，白盒</p><figure><img src="'+o+'" alt="image-20231128150032853" tabindex="0" loading="lazy"><figcaption>image-20231128150032853</figcaption></figure><h3 id="黑盒测试" tabindex="-1"><a class="header-anchor" href="#黑盒测试" aria-hidden="true">#</a> 黑盒测试</h3>',9),L=n('<li><p>等价类：找if，寻找有效和无效等价类，并且为此设计测试用例</p></li><li><p>边界值分析：基于等价类的条件下，设计测试用例的时候进行采取边界值取法。其中取法规则如下：</p><ul><li>一遍边界值：4n + 1（不考虑无效）</li><li>一遍边界值的最坏情况：5的n次方</li><li>健壮性边界值：6n + 1（考虑无效）</li><li>健壮性的最坏情况：7的n次方</li></ul><figure><img src="'+c+'" alt="image-20231127194123118" tabindex="0" loading="lazy"><figcaption>image-20231127194123118</figcaption></figure><figure><img src="'+d+'" alt="image-20231128201321021" tabindex="0" loading="lazy"><figcaption>image-20231128201321021</figcaption></figure></li>',2),T={href:"https://blog.csdn.net/weixin_53436351/article/details/123638152",target:"_blank",rel:"noopener noreferrer"},j=n('<li><p>因果图：找原因 -&gt; 找结果，其中原因附带什么条件可以得出什么结果</p><ul><li><p>约束关系：互斥（E），包含（I），唯一（O），要求（R），屏蔽（M）</p><figure><img src="'+p+'" alt="image-20231127193101194" tabindex="0" loading="lazy"><figcaption>image-20231127193101194</figcaption></figure></li><li><p>因果关系：恒等，非（~），与和或</p><figure><img src="'+h+'" alt="image-20231127193203639" tabindex="0" loading="lazy"><figcaption>image-20231127193203639</figcaption></figure></li></ul></li><li><p>状态图：明确状态节点 -&gt; 绘制迁移图 -&gt; 绘制状态迁移树 -&gt; 抽取测试路径</p></li><li><p>场景法：画流程图 -&gt; 主要事件 -&gt; 备选事件 -&gt; 设计测试用例</p></li>',3),F=i("p",null,"后两个更倾向于真实业务测试，也就是功能测试。",-1),M={href:"https://zhuanlan.zhihu.com/p/451208514",target:"_blank",rel:"noopener noreferrer"},P={href:"https://juejin.cn/post/7283797053339353129#heading-9",target:"_blank",rel:"noopener noreferrer"},O=n('<h3 id="白盒测试" tabindex="-1"><a class="header-anchor" href="#白盒测试" aria-hidden="true">#</a> 白盒测试</h3><p>白盒测试可分为<strong>覆盖测试和基本路径测试</strong>。其中<strong>覆盖测试</strong>有</p><ul><li>语句覆盖：让每个语句都执行</li><li>判定覆盖：每个判断都取一次真假，例如if(a&gt;0 &amp;&amp; b&gt;0)，要保证这个if的值取满true和false</li><li>条件覆盖：每个条件，指的是if内部的判断取满true，false。同上例子，要a和b这两个判断都取满true，false</li><li>条件判定覆盖：前两个的合并。所以他是一定包含了前两个的覆盖</li><li>组合覆盖：条件组合情况，例如上面例子，a&gt;0和b&gt;0的两个判断，这时候就需要他们true，false的所有组合</li><li>路径覆盖：画流程图，每条路都走</li></ul><figure><img src="'+f+'" alt="image-20231128204519239" tabindex="0" loading="lazy"><figcaption>image-20231128204519239</figcaption></figure><p><strong>基本路径测试</strong></p><ul><li>圈复杂度：判断节点 + 1，区域的个数，边 - 节点 + 2</li><li>使用步骤： <ol><li>画控制图：先画流程图 -&gt; 控制流图</li><li>计算圈复杂度：这个说明需要多少个测试用例</li><li>导出测试用例：按照路径给予测试用例</li><li>写测试用例</li></ol></li></ul>',6),Q={href:"https://blog.csdn.net/XU_MAN_/article/details/102963251",target:"_blank",rel:"noopener noreferrer"},R={href:"https://zhuanlan.zhihu.com/p/43007988",target:"_blank",rel:"noopener noreferrer"},U=i("p",null,"z路径覆盖：对于循环体，只考虑执行0次和1次的情况",-1),W=i("figure",null,[i("img",{src:u,alt:"image-20231128205752430",tabindex:"0",loading:"lazy"}),i("figcaption",null,"image-20231128205752430")],-1),X=i("h3",{id:"集成测试",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#集成测试","aria-hidden":"true"},"#"),a(" 集成测试")],-1),G={href:"https://blog.csdn.net/weixin_45459356/article/details/117034268?app_version=6.1.4&code=app_1562916241&csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22117034268%22%2C%22source%22%3A%222301_80250292%22%7D&uLinkId=usr1mkqgl919blen&utm_source=app",target:"_blank",rel:"noopener noreferrer"},H={href:"https://developer.aliyun.com/article/1102979",target:"_blank",rel:"noopener noreferrer"},J=n('<figure><img src="'+m+'" alt="image-20231129172412206" tabindex="0" loading="lazy"><figcaption>image-20231129172412206</figcaption></figure><h3 id="控制流图-白盒测试" tabindex="-1"><a class="header-anchor" href="#控制流图-白盒测试" aria-hidden="true">#</a> 控制流图-白盒测试</h3><ol><li><p>将流程图简化为控制流图时，在选择或者多分支结构中，分支的汇聚处应有一个汇聚节点</p></li><li><p>一个判断是多条件的复合表达式的时候，需要改为多分支单条件</p><figure><img src="'+_+'" alt="image-20231128201053314" tabindex="0" loading="lazy"><figcaption>image-20231128201053314</figcaption></figure></li></ol><figure><img src="'+b+'" alt="image-20231128205712114" tabindex="0" loading="lazy"><figcaption>image-20231128205712114</figcaption></figure><hr><h2 id="sqa" tabindex="-1"><a class="header-anchor" href="#sqa" aria-hidden="true">#</a> SQA</h2><h3 id="软件质量控制基本概念" tabindex="-1"><a class="header-anchor" href="#软件质量控制基本概念" aria-hidden="true">#</a> 软件质量控制基本概念</h3><ul><li><p>软件质量控制是软件质量管理的<strong>指向器</strong>和<strong>原动力</strong></p></li><li><p>软件质量管理是软件质量控制的执行机构</p></li><li><p>质量控制承担了两个方面的度量：</p><ul><li>度量与计划和定义开发过程中的一致性</li><li>度量产品或阶段性产品是否达到了质量要求</li></ul></li></ul><h3 id="第一类测试和第二类测试" tabindex="-1"><a class="header-anchor" href="#第一类测试和第二类测试" aria-hidden="true">#</a> 第一类测试和第二类测试</h3><ul><li>第一类测试：验证软件是工作的，也就是说是按照预先设计的执行</li><li>第二类测试：验证软件是不工作的be</li></ul><p>本质区别：验证的目的不一样</p><figure><img src="'+x+'" alt="image-20231128142851889" tabindex="0" loading="lazy"><figcaption>image-20231128142851889</figcaption></figure><h3 id="软件缺陷" tabindex="-1"><a class="header-anchor" href="#软件缺陷" aria-hidden="true">#</a> 软件缺陷</h3><ul><li>软件出错</li><li>软件功能没满足需求</li><li>软件功能多余</li><li>软件未达到指定的目标</li><li>软件不好用</li></ul><figure><img src="'+z+'" alt="image-20231128142829513" tabindex="0" loading="lazy"><figcaption>image-20231128142829513</figcaption></figure><h3 id="pie模型-传播-propagation-感染-infection-执行-execution" tabindex="-1"><a class="header-anchor" href="#pie模型-传播-propagation-感染-infection-执行-execution" aria-hidden="true">#</a> PIE模型：传播（Propagation）-感染（Infection）-执行（Execution）</h3><p>相关概念：</p><ul><li>缺陷（Fault）：静态存在于代码中的错误行</li><li>错误（Error）：执行错误代码后导致内部错误。也就是报错</li><li>失败（Failure）：错误状态被捕获了，并且提供了给外部</li></ul><figure><img src="'+y+'" alt="image-20231128143314043" tabindex="0" loading="lazy"><figcaption>image-20231128143314043</figcaption></figure><figure><img src="'+k+'" alt="image-20231128143321795" tabindex="0" loading="lazy"><figcaption>image-20231128143321795</figcaption></figure><h3 id="软件测试模型" tabindex="-1"><a class="header-anchor" href="#软件测试模型" aria-hidden="true">#</a> 软件测试模型</h3><h4 id="v模型" tabindex="-1"><a class="header-anchor" href="#v模型" aria-hidden="true">#</a> V模型</h4><figure><img src="'+E+'" alt="image-20231128144540035" tabindex="0" loading="lazy"><figcaption>image-20231128144540035</figcaption></figure><figure><img src="'+I+'" alt="image-20231128144807819" tabindex="0" loading="lazy"><figcaption>image-20231128144807819</figcaption></figure>',24),K={id:"w模型",tabindex:"-1"},Y=i("a",{class:"header-anchor",href:"#w模型","aria-hidden":"true"},"#",-1),Z={href:"https://zhuanlan.zhihu.com/p/56673435",target:"_blank",rel:"noopener noreferrer"},$=n('<figure><img src="'+q+'" alt="image-20231128144839640" tabindex="0" loading="lazy"><figcaption>image-20231128144839640</figcaption></figure><figure><img src="'+v+'" alt="image-20231128144920540" tabindex="0" loading="lazy"><figcaption>image-20231128144920540</figcaption></figure><h3 id="测试阶段" tabindex="-1"><a class="header-anchor" href="#测试阶段" aria-hidden="true">#</a> 测试阶段</h3><ul><li>单元测试：针对代码的测试，函数的输入输出是否符合需求。模块的测试</li><li>集成测试：基于单元测试结束后，按照设计进行组装测试，测试各个模块连接是否有问题</li><li>系统测试：检查软件产品是否与系统的其他部分协调工作。比如操作系统，硬件等待，是否性能达标</li><li>验收测试：从用户的角度进行测试，是否符合用户的要求 <ul><li>Alpha版本：用户在开发环境下进行的测试</li><li>Beta版本：用户在用户环境下进行的测试</li><li>有α和β两种测试方法</li></ul></li></ul><figure><img src="'+A+'" alt="image-20231129194533951" tabindex="0" loading="lazy"><figcaption>image-20231129194533951</figcaption></figure><figure><img src="'+N+'" alt="image-20231129194547864" tabindex="0" loading="lazy"><figcaption>image-20231129194547864</figcaption></figure><figure><img src="'+C+'" alt="image-20231128145826998" tabindex="0" loading="lazy"><figcaption>image-20231128145826998</figcaption></figure><figure><img src="'+B+'" alt="image-20231128145839265" tabindex="0" loading="lazy"><figcaption>image-20231128145839265</figcaption></figure><h3 id="软件评审" tabindex="-1"><a class="header-anchor" href="#软件评审" aria-hidden="true">#</a> 软件评审</h3><h4 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h4><p>按照IEEE标准，软件评审时软件开发组之外的人员对<strong>软件需求，设计和代码</strong>进行详细审查的评价方法</p><figure><img src="'+V+'" alt="image-20231129195728815" tabindex="0" loading="lazy"><figcaption>image-20231129195728815</figcaption></figure><p>评审小组人员有：组长，评审员，宣读员，记录员，作者</p><h4 id="评审会议的一般流程" tabindex="-1"><a class="header-anchor" href="#评审会议的一般流程" aria-hidden="true">#</a> 评审会议的一般流程</h4><ol><li>评审预备：人员和议程介绍</li><li>作品介绍和问答</li><li>评审决议</li></ol><p>评审结束后，评审报告应该包含：会议的基本信息，存在的问题和解决措施，结论和意见，问题跟踪表，问答记录</p><h3 id="软件质量特性" tabindex="-1"><a class="header-anchor" href="#软件质量特性" aria-hidden="true">#</a> 软件质量特性</h3><figure><img src="'+w+'" alt="image-20231129202240736" tabindex="0" loading="lazy"><figcaption>image-20231129202240736</figcaption></figure>',18);function ii(ai,ei){const e=r("ExternalLinkIcon");return s(),g("div",null,[D,i("ul",null,[L,i("li",null,[i("p",null,[a("判断表："),i("a",T,[a("常用测试用例设计方法3-判定表法-CSDN博客"),t(e)])])]),j]),F,i("blockquote",null,[i("p",null,[i("a",M,[a("完美诠释因果图与判定表法 - 知乎 (zhihu.com)"),t(e)])]),i("p",null,[i("a",P,[a("黑盒测试"),t(e)])])]),O,i("blockquote",null,[i("p",null,[i("a",Q,[a("基本路径测试"),t(e)])]),i("p",null,[i("a",R,[a("覆盖率计算"),t(e)])])]),U,W,X,i("ul",null,[i("li",null,[i("a",G,[a("集成测试_维维sanguine的博客-CSDN博客"),t(e)])]),i("li",null,[i("a",H,[a("集成测试之自顶向下、自底向上、三明治集成-阿里云开发者社区 (aliyun.com)"),t(e)])])]),J,i("h4",K,[Y,a(),i("a",Z,[a("W模型"),t(e)])]),$])}const li=l(S,[["render",ii],["__file","测试.html.vue"]]);export{li as default};
